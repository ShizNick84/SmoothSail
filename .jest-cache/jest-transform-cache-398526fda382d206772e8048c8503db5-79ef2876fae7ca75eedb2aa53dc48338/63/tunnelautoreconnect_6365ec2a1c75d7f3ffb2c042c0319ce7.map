{"file":"C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\infrastructure\\tunnel-auto-reconnect.ts","mappings":"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","names":[],"sources":["C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\infrastructure\\tunnel-auto-reconnect.ts"],"sourcesContent":["import { EventEmitter } from 'events';\r\nimport { Logger } from '../core/logging/logger';\r\nimport { SSHTunnelManager, TunnelConnection, TunnelState } from './ssh-tunnel-manager';\r\nimport { TunnelHealthMonitor, TunnelHealthMetrics } from './tunnel-health-monitor';\r\nimport { TunnelStateTracker } from './tunnel-state-tracker';\r\n\r\n/**\r\n * Reconnection strategy configuration\r\n */\r\nexport interface ReconnectionConfig {\r\n  /** Enable automatic reconnection */\r\n  enabled: boolean;\r\n  /** Initial retry delay in milliseconds */\r\n  initialRetryDelay: number;\r\n  /** Maximum retry delay in milliseconds */\r\n  maxRetryDelay: number;\r\n  /** Exponential backoff multiplier */\r\n  backoffMultiplier: number;\r\n  /** Maximum number of retry attempts */\r\n  maxRetryAttempts: number;\r\n  /** Reset retry count after successful connection duration (ms) */\r\n  resetRetryCountAfter: number;\r\n  /** Health check threshold for triggering reconnection */\r\n  healthThreshold: number;\r\n  /** Consecutive failure threshold for triggering reconnection */\r\n  failureThreshold: number;\r\n  /** Jitter factor for retry delays (0-1) */\r\n  jitterFactor: number;\r\n}\r\n\r\n/**\r\n * Reconnection attempt information\r\n */\r\nexport interface ReconnectionAttempt {\r\n  connectionId: string;\r\n  attemptNumber: number;\r\n  timestamp: Date;\r\n  reason: string;\r\n  success: boolean;\r\n  error?: Error;\r\n  duration: number;\r\n  nextRetryDelay?: number;\r\n}\r\n\r\n/**\r\n * Reconnection statistics\r\n */\r\nexport interface ReconnectionStats {\r\n  connectionId: string;\r\n  totalAttempts: number;\r\n  successfulAttempts: number;\r\n  failedAttempts: number;\r\n  averageReconnectionTime: number;\r\n  longestDowntime: number;\r\n  shortestDowntime: number;\r\n  lastReconnectionAttempt: Date | null;\r\n  currentRetryCount: number;\r\n  isReconnecting: boolean;\r\n}\r\n\r\n/**\r\n * Tunnel Auto-Reconnection Manager\r\n * Implements intelligent auto-reconnection with exponential backoff and failure detection\r\n */\r\nexport class TunnelAutoReconnect extends EventEmitter {\r\n  private logger: Logger;\r\n  private tunnelManager: SSHTunnelManager;\r\n  private healthMonitor: TunnelHealthMonitor;\r\n  private stateTracker: TunnelStateTracker;\r\n  private config: ReconnectionConfig;\r\n  private reconnectionStats: Map<string, ReconnectionStats>;\r\n  private reconnectionTimers: Map<string, NodeJS.Timeout>;\r\n  private reconnectionAttempts: Map<string, ReconnectionAttempt[]>;\r\n  private isEnabled: boolean;\r\n\r\n  constructor(\r\n    logger: Logger,\r\n    tunnelManager: SSHTunnelManager,\r\n    healthMonitor: TunnelHealthMonitor,\r\n    stateTracker: TunnelStateTracker,\r\n    config?: Partial<ReconnectionConfig>\r\n  ) {\r\n    super();\r\n    this.logger = logger;\r\n    this.tunnelManager = tunnelManager;\r\n    this.healthMonitor = healthMonitor;\r\n    this.stateTracker = stateTracker;\r\n    this.reconnectionStats = new Map();\r\n    this.reconnectionTimers = new Map();\r\n    this.reconnectionAttempts = new Map();\r\n    this.isEnabled = false;\r\n\r\n    // Default configuration\r\n    this.config = {\r\n      enabled: true,\r\n      initialRetryDelay: 5000, // 5 seconds\r\n      maxRetryDelay: 300000, // 5 minutes\r\n      backoffMultiplier: 2,\r\n      maxRetryAttempts: 10,\r\n      resetRetryCountAfter: 300000, // 5 minutes\r\n      healthThreshold: 30,\r\n      failureThreshold: 3,\r\n      jitterFactor: 0.1,\r\n      ...config\r\n    };\r\n\r\n    this.setupEventListeners();\r\n    this.logger.info('Tunnel Auto-Reconnection Manager initialized', this.config);\r\n  }\r\n\r\n  /**\r\n   * Enable auto-reconnection\r\n   */\r\n  enable(): void {\r\n    if (this.isEnabled) {\r\n      this.logger.warn('Auto-reconnection is already enabled');\r\n      return;\r\n    }\r\n\r\n    this.isEnabled = true;\r\n    this.logger.info('Auto-reconnection enabled');\r\n\r\n    // Check existing connections for health issues\r\n    this.checkExistingConnections();\r\n\r\n    this.emit('autoReconnectEnabled');\r\n  }\r\n\r\n  /**\r\n   * Disable auto-reconnection\r\n   */\r\n  disable(): void {\r\n    if (!this.isEnabled) {\r\n      this.logger.warn('Auto-reconnection is already disabled');\r\n      return;\r\n    }\r\n\r\n    this.isEnabled = false;\r\n    this.logger.info('Auto-reconnection disabled');\r\n\r\n    // Cancel all pending reconnection attempts\r\n    this.cancelAllReconnectionAttempts();\r\n\r\n    this.emit('autoReconnectDisabled');\r\n  }\r\n\r\n  /**\r\n   * Get reconnection statistics for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @returns Reconnection statistics or undefined\r\n   */\r\n  getReconnectionStats(connectionId: string): ReconnectionStats | undefined {\r\n    return this.reconnectionStats.get(connectionId);\r\n  }\r\n\r\n  /**\r\n   * Get all reconnection statistics\r\n   * \r\n   * @returns Map of all reconnection statistics\r\n   */\r\n  getAllReconnectionStats(): Map<string, ReconnectionStats> {\r\n    return new Map(this.reconnectionStats);\r\n  }\r\n\r\n  /**\r\n   * Get reconnection attempt history for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @param limit - Maximum number of attempts to return\r\n   * @returns Array of reconnection attempts\r\n   */\r\n  getReconnectionHistory(connectionId: string, limit?: number): ReconnectionAttempt[] {\r\n    const attempts = this.reconnectionAttempts.get(connectionId) || [];\r\n    return limit ? attempts.slice(-limit) : [...attempts];\r\n  }\r\n\r\n  /**\r\n   * Force reconnection for a specific connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @param reason - Reason for forced reconnection\r\n   * @returns Promise resolving when reconnection is complete\r\n   */\r\n  async forceReconnection(connectionId: string, reason: string = 'Manual reconnection'): Promise<void> {\r\n    const connection = this.tunnelManager.getConnection(connectionId);\r\n    if (!connection) {\r\n      throw new Error(`Connection not found: ${connectionId}`);\r\n    }\r\n\r\n    this.logger.info(`Forcing reconnection for connection: ${connectionId}`, { reason });\r\n\r\n    // Cancel any pending reconnection\r\n    this.cancelReconnectionAttempt(connectionId);\r\n\r\n    // Perform immediate reconnection\r\n    await this.performReconnection(connectionId, reason, 0);\r\n  }\r\n\r\n  /**\r\n   * Update reconnection configuration\r\n   * \r\n   * @param newConfig - New configuration parameters\r\n   */\r\n  updateConfig(newConfig: Partial<ReconnectionConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n    this.logger.info('Auto-reconnection configuration updated', this.config);\r\n    this.emit('configUpdated', this.config);\r\n  }\r\n\r\n  /**\r\n   * Setup event listeners for tunnel events\r\n   */\r\n  private setupEventListeners(): void {\r\n    // Listen for tunnel disconnections\r\n    this.tunnelManager.on('tunnelDisconnected', (connection) => {\r\n      if (this.isEnabled) {\r\n        this.handleConnectionLoss(connection, 'Tunnel disconnected');\r\n      }\r\n    });\r\n\r\n    // Listen for tunnel errors\r\n    this.tunnelManager.on('tunnelError', (connection, error) => {\r\n      if (this.isEnabled) {\r\n        this.handleConnectionLoss(connection, `Tunnel error: ${error.message}`);\r\n      }\r\n    });\r\n\r\n    // Listen for health issues\r\n    this.healthMonitor.on('connectionUnhealthy', (connection, metrics) => {\r\n      if (this.isEnabled) {\r\n        this.handleHealthIssue(connection, metrics);\r\n      }\r\n    });\r\n\r\n    // Listen for successful connections to reset retry counts\r\n    this.tunnelManager.on('tunnelConnected', (connection) => {\r\n      this.handleSuccessfulConnection(connection);\r\n    });\r\n\r\n    // Listen for state changes\r\n    this.stateTracker.on('connectionFailed', (connection, stateChangeEvent) => {\r\n      if (this.isEnabled) {\r\n        this.handleConnectionFailure(connection, 'Connection failed');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check existing connections for health issues\r\n   */\r\n  private checkExistingConnections(): void {\r\n    const connections = this.tunnelManager.getAllConnections();\r\n    \r\n    for (const connection of connections) {\r\n      // Initialize stats if not exists\r\n      this.initializeReconnectionStats(connection.id);\r\n\r\n      // Check if connection needs reconnection\r\n      if (connection.state === TunnelState.FAILED || connection.state === TunnelState.DISCONNECTED) {\r\n        this.handleConnectionLoss(connection, 'Connection check on enable');\r\n      } else {\r\n        // Check health metrics\r\n        const healthMetrics = this.healthMonitor.getHealthMetrics(connection.id);\r\n        if (healthMetrics && !healthMetrics.isHealthy) {\r\n          this.handleHealthIssue(connection, healthMetrics);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle connection loss event\r\n   * \r\n   * @param connection - Lost connection\r\n   * @param reason - Reason for connection loss\r\n   */\r\n  private handleConnectionLoss(connection: TunnelConnection, reason: string): void {\r\n    if (!this.config.enabled) return;\r\n\r\n    this.logger.warn(`Connection lost: ${connection.id}`, { reason });\r\n\r\n    // Initialize stats if not exists\r\n    this.initializeReconnectionStats(connection.id);\r\n\r\n    // Schedule reconnection\r\n    this.scheduleReconnection(connection.id, reason);\r\n  }\r\n\r\n  /**\r\n   * Handle health issue event\r\n   * \r\n   * @param connection - Connection with health issues\r\n   * @param metrics - Health metrics\r\n   */\r\n  private handleHealthIssue(connection: TunnelConnection, metrics: TunnelHealthMetrics): void {\r\n    if (!this.config.enabled) return;\r\n\r\n    // Check if health is below threshold\r\n    if (metrics.healthScore < this.config.healthThreshold) {\r\n      this.logger.warn(`Connection health below threshold: ${connection.id}`, {\r\n        healthScore: metrics.healthScore,\r\n        threshold: this.config.healthThreshold\r\n      });\r\n\r\n      this.scheduleReconnection(connection.id, `Health score below threshold: ${metrics.healthScore}`);\r\n    }\r\n\r\n    // Check for consecutive failures\r\n    if (metrics.consecutiveFailures >= this.config.failureThreshold) {\r\n      this.logger.warn(`Connection has too many consecutive failures: ${connection.id}`, {\r\n        failures: metrics.consecutiveFailures,\r\n        threshold: this.config.failureThreshold\r\n      });\r\n\r\n      this.scheduleReconnection(connection.id, `Too many consecutive failures: ${metrics.consecutiveFailures}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle connection failure event\r\n   * \r\n   * @param connection - Failed connection\r\n   * @param reason - Reason for failure\r\n   */\r\n  private handleConnectionFailure(connection: TunnelConnection, reason: string): void {\r\n    if (!this.config.enabled) return;\r\n\r\n    this.logger.error(`Connection failed: ${connection.id}`, { reason });\r\n    this.scheduleReconnection(connection.id, reason);\r\n  }\r\n\r\n  /**\r\n   * Handle successful connection event\r\n   * \r\n   * @param connection - Successfully connected tunnel\r\n   */\r\n  private handleSuccessfulConnection(connection: TunnelConnection): void {\r\n    const stats = this.reconnectionStats.get(connection.id);\r\n    if (!stats) return;\r\n\r\n    // Cancel any pending reconnection\r\n    this.cancelReconnectionAttempt(connection.id);\r\n\r\n    // Update stats\r\n    stats.isReconnecting = false;\r\n    stats.successfulAttempts++;\r\n\r\n    // Reset retry count after successful connection\r\n    setTimeout(() => {\r\n      if (stats.currentRetryCount > 0) {\r\n        this.logger.info(`Resetting retry count for connection: ${connection.id}`);\r\n        stats.currentRetryCount = 0;\r\n      }\r\n    }, this.config.resetRetryCountAfter);\r\n\r\n    this.logger.info(`Connection successfully established: ${connection.id}`);\r\n    this.emit('reconnectionSuccessful', connection, stats);\r\n  }\r\n\r\n  /**\r\n   * Schedule reconnection attempt\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @param reason - Reason for reconnection\r\n   */\r\n  private scheduleReconnection(connectionId: string, reason: string): void {\r\n    // Cancel any existing reconnection timer\r\n    this.cancelReconnectionAttempt(connectionId);\r\n\r\n    const stats = this.reconnectionStats.get(connectionId);\r\n    if (!stats) {\r\n      this.initializeReconnectionStats(connectionId);\r\n      return this.scheduleReconnection(connectionId, reason);\r\n    }\r\n\r\n    // Check if max attempts reached\r\n    if (stats.currentRetryCount >= this.config.maxRetryAttempts) {\r\n      this.logger.error(`Max reconnection attempts reached for connection: ${connectionId}`, {\r\n        attempts: stats.currentRetryCount,\r\n        maxAttempts: this.config.maxRetryAttempts\r\n      });\r\n      \r\n      stats.isReconnecting = false;\r\n      this.emit('reconnectionFailed', connectionId, stats, 'Max attempts reached');\r\n      return;\r\n    }\r\n\r\n    // Calculate retry delay with exponential backoff and jitter\r\n    const baseDelay = Math.min(\r\n      this.config.initialRetryDelay * Math.pow(this.config.backoffMultiplier, stats.currentRetryCount),\r\n      this.config.maxRetryDelay\r\n    );\r\n\r\n    // Add jitter to prevent thundering herd\r\n    const jitter = baseDelay * this.config.jitterFactor * (Math.random() - 0.5);\r\n    const retryDelay = Math.max(1000, baseDelay + jitter); // Minimum 1 second\r\n\r\n    this.logger.info(`Scheduling reconnection for connection: ${connectionId}`, {\r\n      reason,\r\n      attempt: stats.currentRetryCount + 1,\r\n      delay: `${retryDelay}ms`\r\n    });\r\n\r\n    // Update stats\r\n    stats.isReconnecting = true;\r\n    stats.currentRetryCount++;\r\n\r\n    // Schedule reconnection\r\n    const timer = setTimeout(async () => {\r\n      try {\r\n        await this.performReconnection(connectionId, reason, stats.currentRetryCount);\r\n      } catch (error) {\r\n        this.logger.error(`Reconnection attempt failed: ${connectionId}`, error);\r\n        \r\n        // Schedule next attempt if not at max\r\n        if (stats.currentRetryCount < this.config.maxRetryAttempts) {\r\n          this.scheduleReconnection(connectionId, `Retry after failure: ${error instanceof Error ? error.message : String(error)}`);\r\n        } else {\r\n          stats.isReconnecting = false;\r\n          this.emit('reconnectionFailed', connectionId, stats, 'All attempts exhausted');\r\n        }\r\n      }\r\n    }, retryDelay);\r\n\r\n    this.reconnectionTimers.set(connectionId, timer);\r\n    this.emit('reconnectionScheduled', connectionId, stats, retryDelay);\r\n  }\r\n\r\n  /**\r\n   * Perform actual reconnection attempt\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @param reason - Reason for reconnection\r\n   * @param attemptNumber - Current attempt number\r\n   */\r\n  private async performReconnection(connectionId: string, reason: string, attemptNumber: number): Promise<void> {\r\n    const connection = this.tunnelManager.getConnection(connectionId);\r\n    if (!connection) {\r\n      throw new Error(`Connection not found: ${connectionId}`);\r\n    }\r\n\r\n    const stats = this.reconnectionStats.get(connectionId);\r\n    if (!stats) {\r\n      throw new Error(`Reconnection stats not found: ${connectionId}`);\r\n    }\r\n\r\n    const startTime = Date.now();\r\n    const attempt: ReconnectionAttempt = {\r\n      connectionId,\r\n      attemptNumber,\r\n      timestamp: new Date(),\r\n      reason,\r\n      success: false,\r\n      duration: 0\r\n    };\r\n\r\n    try {\r\n      this.logger.info(`Attempting reconnection: ${connectionId}`, {\r\n        attempt: attemptNumber,\r\n        reason\r\n      });\r\n\r\n      // Disconnect existing connection if still connected\r\n      if (connection.state === TunnelState.CONNECTED) {\r\n        await this.tunnelManager.disconnectTunnel(connectionId);\r\n      }\r\n\r\n      // Wait a moment before reconnecting\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n      // Attempt to establish new connection\r\n      await this.tunnelManager.establishTunnel(connectionId);\r\n\r\n      // Success\r\n      attempt.success = true;\r\n      attempt.duration = Date.now() - startTime;\r\n\r\n      // Update stats\r\n      stats.totalAttempts++;\r\n      stats.successfulAttempts++;\r\n      stats.lastReconnectionAttempt = new Date();\r\n      stats.isReconnecting = false;\r\n\r\n      // Calculate average reconnection time\r\n      if (stats.successfulAttempts > 0) {\r\n        const totalTime = this.getReconnectionHistory(connectionId)\r\n          .filter(a => a.success)\r\n          .reduce((sum, a) => sum + a.duration, 0);\r\n        stats.averageReconnectionTime = totalTime / stats.successfulAttempts;\r\n      }\r\n\r\n      this.logger.info(`Reconnection successful: ${connectionId}`, {\r\n        attempt: attemptNumber,\r\n        duration: `${attempt.duration}ms`\r\n      });\r\n\r\n      this.emit('reconnectionAttemptSuccessful', connection, attempt, stats);\r\n\r\n    } catch (error) {\r\n      // Failure\r\n      attempt.success = false;\r\n      attempt.error = error instanceof Error ? error : new Error(String(error));\r\n      attempt.duration = Date.now() - startTime;\r\n\r\n      // Update stats\r\n      stats.totalAttempts++;\r\n      stats.failedAttempts++;\r\n      stats.lastReconnectionAttempt = new Date();\r\n\r\n      this.logger.error(`Reconnection attempt failed: ${connectionId}`, {\r\n        attempt: attemptNumber,\r\n        error: attempt.error.message,\r\n        duration: `${attempt.duration}ms`\r\n      });\r\n\r\n      this.emit('reconnectionAttemptFailed', connection, attempt, stats);\r\n      throw attempt.error;\r\n\r\n    } finally {\r\n      // Store attempt in history\r\n      this.storeReconnectionAttempt(connectionId, attempt);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel reconnection attempt for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   */\r\n  private cancelReconnectionAttempt(connectionId: string): void {\r\n    const timer = this.reconnectionTimers.get(connectionId);\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      this.reconnectionTimers.delete(connectionId);\r\n      \r\n      const stats = this.reconnectionStats.get(connectionId);\r\n      if (stats) {\r\n        stats.isReconnecting = false;\r\n      }\r\n\r\n      this.logger.debug(`Cancelled reconnection attempt for connection: ${connectionId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancel all pending reconnection attempts\r\n   */\r\n  private cancelAllReconnectionAttempts(): void {\r\n    for (const [connectionId, timer] of this.reconnectionTimers.entries()) {\r\n      clearTimeout(timer);\r\n      \r\n      const stats = this.reconnectionStats.get(connectionId);\r\n      if (stats) {\r\n        stats.isReconnecting = false;\r\n      }\r\n    }\r\n\r\n    this.reconnectionTimers.clear();\r\n    this.logger.info('Cancelled all pending reconnection attempts');\r\n  }\r\n\r\n  /**\r\n   * Initialize reconnection statistics for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   */\r\n  private initializeReconnectionStats(connectionId: string): void {\r\n    if (this.reconnectionStats.has(connectionId)) {\r\n      return;\r\n    }\r\n\r\n    const stats: ReconnectionStats = {\r\n      connectionId,\r\n      totalAttempts: 0,\r\n      successfulAttempts: 0,\r\n      failedAttempts: 0,\r\n      averageReconnectionTime: 0,\r\n      longestDowntime: 0,\r\n      shortestDowntime: Infinity,\r\n      lastReconnectionAttempt: null,\r\n      currentRetryCount: 0,\r\n      isReconnecting: false\r\n    };\r\n\r\n    this.reconnectionStats.set(connectionId, stats);\r\n    this.reconnectionAttempts.set(connectionId, []);\r\n  }\r\n\r\n  /**\r\n   * Store reconnection attempt in history\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @param attempt - Reconnection attempt to store\r\n   */\r\n  private storeReconnectionAttempt(connectionId: string, attempt: ReconnectionAttempt): void {\r\n    if (!this.reconnectionAttempts.has(connectionId)) {\r\n      this.reconnectionAttempts.set(connectionId, []);\r\n    }\r\n\r\n    const attempts = this.reconnectionAttempts.get(connectionId)!;\r\n    attempts.push(attempt);\r\n\r\n    // Limit history size\r\n    const maxHistorySize = 100;\r\n    if (attempts.length > maxHistorySize) {\r\n      attempts.splice(0, attempts.length - maxHistorySize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cleanup auto-reconnection resources\r\n   */\r\n  cleanup(): void {\r\n    this.disable();\r\n    this.reconnectionStats.clear();\r\n    this.reconnectionAttempts.clear();\r\n    this.logger.info('Tunnel auto-reconnection cleanup completed');\r\n  }\r\n}\r\n"],"version":3}