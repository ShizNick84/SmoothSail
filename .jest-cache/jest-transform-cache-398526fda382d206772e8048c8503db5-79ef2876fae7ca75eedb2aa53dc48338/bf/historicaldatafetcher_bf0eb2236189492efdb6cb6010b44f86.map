{"file":"C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\trading\\backtesting\\historical-data-fetcher.ts","mappings":"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","names":[],"sources":["C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\trading\\backtesting\\historical-data-fetcher.ts"],"sourcesContent":["/**\r\n * =============================================================================\r\n * HISTORICAL DATA FETCHER - REAL MARKET DATA ONLY\r\n * =============================================================================\r\n * \r\n * This module fetches and validates historical market data from Gate.io API\r\n * for backtesting purposes. CRITICAL: NO MOCK DATA ALLOWED - only real\r\n * historical market data is used to ensure accurate backtesting results.\r\n * \r\n * SECURITY FEATURES:\r\n * - Data integrity verification with cryptographic hashes\r\n * - Comprehensive data validation and gap detection\r\n * - Rate limiting and API health monitoring\r\n * - Audit logging for all data fetching operations\r\n * \r\n * @author AI Crypto Trading System\r\n * @version 1.0.0\r\n * @license PROPRIETARY\r\n * =============================================================================\r\n */\r\n\r\nimport crypto from 'crypto';\r\nimport { logger } from '@/core/logging/logger';\r\nimport { AuditService } from '@/security/audit-service';\r\nimport { GateIOClient } from '../api/gate-io-client';\r\nimport { \r\n  HistoricalMarketData, \r\n  DataValidationResult, \r\n  DataGap,\r\n  BacktestConfig \r\n} from './types';\r\nimport { MarketData } from '../strategies/types';\r\nimport { Candlestick } from '../api/types';\r\n\r\n/**\r\n * Time intervals supported by Gate.io API\r\n */\r\nexport type TimeInterval = '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d';\r\n\r\n/**\r\n * Data fetching configuration\r\n */\r\ninterface DataFetchConfig {\r\n  symbol: string;\r\n  interval: TimeInterval;\r\n  startTime: Date;\r\n  endTime: Date;\r\n  maxRetries: number;\r\n  batchSize: number; // Number of candles per request\r\n  validateIntegrity: boolean;\r\n}\r\n\r\n/**\r\n * Data fetching statistics\r\n */\r\ninterface FetchStatistics {\r\n  totalRequests: number;\r\n  successfulRequests: number;\r\n  failedRequests: number;\r\n  totalDataPoints: number;\r\n  validDataPoints: number;\r\n  duplicatesRemoved: number;\r\n  gapsDetected: number;\r\n  fetchDuration: number; // in milliseconds\r\n  averageRequestTime: number;\r\n}\r\n\r\n/**\r\n * Historical Data Fetcher with comprehensive validation\r\n */\r\nexport class HistoricalDataFetcher {\r\n  private gateIOClient: GateIOClient;\r\n  private auditService: AuditService;\r\n  private fetchStatistics: FetchStatistics;\r\n\r\n  constructor(gateIOClient: GateIOClient) {\r\n    this.gateIOClient = gateIOClient;\r\n    this.auditService = new AuditService();\r\n    this.resetStatistics();\r\n    \r\n    logger.info('📊 Historical Data Fetcher initialized - REAL DATA ONLY');\r\n  }\r\n\r\n  /**\r\n   * Fetch historical market data for backtesting\r\n   * CRITICAL: Only real market data from Gate.io API - NO MOCK DATA\r\n   */\r\n  public async fetchHistoricalData(config: DataFetchConfig): Promise<HistoricalMarketData[]> {\r\n    const startTime = Date.now();\r\n    this.resetStatistics();\r\n    \r\n    try {\r\n      logger.info(`📈 Fetching historical data for ${config.symbol} from ${config.startTime.toISOString()} to ${config.endTime.toISOString()}`);\r\n      \r\n      // Validate configuration\r\n      this.validateFetchConfig(config);\r\n      \r\n      // Calculate time range and batch requests\r\n      const batches = this.calculateBatches(config);\r\n      logger.info(`📦 Splitting request into ${batches.length} batches`);\r\n      \r\n      // Fetch data in batches to respect API limits\r\n      const allData: HistoricalMarketData[] = [];\r\n      \r\n      for (let i = 0; i < batches.length; i++) {\r\n        const batch = batches[i];\r\n        logger.info(`📥 Fetching batch ${i + 1}/${batches.length}: ${batch.start.toISOString()} to ${batch.end.toISOString()}`);\r\n        \r\n        try {\r\n          const batchData = await this.fetchBatch(config.symbol, config.interval, batch.start, batch.end);\r\n          allData.push(...batchData);\r\n          this.fetchStatistics.successfulRequests++;\r\n          \r\n          // Add delay between batches to respect rate limits\r\n          if (i < batches.length - 1) {\r\n            await this.delay(1000); // 1 second delay\r\n          }\r\n          \r\n        } catch (error) {\r\n          logger.error(`❌ Failed to fetch batch ${i + 1}:`, error);\r\n          this.fetchStatistics.failedRequests++;\r\n          \r\n          // Retry failed batch\r\n          if (this.fetchStatistics.failedRequests <= config.maxRetries) {\r\n            logger.info(`🔄 Retrying batch ${i + 1} (attempt ${this.fetchStatistics.failedRequests})`);\r\n            i--; // Retry current batch\r\n            await this.delay(2000); // 2 second delay before retry\r\n          } else {\r\n            throw new Error(`Failed to fetch batch after ${config.maxRetries} retries`);\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Sort data by timestamp\r\n      allData.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\r\n      \r\n      // Remove duplicates\r\n      const uniqueData = this.removeDuplicates(allData);\r\n      this.fetchStatistics.duplicatesRemoved = allData.length - uniqueData.length;\r\n      \r\n      // Validate data integrity\r\n      const validatedData = config.validateIntegrity \r\n        ? await this.validateDataIntegrity(uniqueData)\r\n        : uniqueData;\r\n      \r\n      // Update statistics\r\n      this.fetchStatistics.totalDataPoints = validatedData.length;\r\n      this.fetchStatistics.validDataPoints = validatedData.filter(d => d.validated).length;\r\n      this.fetchStatistics.fetchDuration = Date.now() - startTime;\r\n      this.fetchStatistics.averageRequestTime = this.fetchStatistics.fetchDuration / this.fetchStatistics.totalRequests;\r\n      \r\n      // Log audit event\r\n      await this.auditService.logSecurityEvent({\r\n        type: 'HISTORICAL_DATA_FETCHED',\r\n        severity: 'INFO',\r\n        details: {\r\n          symbol: config.symbol,\r\n          interval: config.interval,\r\n          dataPoints: validatedData.length,\r\n          statistics: this.fetchStatistics,\r\n        },\r\n        timestamp: new Date(),\r\n      });\r\n      \r\n      logger.info(`✅ Successfully fetched ${validatedData.length} historical data points for ${config.symbol}`);\r\n      logger.info(`📊 Fetch Statistics:`, this.fetchStatistics);\r\n      \r\n      return validatedData;\r\n      \r\n    } catch (error) {\r\n      logger.error('❌ Failed to fetch historical data:', error);\r\n      \r\n      await this.auditService.logSecurityEvent({\r\n        type: 'HISTORICAL_DATA_FETCH_FAILED',\r\n        severity: 'ERROR',\r\n        details: {\r\n          symbol: config.symbol,\r\n          error: error.message,\r\n          statistics: this.fetchStatistics,\r\n        },\r\n        timestamp: new Date(),\r\n      });\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch historical data for backtesting configuration\r\n   */\r\n  public async fetchForBacktest(backtestConfig: BacktestConfig): Promise<HistoricalMarketData[]> {\r\n    // Determine appropriate interval based on backtest duration\r\n    const durationDays = (backtestConfig.endDate.getTime() - backtestConfig.startDate.getTime()) / (1000 * 60 * 60 * 24);\r\n    const interval = this.determineOptimalInterval(durationDays);\r\n    \r\n    const fetchConfig: DataFetchConfig = {\r\n      symbol: backtestConfig.symbol,\r\n      interval,\r\n      startTime: backtestConfig.startDate,\r\n      endTime: backtestConfig.endDate,\r\n      maxRetries: 3,\r\n      batchSize: 1000,\r\n      validateIntegrity: backtestConfig.dataValidation.requireRealData,\r\n    };\r\n    \r\n    return this.fetchHistoricalData(fetchConfig);\r\n  }\r\n\r\n  /**\r\n   * Validate fetched data for backtesting requirements\r\n   * CRITICAL: Enforces NO MOCK DATA policy\r\n   */\r\n  public async validateForBacktesting(\r\n    data: HistoricalMarketData[], \r\n    config: BacktestConfig\r\n  ): Promise<DataValidationResult> {\r\n    logger.info('🔍 Validating historical data for backtesting - REAL DATA ONLY...');\r\n    \r\n    const validation: DataValidationResult = {\r\n      isValid: true,\r\n      totalPoints: data.length,\r\n      validPoints: 0,\r\n      invalidPoints: 0,\r\n      gaps: [],\r\n      integrityScore: 0,\r\n      errors: [],\r\n      warnings: [],\r\n    };\r\n    \r\n    // CRITICAL: Enforce real data only policy\r\n    if (config.dataValidation.requireRealData) {\r\n      const mockDataPoints = data.filter(d => d.source !== 'GATE_IO' || !d.validated);\r\n      if (mockDataPoints.length > 0) {\r\n        validation.isValid = false;\r\n        validation.errors.push(`CRITICAL: Mock data detected - ${mockDataPoints.length} invalid points. Only real Gate.io data allowed.`);\r\n        \r\n        // Log details of mock data for debugging\r\n        for (const mockPoint of mockDataPoints.slice(0, 5)) { // Log first 5 for debugging\r\n          logger.error(`❌ Mock data point: ${mockPoint.symbol} at ${mockPoint.timestamp.toISOString()}, source: ${mockPoint.source}, validated: ${mockPoint.validated}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Check minimum data points requirement\r\n    if (data.length < config.dataValidation.minDataPoints) {\r\n      validation.isValid = false;\r\n      validation.errors.push(`Insufficient data points: ${data.length} < ${config.dataValidation.minDataPoints}`);\r\n    }\r\n    \r\n    // Validate each data point for market data integrity\r\n    for (let i = 0; i < data.length; i++) {\r\n      const point = data[i];\r\n      \r\n      if (this.isValidDataPoint(point) && this.isRealMarketData(point)) {\r\n        validation.validPoints++;\r\n      } else {\r\n        validation.invalidPoints++;\r\n        validation.warnings.push(`Invalid data point at index ${i}: ${point.timestamp.toISOString()}`);\r\n      }\r\n    }\r\n    \r\n    // Detect gaps in data\r\n    validation.gaps = this.detectDataGaps(data, config.dataValidation.maxGapMinutes);\r\n    \r\n    // Check for critical gaps that could affect backtesting accuracy\r\n    const criticalGaps = validation.gaps.filter(gap => gap.severity === 'HIGH');\r\n    if (criticalGaps.length > 0) {\r\n      validation.isValid = false;\r\n      validation.errors.push(`Critical data gaps detected: ${criticalGaps.length} gaps > ${config.dataValidation.maxGapMinutes * 3} minutes`);\r\n    }\r\n    \r\n    // Calculate integrity score\r\n    validation.integrityScore = this.calculateIntegrityScore(validation);\r\n    \r\n    // Additional validation for backtesting quality\r\n    const dataQualityScore = this.calculateDataQualityScore(data);\r\n    if (dataQualityScore < 90) {\r\n      validation.warnings.push(`Data quality score below threshold: ${dataQualityScore}% < 90%`);\r\n    }\r\n    \r\n    // Validate data source authenticity (redundant check for extra security)\r\n    const realDataPoints = data.filter(d => d.source === 'GATE_IO' && d.validated).length;\r\n    if (config.dataValidation.requireRealData && realDataPoints < data.length) {\r\n      validation.isValid = false;\r\n      validation.errors.push(`SECURITY VIOLATION: Mock or tampered data detected: ${data.length - realDataPoints} suspicious points`);\r\n    }\r\n    \r\n    // Log comprehensive validation results\r\n    logger.info(`✅ Data validation completed: ${validation.isValid ? 'VALID' : 'INVALID'}`);\r\n    logger.info(`📊 Validation Results:`, {\r\n      totalPoints: validation.totalPoints,\r\n      validPoints: validation.validPoints,\r\n      invalidPoints: validation.invalidPoints,\r\n      gaps: validation.gaps.length,\r\n      integrityScore: validation.integrityScore,\r\n      dataQualityScore,\r\n      realDataPercentage: (realDataPoints / data.length * 100).toFixed(2) + '%',\r\n    });\r\n    \r\n    if (!validation.isValid) {\r\n      logger.error('❌ Data validation failed:', validation.errors);\r\n    }\r\n    \r\n    return validation;\r\n  }\r\n\r\n  /**\r\n   * Verify that data point is real market data from Gate.io\r\n   */\r\n  private isRealMarketData(point: HistoricalMarketData): boolean {\r\n    // Check source authenticity\r\n    if (point.source !== 'GATE_IO') {\r\n      return false;\r\n    }\r\n    \r\n    // Check validation flag\r\n    if (!point.validated) {\r\n      return false;\r\n    }\r\n    \r\n    // Check integrity hash exists\r\n    if (!point.integrity || point.integrity.length < 10) {\r\n      return false;\r\n    }\r\n    \r\n    // Check fetch timestamp is reasonable\r\n    if (!point.fetchedAt || point.fetchedAt > new Date()) {\r\n      return false;\r\n    }\r\n    \r\n    // Additional checks for realistic market data patterns\r\n    if (!this.hasRealisticMarketPatterns(point)) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Check if data point has realistic market patterns\r\n   */\r\n  private hasRealisticMarketPatterns(point: HistoricalMarketData): boolean {\r\n    // Check for unrealistic price movements (> 50% in one candle)\r\n    const priceRange = point.high - point.low;\r\n    const midPrice = (point.high + point.low) / 2;\r\n    if (priceRange / midPrice > 0.5) {\r\n      return false;\r\n    }\r\n    \r\n    // Check OHLC relationships are valid\r\n    if (point.high < Math.max(point.open, point.close) || \r\n        point.low > Math.min(point.open, point.close)) {\r\n      return false;\r\n    }\r\n    \r\n    // Check for reasonable volume (not zero or extremely high)\r\n    if (point.volume <= 0 || point.volume > 1e12) {\r\n      return false;\r\n    }\r\n    \r\n    // Check prices are positive and reasonable\r\n    if (point.open <= 0 || point.high <= 0 || point.low <= 0 || point.close <= 0) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calculate overall data quality score\r\n   */\r\n  private calculateDataQualityScore(data: HistoricalMarketData[]): number {\r\n    if (data.length === 0) return 0;\r\n    \r\n    let qualityScore = 100;\r\n    \r\n    // Check for data completeness\r\n    const validPoints = data.filter(d => this.isValidDataPoint(d) && this.isRealMarketData(d)).length;\r\n    const completenessScore = (validPoints / data.length) * 100;\r\n    qualityScore = Math.min(qualityScore, completenessScore);\r\n    \r\n    // Check for data consistency (no extreme outliers)\r\n    const prices = data.map(d => d.close);\r\n    const outliers = this.detectPriceOutliers(prices);\r\n    const outlierPenalty = (outliers.length / data.length) * 50;\r\n    qualityScore -= outlierPenalty;\r\n    \r\n    // Check for temporal consistency\r\n    const temporalGaps = this.detectDataGaps(data, 60); // 1 hour max gap\r\n    const gapPenalty = Math.min(temporalGaps.length * 5, 30);\r\n    qualityScore -= gapPenalty;\r\n    \r\n    return Math.max(0, Math.round(qualityScore));\r\n  }\r\n\r\n  /**\r\n   * Detect price outliers that might indicate bad data\r\n   */\r\n  private detectPriceOutliers(prices: number[]): number[] {\r\n    if (prices.length < 10) return [];\r\n    \r\n    const outliers: number[] = [];\r\n    const sortedPrices = [...prices].sort((a, b) => a - b);\r\n    const q1 = sortedPrices[Math.floor(sortedPrices.length * 0.25)];\r\n    const q3 = sortedPrices[Math.floor(sortedPrices.length * 0.75)];\r\n    const iqr = q3 - q1;\r\n    const lowerBound = q1 - 1.5 * iqr;\r\n    const upperBound = q3 + 1.5 * iqr;\r\n    \r\n    for (let i = 0; i < prices.length; i++) {\r\n      if (prices[i] < lowerBound || prices[i] > upperBound) {\r\n        outliers.push(i);\r\n      }\r\n    }\r\n    \r\n    return outliers;\r\n  }\r\n\r\n  /**\r\n   * Validate fetch configuration\r\n   */\r\n  private validateFetchConfig(config: DataFetchConfig): void {\r\n    if (!config.symbol || config.symbol.trim() === '') {\r\n      throw new Error('Symbol is required');\r\n    }\r\n    \r\n    if (config.startTime >= config.endTime) {\r\n      throw new Error('Start time must be before end time');\r\n    }\r\n    \r\n    if (config.endTime > new Date()) {\r\n      throw new Error('End time cannot be in the future');\r\n    }\r\n    \r\n    const maxHistoryDays = 365; // 1 year maximum\r\n    const durationDays = (config.endTime.getTime() - config.startTime.getTime()) / (1000 * 60 * 60 * 24);\r\n    if (durationDays > maxHistoryDays) {\r\n      throw new Error(`Date range too large: ${durationDays} days > ${maxHistoryDays} days`);\r\n    }\r\n    \r\n    if (config.batchSize <= 0 || config.batchSize > 1000) {\r\n      throw new Error('Batch size must be between 1 and 1000');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate batches for data fetching\r\n   */\r\n  private calculateBatches(config: DataFetchConfig): Array<{ start: Date; end: Date }> {\r\n    const batches: Array<{ start: Date; end: Date }> = [];\r\n    const intervalMs = this.getIntervalMilliseconds(config.interval);\r\n    const batchDuration = config.batchSize * intervalMs;\r\n    \r\n    let currentStart = new Date(config.startTime);\r\n    \r\n    while (currentStart < config.endTime) {\r\n      const currentEnd = new Date(Math.min(\r\n        currentStart.getTime() + batchDuration,\r\n        config.endTime.getTime()\r\n      ));\r\n      \r\n      batches.push({\r\n        start: new Date(currentStart),\r\n        end: new Date(currentEnd),\r\n      });\r\n      \r\n      currentStart = new Date(currentEnd.getTime() + intervalMs);\r\n    }\r\n    \r\n    return batches;\r\n  }\r\n\r\n  /**\r\n   * Fetch a single batch of data from Gate.io API\r\n   */\r\n  private async fetchBatch(\r\n    symbol: string, \r\n    interval: TimeInterval, \r\n    startTime: Date, \r\n    endTime: Date\r\n  ): Promise<HistoricalMarketData[]> {\r\n    this.fetchStatistics.totalRequests++;\r\n    \r\n    try {\r\n      // Convert to Gate.io API format\r\n      const gateSymbol = symbol.replace('_', '_'); // Ensure correct format\r\n      const from = Math.floor(startTime.getTime() / 1000);\r\n      const to = Math.floor(endTime.getTime() / 1000);\r\n      \r\n      // Make API request for candlestick data\r\n      const response = await this.gateIOClient.makeRequest<Candlestick[]>({\r\n        method: 'GET',\r\n        url: `/spot/candlesticks`,\r\n        params: {\r\n          currency_pair: gateSymbol,\r\n          interval: interval,\r\n          from: from,\r\n          to: to,\r\n        },\r\n        requestType: 'PUBLIC' as any,\r\n        skipAuth: true,\r\n      });\r\n      \r\n      // Convert Gate.io candlestick data to our format\r\n      const historicalData: HistoricalMarketData[] = response.map((candle: Candlestick) => {\r\n        const marketData: HistoricalMarketData = {\r\n          symbol: symbol,\r\n          timestamp: new Date(candle.timestamp * 1000),\r\n          open: parseFloat(candle.open),\r\n          high: parseFloat(candle.high),\r\n          low: parseFloat(candle.low),\r\n          close: parseFloat(candle.close),\r\n          volume: parseFloat(candle.volume),\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: this.calculateDataHash(candle),\r\n          fetchedAt: new Date(),\r\n        };\r\n        \r\n        return marketData;\r\n      });\r\n      \r\n      logger.debug(`📥 Fetched ${historicalData.length} data points for ${symbol} (${interval})`);\r\n      \r\n      return historicalData;\r\n      \r\n    } catch (error) {\r\n      logger.error(`❌ Failed to fetch batch for ${symbol}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove duplicate data points\r\n   */\r\n  private removeDuplicates(data: HistoricalMarketData[]): HistoricalMarketData[] {\r\n    const seen = new Set<string>();\r\n    const unique: HistoricalMarketData[] = [];\r\n    \r\n    for (const point of data) {\r\n      const key = `${point.symbol}_${point.timestamp.getTime()}`;\r\n      if (!seen.has(key)) {\r\n        seen.add(key);\r\n        unique.push(point);\r\n      }\r\n    }\r\n    \r\n    return unique;\r\n  }\r\n\r\n  /**\r\n   * Validate data integrity with cryptographic verification\r\n   */\r\n  private async validateDataIntegrity(data: HistoricalMarketData[]): Promise<HistoricalMarketData[]> {\r\n    logger.info('🔐 Validating data integrity...');\r\n    \r\n    const validatedData: HistoricalMarketData[] = [];\r\n    \r\n    for (const point of data) {\r\n      // Recalculate hash to verify integrity\r\n      const expectedHash = this.calculateDataHash({\r\n        timestamp: Math.floor(point.timestamp.getTime() / 1000),\r\n        open: point.open.toString(),\r\n        high: point.high.toString(),\r\n        low: point.low.toString(),\r\n        close: point.close.toString(),\r\n        volume: point.volume.toString(),\r\n        quote_volume: '0', // Not used in our calculation\r\n      });\r\n      \r\n      if (point.integrity === expectedHash) {\r\n        validatedData.push({\r\n          ...point,\r\n          validated: true,\r\n        });\r\n      } else {\r\n        logger.warn(`⚠️ Data integrity check failed for ${point.symbol} at ${point.timestamp.toISOString()}`);\r\n        validatedData.push({\r\n          ...point,\r\n          validated: false,\r\n        });\r\n      }\r\n    }\r\n    \r\n    logger.info(`✅ Data integrity validation completed: ${validatedData.filter(d => d.validated).length}/${validatedData.length} valid`);\r\n    \r\n    return validatedData;\r\n  }\r\n\r\n  /**\r\n   * Calculate cryptographic hash for data integrity\r\n   */\r\n  private calculateDataHash(candle: any): string {\r\n    const dataString = `${candle.timestamp}_${candle.open}_${candle.high}_${candle.low}_${candle.close}_${candle.volume}`;\r\n    return crypto.createHash('sha256').update(dataString).digest('hex');\r\n  }\r\n\r\n  /**\r\n   * Check if a data point is valid\r\n   */\r\n  private isValidDataPoint(point: HistoricalMarketData): boolean {\r\n    // Check for valid OHLCV data\r\n    if (point.open <= 0 || point.high <= 0 || point.low <= 0 || point.close <= 0) {\r\n      return false;\r\n    }\r\n    \r\n    // Check OHLC relationships\r\n    if (point.high < Math.max(point.open, point.close) || \r\n        point.low > Math.min(point.open, point.close)) {\r\n      return false;\r\n    }\r\n    \r\n    // Check for reasonable volume\r\n    if (point.volume < 0) {\r\n      return false;\r\n    }\r\n    \r\n    // Check timestamp validity\r\n    if (point.timestamp > new Date() || point.timestamp < new Date('2009-01-01')) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Detect gaps in historical data\r\n   */\r\n  private detectDataGaps(data: HistoricalMarketData[], maxGapMinutes: number): DataGap[] {\r\n    const gaps: DataGap[] = [];\r\n    \r\n    for (let i = 1; i < data.length; i++) {\r\n      const prevTime = data[i - 1].timestamp.getTime();\r\n      const currTime = data[i].timestamp.getTime();\r\n      const gapMinutes = (currTime - prevTime) / (1000 * 60);\r\n      \r\n      if (gapMinutes > maxGapMinutes) {\r\n        const severity = gapMinutes > maxGapMinutes * 3 ? 'HIGH' : \r\n                        gapMinutes > maxGapMinutes * 2 ? 'MEDIUM' : 'LOW';\r\n        \r\n        gaps.push({\r\n          startTime: data[i - 1].timestamp,\r\n          endTime: data[i].timestamp,\r\n          durationMinutes: gapMinutes,\r\n          severity,\r\n          impact: `Missing ${Math.floor(gapMinutes / maxGapMinutes)} expected data points`,\r\n        });\r\n      }\r\n    }\r\n    \r\n    return gaps;\r\n  }\r\n\r\n  /**\r\n   * Calculate data integrity score\r\n   */\r\n  private calculateIntegrityScore(validation: DataValidationResult): number {\r\n    if (validation.totalPoints === 0) return 0;\r\n    \r\n    const validRatio = validation.validPoints / validation.totalPoints;\r\n    const gapPenalty = Math.min(validation.gaps.length * 0.1, 0.5);\r\n    const errorPenalty = Math.min(validation.errors.length * 0.2, 0.8);\r\n    \r\n    return Math.max(0, (validRatio - gapPenalty - errorPenalty) * 100);\r\n  }\r\n\r\n  /**\r\n   * Determine optimal interval based on backtest duration\r\n   */\r\n  private determineOptimalInterval(durationDays: number): TimeInterval {\r\n    if (durationDays <= 7) return '1m';\r\n    if (durationDays <= 30) return '5m';\r\n    if (durationDays <= 90) return '15m';\r\n    if (durationDays <= 180) return '1h';\r\n    return '4h';\r\n  }\r\n\r\n  /**\r\n   * Get interval duration in milliseconds\r\n   */\r\n  private getIntervalMilliseconds(interval: TimeInterval): number {\r\n    const intervals: Record<TimeInterval, number> = {\r\n      '1m': 60 * 1000,\r\n      '5m': 5 * 60 * 1000,\r\n      '15m': 15 * 60 * 1000,\r\n      '30m': 30 * 60 * 1000,\r\n      '1h': 60 * 60 * 1000,\r\n      '4h': 4 * 60 * 60 * 1000,\r\n      '8h': 8 * 60 * 60 * 1000,\r\n      '1d': 24 * 60 * 60 * 1000,\r\n    };\r\n    \r\n    return intervals[interval];\r\n  }\r\n\r\n  /**\r\n   * Reset fetch statistics\r\n   */\r\n  private resetStatistics(): void {\r\n    this.fetchStatistics = {\r\n      totalRequests: 0,\r\n      successfulRequests: 0,\r\n      failedRequests: 0,\r\n      totalDataPoints: 0,\r\n      validDataPoints: 0,\r\n      duplicatesRemoved: 0,\r\n      gapsDetected: 0,\r\n      fetchDuration: 0,\r\n      averageRequestTime: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Delay execution for rate limiting\r\n   */\r\n  private delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  /**\r\n   * Get fetch statistics\r\n   */\r\n  public getFetchStatistics(): FetchStatistics {\r\n    return { ...this.fetchStatistics };\r\n  }\r\n}\r\n"],"version":3}