{"file":"C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\trading\\backtesting\\__tests__\\real-data-validation.test.ts","mappings":"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","names":[],"sources":["C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\trading\\backtesting\\__tests__\\real-data-validation.test.ts"],"sourcesContent":["/**\r\n * =============================================================================\r\n * REAL DATA VALIDATION TESTS\r\n * =============================================================================\r\n * \r\n * Comprehensive tests to ensure the backtesting system only uses real\r\n * historical market data and never mock data. These tests validate the\r\n * data integrity and authenticity requirements.\r\n * \r\n * @author AI Crypto Trading System\r\n * @version 1.0.0\r\n * @license PROPRIETARY\r\n * =============================================================================\r\n */\r\n\r\nimport { describe, test, expect, beforeEach } from '@jest/globals';\r\nimport { HistoricalDataFetcher } from '../historical-data-fetcher';\r\nimport { BacktestingEngine } from '../backtesting-engine';\r\nimport { GateIOClient } from '../../api/gate-io-client';\r\nimport { \r\n  HistoricalMarketData, \r\n  BacktestConfig,\r\n  DataValidationResult \r\n} from '../types';\r\n\r\n// Mock GateIOClient for testing\r\nconst mockGateIOClient = {\r\n  makeRequest: jest.fn(),\r\n} as unknown as GateIOClient;\r\n\r\ndescribe('Real Data Validation', () => {\r\n  let dataFetcher: HistoricalDataFetcher;\r\n  let backtestingEngine: BacktestingEngine;\r\n\r\n  beforeEach(() => {\r\n    dataFetcher = new HistoricalDataFetcher(mockGateIOClient);\r\n    backtestingEngine = new BacktestingEngine(mockGateIOClient);\r\n  });\r\n\r\n  describe('Data Source Validation', () => {\r\n    test('should reject mock data', async () => {\r\n      const mockData: HistoricalMarketData[] = [\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date(),\r\n          open: 42000,\r\n          high: 42500,\r\n          low: 41800,\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: false, // Mock data flag\r\n          source: 'MOCK', // Not from Gate.io\r\n          integrity: 'mock_hash',\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 1,\r\n          maxGapMinutes: 60,\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(mockData, config);\r\n      \r\n      expect(validation.isValid).toBe(false);\r\n      expect(validation.errors).toContain(expect.stringContaining('Mock data detected'));\r\n    });\r\n\r\n    test('should accept real Gate.io data', async () => {\r\n      const realData: HistoricalMarketData[] = [\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date(),\r\n          open: 42000,\r\n          high: 42500,\r\n          low: 41800,\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: true, // Real data flag\r\n          source: 'GATE_IO', // From Gate.io\r\n          integrity: 'real_hash_12345',\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 1,\r\n          maxGapMinutes: 60,\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(realData, config);\r\n      \r\n      expect(validation.isValid).toBe(true);\r\n      expect(validation.errors).toHaveLength(0);\r\n    });\r\n\r\n    test('should validate data integrity hashes', async () => {\r\n      const dataWithBadHash: HistoricalMarketData[] = [\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date(),\r\n          open: 42000,\r\n          high: 42500,\r\n          low: 41800,\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: 'invalid_hash', // Bad integrity hash\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 1,\r\n          maxGapMinutes: 60,\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(dataWithBadHash, config);\r\n      \r\n      // Should still be valid but with warnings about integrity\r\n      expect(validation.warnings.length).toBeGreaterThan(0);\r\n    });\r\n  });\r\n\r\n  describe('Data Quality Validation', () => {\r\n    test('should detect unrealistic price movements', async () => {\r\n      const unrealisticData: HistoricalMarketData[] = [\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date(),\r\n          open: 42000,\r\n          high: 84000, // 100% price jump - unrealistic\r\n          low: 21000,  // 50% price drop - unrealistic\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: 'test_hash',\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 1,\r\n          maxGapMinutes: 60,\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(unrealisticData, config);\r\n      \r\n      expect(validation.invalidPoints).toBeGreaterThan(0);\r\n      expect(validation.warnings.length).toBeGreaterThan(0);\r\n    });\r\n\r\n    test('should validate OHLC relationships', async () => {\r\n      const invalidOHLCData: HistoricalMarketData[] = [\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date(),\r\n          open: 42000,\r\n          high: 41000, // High less than open - invalid\r\n          low: 43000,  // Low greater than open - invalid\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: 'test_hash',\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 1,\r\n          maxGapMinutes: 60,\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(invalidOHLCData, config);\r\n      \r\n      expect(validation.invalidPoints).toBeGreaterThan(0);\r\n    });\r\n\r\n    test('should detect data gaps', async () => {\r\n      const dataWithGaps: HistoricalMarketData[] = [\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date('2024-01-01T00:00:00Z'),\r\n          open: 42000,\r\n          high: 42500,\r\n          low: 41800,\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: 'test_hash_1',\r\n          fetchedAt: new Date(),\r\n        },\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date('2024-01-01T05:00:00Z'), // 5 hour gap\r\n          open: 42200,\r\n          high: 42800,\r\n          low: 42000,\r\n          close: 42600,\r\n          volume: 1200,\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: 'test_hash_2',\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 2,\r\n          maxGapMinutes: 60, // 1 hour max gap\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(dataWithGaps, config);\r\n      \r\n      expect(validation.gaps.length).toBeGreaterThan(0);\r\n      expect(validation.gaps[0].durationMinutes).toBeGreaterThan(60);\r\n    });\r\n  });\r\n\r\n  describe('Security Validation', () => {\r\n    test('should enforce minimum data points requirement', async () => {\r\n      const insufficientData: HistoricalMarketData[] = [\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date(),\r\n          open: 42000,\r\n          high: 42500,\r\n          low: 41800,\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: 'test_hash',\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 100, // Require 100 points\r\n          maxGapMinutes: 60,\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(insufficientData, config);\r\n      \r\n      expect(validation.isValid).toBe(false);\r\n      expect(validation.errors).toContainEqual(expect.stringContaining('Insufficient data points'));\r\n    });\r\n\r\n    test('should calculate data integrity score', async () => {\r\n      const mixedQualityData: HistoricalMarketData[] = [\r\n        // Good data point\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date('2024-01-01T00:00:00Z'),\r\n          open: 42000,\r\n          high: 42500,\r\n          low: 41800,\r\n          close: 42200,\r\n          volume: 1000,\r\n          validated: true,\r\n          source: 'GATE_IO',\r\n          integrity: 'good_hash_1',\r\n          fetchedAt: new Date(),\r\n        },\r\n        // Bad data point\r\n        {\r\n          symbol: 'BTC_USDT',\r\n          timestamp: new Date('2024-01-01T01:00:00Z'),\r\n          open: 0, // Invalid price\r\n          high: 0,\r\n          low: 0,\r\n          close: 0,\r\n          volume: -100, // Invalid volume\r\n          validated: false,\r\n          source: 'GATE_IO',\r\n          integrity: 'bad_hash',\r\n          fetchedAt: new Date(),\r\n        },\r\n      ];\r\n\r\n      const config: BacktestConfig = {\r\n        symbol: 'BTC_USDT',\r\n        startDate: new Date('2024-01-01'),\r\n        endDate: new Date('2024-01-02'),\r\n        initialBalance: 10000,\r\n        strategies: [],\r\n        riskManagement: {\r\n          maxRiskPerTrade: 0.02,\r\n          stopLossPercentage: 0.01,\r\n          minRiskRewardRatio: 1.5,\r\n          maxDrawdown: 0.15,\r\n        },\r\n        fees: { maker: 0.002, taker: 0.002 },\r\n        slippage: 0.001,\r\n        dataValidation: {\r\n          requireRealData: true,\r\n          minDataPoints: 2,\r\n          maxGapMinutes: 120,\r\n        },\r\n      };\r\n\r\n      const validation = await dataFetcher.validateForBacktesting(mixedQualityData, config);\r\n      \r\n      expect(validation.integrityScore).toBeLessThan(100);\r\n      expect(validation.validPoints).toBe(1);\r\n      expect(validation.invalidPoints).toBe(1);\r\n    });\r\n  });\r\n});"],"version":3}