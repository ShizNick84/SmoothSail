{"file":"C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\infrastructure\\tunnel-health-monitor.ts","mappings":"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","names":[],"sources":["C:\\Users\\Nick\\Desktop\\SmoothSail\\src\\infrastructure\\tunnel-health-monitor.ts"],"sourcesContent":["import { EventEmitter } from 'events';\r\nimport { Logger } from '../core/logging/logger';\r\nimport { TunnelConnection, TunnelState, SSHTunnelManager } from './ssh-tunnel-manager';\r\nimport { TunnelStateTracker } from './tunnel-state-tracker';\r\n\r\n/**\r\n * Tunnel health metrics\r\n */\r\nexport interface TunnelHealthMetrics {\r\n  connectionId: string;\r\n  isHealthy: boolean;\r\n  latency: number; // ms\r\n  throughput: number; // bytes/sec\r\n  packetLoss: number; // percentage\r\n  uptime: number; // ms\r\n  lastHealthCheck: Date;\r\n  consecutiveFailures: number;\r\n  healthScore: number; // 0-100\r\n  issues: HealthIssue[];\r\n}\r\n\r\n/**\r\n * Health issue types\r\n */\r\nexport interface HealthIssue {\r\n  type: 'HIGH_LATENCY' | 'PACKET_LOSS' | 'LOW_THROUGHPUT' | 'CONNECTION_UNSTABLE' | 'AUTHENTICATION_FAILURE';\r\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\r\n  message: string;\r\n  timestamp: Date;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Health monitoring configuration\r\n */\r\nexport interface HealthMonitorConfig {\r\n  /** Health check interval in milliseconds */\r\n  checkInterval: number;\r\n  /** Maximum acceptable latency in milliseconds */\r\n  maxLatency: number;\r\n  /** Maximum acceptable packet loss percentage */\r\n  maxPacketLoss: number;\r\n  /** Minimum acceptable throughput in bytes/sec */\r\n  minThroughput: number;\r\n  /** Number of consecutive failures before marking unhealthy */\r\n  failureThreshold: number;\r\n  /** Health check timeout in milliseconds */\r\n  healthCheckTimeout: number;\r\n  /** Enable detailed performance monitoring */\r\n  enablePerformanceMonitoring: boolean;\r\n}\r\n\r\n/**\r\n * Performance metrics for tunnel monitoring\r\n */\r\nexport interface PerformanceMetrics {\r\n  timestamp: Date;\r\n  latency: number;\r\n  throughput: number;\r\n  packetLoss: number;\r\n  cpuUsage: number;\r\n  memoryUsage: number;\r\n  networkUtilization: number;\r\n}\r\n\r\n/**\r\n * Tunnel Health Monitor\r\n * Monitors SSH tunnel health with real-time metrics collection and alerting\r\n */\r\nexport class TunnelHealthMonitor extends EventEmitter {\r\n  private logger: Logger;\r\n  private tunnelManager: SSHTunnelManager;\r\n  private stateTracker: TunnelStateTracker;\r\n  private config: HealthMonitorConfig;\r\n  private healthMetrics: Map<string, TunnelHealthMetrics>;\r\n  private performanceHistory: Map<string, PerformanceMetrics[]>;\r\n  private monitoringIntervals: Map<string, NodeJS.Timeout>;\r\n  private isMonitoring: boolean;\r\n\r\n  constructor(\r\n    logger: Logger,\r\n    tunnelManager: SSHTunnelManager,\r\n    stateTracker: TunnelStateTracker,\r\n    config?: Partial<HealthMonitorConfig>\r\n  ) {\r\n    super();\r\n    this.logger = logger;\r\n    this.tunnelManager = tunnelManager;\r\n    this.stateTracker = stateTracker;\r\n    this.healthMetrics = new Map();\r\n    this.performanceHistory = new Map();\r\n    this.monitoringIntervals = new Map();\r\n    this.isMonitoring = false;\r\n\r\n    // Default configuration\r\n    this.config = {\r\n      checkInterval: 30000, // 30 seconds\r\n      maxLatency: 1000, // 1 second\r\n      maxPacketLoss: 5, // 5%\r\n      minThroughput: 1024, // 1 KB/s\r\n      failureThreshold: 3,\r\n      healthCheckTimeout: 10000, // 10 seconds\r\n      enablePerformanceMonitoring: true,\r\n      ...config\r\n    };\r\n\r\n    this.logger.info('Tunnel Health Monitor initialized', this.config);\r\n  }\r\n\r\n  /**\r\n   * Start monitoring all tunnel connections\r\n   */\r\n  startMonitoring(): void {\r\n    if (this.isMonitoring) {\r\n      this.logger.warn('Health monitoring is already running');\r\n      return;\r\n    }\r\n\r\n    this.isMonitoring = true;\r\n    this.logger.info('Starting tunnel health monitoring');\r\n\r\n    // Monitor existing connections\r\n    const connections = this.tunnelManager.getAllConnections();\r\n    for (const connection of connections) {\r\n      this.startMonitoringConnection(connection.id);\r\n    }\r\n\r\n    // Listen for new connections\r\n    this.tunnelManager.on('tunnelConnected', (connection) => {\r\n      this.startMonitoringConnection(connection.id);\r\n    });\r\n\r\n    // Listen for disconnections\r\n    this.tunnelManager.on('tunnelDisconnected', (connection) => {\r\n      this.stopMonitoringConnection(connection.id);\r\n    });\r\n\r\n    this.emit('monitoringStarted');\r\n  }\r\n\r\n  /**\r\n   * Stop monitoring all tunnel connections\r\n   */\r\n  stopMonitoring(): void {\r\n    if (!this.isMonitoring) {\r\n      this.logger.warn('Health monitoring is not running');\r\n      return;\r\n    }\r\n\r\n    this.isMonitoring = false;\r\n    this.logger.info('Stopping tunnel health monitoring');\r\n\r\n    // Clear all monitoring intervals\r\n    for (const [connectionId, interval] of this.monitoringIntervals.entries()) {\r\n      clearInterval(interval);\r\n      this.monitoringIntervals.delete(connectionId);\r\n    }\r\n\r\n    this.emit('monitoringStopped');\r\n  }\r\n\r\n  /**\r\n   * Start monitoring a specific connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   */\r\n  startMonitoringConnection(connectionId: string): void {\r\n    if (this.monitoringIntervals.has(connectionId)) {\r\n      this.logger.debug(`Already monitoring connection: ${connectionId}`);\r\n      return;\r\n    }\r\n\r\n    this.logger.info(`Starting health monitoring for connection: ${connectionId}`);\r\n\r\n    // Initialize health metrics\r\n    this.initializeHealthMetrics(connectionId);\r\n\r\n    // Start periodic health checks\r\n    const interval = setInterval(async () => {\r\n      try {\r\n        await this.performHealthCheck(connectionId);\r\n      } catch (error) {\r\n        this.logger.error(`Health check failed for connection ${connectionId}`, error);\r\n      }\r\n    }, this.config.checkInterval);\r\n\r\n    this.monitoringIntervals.set(connectionId, interval);\r\n\r\n    // Perform initial health check\r\n    setTimeout(() => this.performHealthCheck(connectionId), 1000);\r\n  }\r\n\r\n  /**\r\n   * Stop monitoring a specific connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   */\r\n  stopMonitoringConnection(connectionId: string): void {\r\n    const interval = this.monitoringIntervals.get(connectionId);\r\n    if (interval) {\r\n      clearInterval(interval);\r\n      this.monitoringIntervals.delete(connectionId);\r\n      this.logger.info(`Stopped health monitoring for connection: ${connectionId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get health metrics for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @returns Health metrics or undefined\r\n   */\r\n  getHealthMetrics(connectionId: string): TunnelHealthMetrics | undefined {\r\n    return this.healthMetrics.get(connectionId);\r\n  }\r\n\r\n  /**\r\n   * Get health metrics for all connections\r\n   * \r\n   * @returns Map of all health metrics\r\n   */\r\n  getAllHealthMetrics(): Map<string, TunnelHealthMetrics> {\r\n    return new Map(this.healthMetrics);\r\n  }\r\n\r\n  /**\r\n   * Get performance history for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @param limit - Maximum number of history entries\r\n   * @returns Array of performance metrics\r\n   */\r\n  getPerformanceHistory(connectionId: string, limit?: number): PerformanceMetrics[] {\r\n    const history = this.performanceHistory.get(connectionId) || [];\r\n    return limit ? history.slice(-limit) : [...history];\r\n  }\r\n\r\n  /**\r\n   * Get overall system health status\r\n   * \r\n   * @returns System health summary\r\n   */\r\n  getSystemHealthStatus(): {\r\n    totalConnections: number;\r\n    healthyConnections: number;\r\n    unhealthyConnections: number;\r\n    averageHealthScore: number;\r\n    criticalIssues: number;\r\n    systemHealthScore: number;\r\n  } {\r\n    const allMetrics = Array.from(this.healthMetrics.values());\r\n    const totalConnections = allMetrics.length;\r\n    const healthyConnections = allMetrics.filter(m => m.isHealthy).length;\r\n    const unhealthyConnections = totalConnections - healthyConnections;\r\n    \r\n    const averageHealthScore = totalConnections > 0\r\n      ? allMetrics.reduce((sum, m) => sum + m.healthScore, 0) / totalConnections\r\n      : 0;\r\n\r\n    const criticalIssues = allMetrics.reduce(\r\n      (sum, m) => sum + m.issues.filter(i => i.severity === 'CRITICAL').length,\r\n      0\r\n    );\r\n\r\n    const systemHealthScore = Math.max(0, averageHealthScore - (criticalIssues * 10));\r\n\r\n    return {\r\n      totalConnections,\r\n      healthyConnections,\r\n      unhealthyConnections,\r\n      averageHealthScore,\r\n      criticalIssues,\r\n      systemHealthScore\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Force health check for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @returns Health check results\r\n   */\r\n  async forceHealthCheck(connectionId: string): Promise<TunnelHealthMetrics | null> {\r\n    try {\r\n      await this.performHealthCheck(connectionId);\r\n      return this.getHealthMetrics(connectionId) || null;\r\n    } catch (error) {\r\n      this.logger.error(`Forced health check failed for connection ${connectionId}`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize health metrics for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   */\r\n  private initializeHealthMetrics(connectionId: string): void {\r\n    const metrics: TunnelHealthMetrics = {\r\n      connectionId,\r\n      isHealthy: false,\r\n      latency: 0,\r\n      throughput: 0,\r\n      packetLoss: 0,\r\n      uptime: 0,\r\n      lastHealthCheck: new Date(),\r\n      consecutiveFailures: 0,\r\n      healthScore: 0,\r\n      issues: []\r\n    };\r\n\r\n    this.healthMetrics.set(connectionId, metrics);\r\n    this.performanceHistory.set(connectionId, []);\r\n  }\r\n\r\n  /**\r\n   * Perform comprehensive health check for a connection\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   */\r\n  private async performHealthCheck(connectionId: string): Promise<void> {\r\n    const connection = this.tunnelManager.getConnection(connectionId);\r\n    if (!connection) {\r\n      this.logger.warn(`Connection not found for health check: ${connectionId}`);\r\n      return;\r\n    }\r\n\r\n    const metrics = this.healthMetrics.get(connectionId);\r\n    if (!metrics) {\r\n      this.logger.warn(`Health metrics not found for connection: ${connectionId}`);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Update last health check timestamp\r\n      metrics.lastHealthCheck = new Date();\r\n\r\n      // Check connection state\r\n      if (connection.state !== TunnelState.CONNECTED) {\r\n        this.markConnectionUnhealthy(metrics, 'Connection not in CONNECTED state');\r\n        return;\r\n      }\r\n\r\n      // Perform latency test\r\n      const latency = await this.measureLatency(connection);\r\n      metrics.latency = latency;\r\n\r\n      // Perform throughput test\r\n      const throughput = await this.measureThroughput(connection);\r\n      metrics.throughput = throughput;\r\n\r\n      // Measure packet loss\r\n      const packetLoss = await this.measurePacketLoss(connection);\r\n      metrics.packetLoss = packetLoss;\r\n\r\n      // Calculate uptime\r\n      if (connection.connectedAt) {\r\n        metrics.uptime = Date.now() - connection.connectedAt.getTime();\r\n      }\r\n\r\n      // Analyze health issues\r\n      const issues = this.analyzeHealthIssues(metrics);\r\n      metrics.issues = issues;\r\n\r\n      // Calculate health score\r\n      metrics.healthScore = this.calculateHealthScore(metrics);\r\n\r\n      // Determine overall health status\r\n      const wasHealthy = metrics.isHealthy;\r\n      metrics.isHealthy = this.determineHealthStatus(metrics);\r\n\r\n      // Handle health status changes\r\n      if (metrics.isHealthy) {\r\n        metrics.consecutiveFailures = 0;\r\n        if (!wasHealthy) {\r\n          this.logger.info(`Connection health restored: ${connectionId}`);\r\n          this.emit('connectionHealthy', connection, metrics);\r\n        }\r\n      } else {\r\n        metrics.consecutiveFailures++;\r\n        if (wasHealthy) {\r\n          this.logger.warn(`Connection health degraded: ${connectionId}`, {\r\n            issues: issues.map(i => i.message)\r\n          });\r\n          this.emit('connectionUnhealthy', connection, metrics);\r\n        }\r\n      }\r\n\r\n      // Store performance metrics\r\n      if (this.config.enablePerformanceMonitoring) {\r\n        this.storePerformanceMetrics(connectionId, {\r\n          timestamp: new Date(),\r\n          latency,\r\n          throughput,\r\n          packetLoss,\r\n          cpuUsage: await this.getCPUUsage(),\r\n          memoryUsage: await this.getMemoryUsage(),\r\n          networkUtilization: await this.getNetworkUtilization()\r\n        });\r\n      }\r\n\r\n      // Emit health check completed event\r\n      this.emit('healthCheckCompleted', connection, metrics);\r\n\r\n    } catch (error) {\r\n      this.logger.error(`Health check failed for connection ${connectionId}`, error);\r\n      this.markConnectionUnhealthy(metrics, `Health check error: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Measure connection latency using ping-like test\r\n   * \r\n   * @param connection - Tunnel connection\r\n   * @returns Latency in milliseconds\r\n   */\r\n  private async measureLatency(connection: TunnelConnection): Promise<number> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      // Simple TCP connection test to local tunnel port\r\n      const net = await import('net');\r\n      \r\n      return new Promise<number>((resolve, reject) => {\r\n        const socket = new net.Socket();\r\n        const timeout = setTimeout(() => {\r\n          socket.destroy();\r\n          reject(new Error('Latency measurement timeout'));\r\n        }, this.config.healthCheckTimeout);\r\n\r\n        socket.connect(connection.config.localPort, 'localhost', () => {\r\n          const latency = Date.now() - startTime;\r\n          clearTimeout(timeout);\r\n          socket.destroy();\r\n          resolve(latency);\r\n        });\r\n\r\n        socket.on('error', (error) => {\r\n          clearTimeout(timeout);\r\n          reject(error);\r\n        });\r\n      });\r\n\r\n    } catch (error) {\r\n      this.logger.debug(`Latency measurement failed for ${connection.id}`, error);\r\n      return 9999; // High latency indicates problem\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Measure connection throughput\r\n   * \r\n   * @param connection - Tunnel connection\r\n   * @returns Throughput in bytes per second\r\n   */\r\n  private async measureThroughput(connection: TunnelConnection): Promise<number> {\r\n    try {\r\n      // Simple throughput test by sending small data packet\r\n      const net = await import('net');\r\n      const testData = Buffer.alloc(1024, 'A'); // 1KB test data\r\n      const startTime = Date.now();\r\n\r\n      return new Promise<number>((resolve, reject) => {\r\n        const socket = new net.Socket();\r\n        const timeout = setTimeout(() => {\r\n          socket.destroy();\r\n          reject(new Error('Throughput measurement timeout'));\r\n        }, this.config.healthCheckTimeout);\r\n\r\n        let bytesReceived = 0;\r\n\r\n        socket.connect(connection.config.localPort, 'localhost', () => {\r\n          socket.write(testData);\r\n        });\r\n\r\n        socket.on('data', (data) => {\r\n          bytesReceived += data.length;\r\n          const duration = (Date.now() - startTime) / 1000; // seconds\r\n          const throughput = bytesReceived / duration;\r\n          \r\n          clearTimeout(timeout);\r\n          socket.destroy();\r\n          resolve(throughput);\r\n        });\r\n\r\n        socket.on('error', (error) => {\r\n          clearTimeout(timeout);\r\n          reject(error);\r\n        });\r\n      });\r\n\r\n    } catch (error) {\r\n      this.logger.debug(`Throughput measurement failed for ${connection.id}`, error);\r\n      return 0; // No throughput indicates problem\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Measure packet loss percentage\r\n   * \r\n   * @param connection - Tunnel connection\r\n   * @returns Packet loss percentage\r\n   */\r\n  private async measurePacketLoss(connection: TunnelConnection): Promise<number> {\r\n    try {\r\n      // Simple packet loss test by sending multiple small packets\r\n      const net = await import('net');\r\n      const packetCount = 10;\r\n      let packetsReceived = 0;\r\n\r\n      for (let i = 0; i < packetCount; i++) {\r\n        try {\r\n          await new Promise<void>((resolve, reject) => {\r\n            const socket = new net.Socket();\r\n            const timeout = setTimeout(() => {\r\n              socket.destroy();\r\n              resolve(); // Count as lost packet\r\n            }, 1000);\r\n\r\n            socket.connect(connection.config.localPort, 'localhost', () => {\r\n              packetsReceived++;\r\n              clearTimeout(timeout);\r\n              socket.destroy();\r\n              resolve();\r\n            });\r\n\r\n            socket.on('error', () => {\r\n              clearTimeout(timeout);\r\n              resolve(); // Count as lost packet\r\n            });\r\n          });\r\n        } catch {\r\n          // Packet lost\r\n        }\r\n      }\r\n\r\n      const packetLoss = ((packetCount - packetsReceived) / packetCount) * 100;\r\n      return Math.max(0, Math.min(100, packetLoss));\r\n\r\n    } catch (error) {\r\n      this.logger.debug(`Packet loss measurement failed for ${connection.id}`, error);\r\n      return 100; // Assume 100% loss on error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze health issues based on metrics\r\n   * \r\n   * @param metrics - Health metrics\r\n   * @returns Array of health issues\r\n   */\r\n  private analyzeHealthIssues(metrics: TunnelHealthMetrics): HealthIssue[] {\r\n    const issues: HealthIssue[] = [];\r\n    const now = new Date();\r\n\r\n    // Check latency\r\n    if (metrics.latency > this.config.maxLatency) {\r\n      issues.push({\r\n        type: 'HIGH_LATENCY',\r\n        severity: metrics.latency > this.config.maxLatency * 2 ? 'HIGH' : 'MEDIUM',\r\n        message: `High latency detected: ${metrics.latency}ms (max: ${this.config.maxLatency}ms)`,\r\n        timestamp: now\r\n      });\r\n    }\r\n\r\n    // Check packet loss\r\n    if (metrics.packetLoss > this.config.maxPacketLoss) {\r\n      issues.push({\r\n        type: 'PACKET_LOSS',\r\n        severity: metrics.packetLoss > this.config.maxPacketLoss * 2 ? 'HIGH' : 'MEDIUM',\r\n        message: `High packet loss detected: ${metrics.packetLoss}% (max: ${this.config.maxPacketLoss}%)`,\r\n        timestamp: now\r\n      });\r\n    }\r\n\r\n    // Check throughput\r\n    if (metrics.throughput < this.config.minThroughput) {\r\n      issues.push({\r\n        type: 'LOW_THROUGHPUT',\r\n        severity: metrics.throughput < this.config.minThroughput / 2 ? 'HIGH' : 'MEDIUM',\r\n        message: `Low throughput detected: ${metrics.throughput} bytes/s (min: ${this.config.minThroughput} bytes/s)`,\r\n        timestamp: now\r\n      });\r\n    }\r\n\r\n    // Check connection stability\r\n    if (metrics.consecutiveFailures >= this.config.failureThreshold) {\r\n      issues.push({\r\n        type: 'CONNECTION_UNSTABLE',\r\n        severity: 'CRITICAL',\r\n        message: `Connection unstable: ${metrics.consecutiveFailures} consecutive failures`,\r\n        timestamp: now\r\n      });\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Calculate health score based on metrics\r\n   * \r\n   * @param metrics - Health metrics\r\n   * @returns Health score (0-100)\r\n   */\r\n  private calculateHealthScore(metrics: TunnelHealthMetrics): number {\r\n    let score = 100;\r\n\r\n    // Deduct points for high latency\r\n    if (metrics.latency > this.config.maxLatency) {\r\n      const latencyPenalty = Math.min(30, (metrics.latency / this.config.maxLatency - 1) * 20);\r\n      score -= latencyPenalty;\r\n    }\r\n\r\n    // Deduct points for packet loss\r\n    if (metrics.packetLoss > this.config.maxPacketLoss) {\r\n      const packetLossPenalty = Math.min(40, metrics.packetLoss * 2);\r\n      score -= packetLossPenalty;\r\n    }\r\n\r\n    // Deduct points for low throughput\r\n    if (metrics.throughput < this.config.minThroughput) {\r\n      const throughputPenalty = Math.min(20, (1 - metrics.throughput / this.config.minThroughput) * 20);\r\n      score -= throughputPenalty;\r\n    }\r\n\r\n    // Deduct points for consecutive failures\r\n    score -= metrics.consecutiveFailures * 10;\r\n\r\n    // Deduct points for critical issues\r\n    const criticalIssues = metrics.issues.filter(i => i.severity === 'CRITICAL').length;\r\n    score -= criticalIssues * 20;\r\n\r\n    return Math.max(0, Math.min(100, score));\r\n  }\r\n\r\n  /**\r\n   * Determine overall health status\r\n   * \r\n   * @param metrics - Health metrics\r\n   * @returns True if connection is healthy\r\n   */\r\n  private determineHealthStatus(metrics: TunnelHealthMetrics): boolean {\r\n    // Connection is unhealthy if there are critical issues\r\n    const hasCriticalIssues = metrics.issues.some(i => i.severity === 'CRITICAL');\r\n    if (hasCriticalIssues) {\r\n      return false;\r\n    }\r\n\r\n    // Connection is unhealthy if health score is too low\r\n    if (metrics.healthScore < 50) {\r\n      return false;\r\n    }\r\n\r\n    // Connection is unhealthy if too many consecutive failures\r\n    if (metrics.consecutiveFailures >= this.config.failureThreshold) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Mark connection as unhealthy\r\n   * \r\n   * @param metrics - Health metrics\r\n   * @param reason - Reason for marking unhealthy\r\n   */\r\n  private markConnectionUnhealthy(metrics: TunnelHealthMetrics, reason: string): void {\r\n    metrics.isHealthy = false;\r\n    metrics.consecutiveFailures++;\r\n    metrics.healthScore = 0;\r\n    metrics.issues = [{\r\n      type: 'CONNECTION_UNSTABLE',\r\n      severity: 'CRITICAL',\r\n      message: reason,\r\n      timestamp: new Date()\r\n    }];\r\n  }\r\n\r\n  /**\r\n   * Store performance metrics in history\r\n   * \r\n   * @param connectionId - Connection identifier\r\n   * @param performanceMetrics - Performance metrics to store\r\n   */\r\n  private storePerformanceMetrics(connectionId: string, performanceMetrics: PerformanceMetrics): void {\r\n    if (!this.performanceHistory.has(connectionId)) {\r\n      this.performanceHistory.set(connectionId, []);\r\n    }\r\n\r\n    const history = this.performanceHistory.get(connectionId)!;\r\n    history.push(performanceMetrics);\r\n\r\n    // Limit history size to prevent memory issues\r\n    const maxHistorySize = 1000;\r\n    if (history.length > maxHistorySize) {\r\n      history.splice(0, history.length - maxHistorySize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current CPU usage\r\n   * \r\n   * @returns CPU usage percentage\r\n   */\r\n  private async getCPUUsage(): Promise<number> {\r\n    try {\r\n      const os = await import('os');\r\n      const cpus = os.cpus();\r\n      \r\n      let totalIdle = 0;\r\n      let totalTick = 0;\r\n      \r\n      for (const cpu of cpus) {\r\n        for (const type in cpu.times) {\r\n          totalTick += cpu.times[type as keyof typeof cpu.times];\r\n        }\r\n        totalIdle += cpu.times.idle;\r\n      }\r\n      \r\n      return 100 - (totalIdle / totalTick * 100);\r\n    } catch {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current memory usage\r\n   * \r\n   * @returns Memory usage percentage\r\n   */\r\n  private async getMemoryUsage(): Promise<number> {\r\n    try {\r\n      const os = await import('os');\r\n      const totalMem = os.totalmem();\r\n      const freeMem = os.freemem();\r\n      return ((totalMem - freeMem) / totalMem) * 100;\r\n    } catch {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current network utilization\r\n   * \r\n   * @returns Network utilization percentage\r\n   */\r\n  private async getNetworkUtilization(): Promise<number> {\r\n    // Simplified network utilization calculation\r\n    // In a real implementation, this would measure actual network traffic\r\n    return Math.random() * 10; // Placeholder\r\n  }\r\n\r\n  /**\r\n   * Cleanup monitoring resources\r\n   */\r\n  cleanup(): void {\r\n    this.stopMonitoring();\r\n    this.healthMetrics.clear();\r\n    this.performanceHistory.clear();\r\n    this.logger.info('Tunnel health monitor cleanup completed');\r\n  }\r\n}"],"version":3}