4d1221a056d25c03fe8e8e9211186d94
"use strict";
/**
 * =============================================================================
 * AI CRYPTO TRADING AGENT - SYSTEM PERFORMANCE OPTIMIZER
 * =============================================================================
 *
 * This service provides comprehensive performance optimization for Intel NUC
 * systems running the AI crypto trading agent. It implements low-latency
 * trading optimizations, thermal management, and resource allocation.
 *
 * CRITICAL PERFORMANCE NOTICE:
 * This system optimizes hardware performance for trading operations. Poor
 * performance could impact trading decisions and result in financial losses.
 * All optimizations are continuously monitored and adjusted.
 *
 * Hardware Specifications:
 * - Intel NUC with i5 CPU
 * - 12GB RAM
 * - 256GB M.2 SSD
 * - Wireless and Gigabit Ethernet
 *
 * @author AI Crypto Trading System
 * @version 1.0.0
 * @license PROPRIETARY
 * =============================================================================
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceOptimizer = void 0;
const si = __importStar(require("systeminformation"));
const logger_1 = require("@/core/logging/logger");
const audit_service_1 = require("@/security/audit-service");
/**
 * System Performance Optimizer
 * Provides comprehensive performance optimization for trading operations
 */
class PerformanceOptimizer {
    systemMonitor;
    config;
    optimizationInterval = null;
    performanceHistory = [];
    latencyMeasurements = [];
    isOptimizing = false;
    constructor(systemMonitor) {
        this.systemMonitor = systemMonitor;
        this.config = this.loadConfiguration();
        logger_1.logger.info('‚ö° Performance Optimizer initializing...');
    }
    /**
     * Load performance optimization configuration
     *
     * @returns PerformanceConfig Configuration object
     */
    loadConfiguration() {
        return {
            enableCPUOptimization: process.env.ENABLE_CPU_OPTIMIZATION === 'true',
            enableMemoryOptimization: process.env.ENABLE_MEMORY_OPTIMIZATION === 'true',
            enableIOOptimization: process.env.ENABLE_IO_OPTIMIZATION === 'true',
            enableNetworkOptimization: process.env.ENABLE_NETWORK_OPTIMIZATION === 'true',
            enableThermalManagement: process.env.ENABLE_THERMAL_MANAGEMENT !== 'false',
            cpuGovernor: process.env.CPU_GOVERNOR || 'performance',
            memorySwappiness: parseInt(process.env.MEMORY_SWAPPINESS || '10'),
            ioScheduler: process.env.IO_SCHEDULER || 'mq-deadline',
            networkBufferSize: parseInt(process.env.NETWORK_BUFFER_SIZE || '16777216'),
            thermalThrottleTemp: parseInt(process.env.THERMAL_THROTTLE_TEMP || '75'),
            monitoringIntervalMs: parseInt(process.env.PERF_MONITORING_INTERVAL_MS || '60000')
        };
    }
    /**
     * Initialize performance optimization
     * Sets up all optimization systems and starts monitoring
     *
     * @returns Promise<void>
     */
    async initializePerformanceOptimization() {
        try {
            logger_1.logger.info('‚ö° Initializing performance optimization...');
            // Apply initial optimizations
            await this.applyInitialOptimizations();
            // Start performance monitoring
            await this.startPerformanceMonitoring();
            // Set up thermal management
            await this.setupThermalManagement();
            logger_1.logger.info('‚úÖ Performance optimization initialized successfully');
            // Audit log
            await audit_service_1.auditService.createAuditEntry({
                auditId: `perf_opt_init_${Date.now()}`,
                eventType: 'PERFORMANCE_OPTIMIZATION_INIT',
                actor: 'SYSTEM',
                resource: 'PERFORMANCE_OPTIMIZER',
                action: 'INITIALIZE',
                result: 'SUCCESS',
                timestamp: new Date(),
                auditData: { config: this.config }
            });
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to initialize performance optimization:', error);
            throw new Error('Performance optimization initialization failed');
        }
    }
    /**
     * Apply initial system optimizations
     * Configures system for optimal trading performance
     *
     * @returns Promise<void>
     */
    async applyInitialOptimizations() {
        try {
            logger_1.logger.info('üîß Applying initial system optimizations...');
            const optimizations = [];
            // CPU optimizations
            if (this.config.enableCPUOptimization) {
                optimizations.push(this.optimizeCPUPerformance());
            }
            // Memory optimizations
            if (this.config.enableMemoryOptimization) {
                optimizations.push(this.optimizeMemoryPerformance());
            }
            // I/O optimizations
            if (this.config.enableIOOptimization) {
                optimizations.push(this.optimizeIOPerformance());
            }
            // Network optimizations
            if (this.config.enableNetworkOptimization) {
                optimizations.push(this.optimizeNetworkPerformance());
            }
            // Apply all optimizations concurrently
            await Promise.all(optimizations);
            logger_1.logger.info('‚úÖ Initial optimizations applied successfully');
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to apply initial optimizations:', error);
            throw error;
        }
    }
    /**
     * Optimize CPU performance for low-latency trading
     *
     * @returns Promise<void>
     */
    async optimizeCPUPerformance() {
        try {
            logger_1.logger.info('üîß Optimizing CPU performance...');
            // Set CPU governor to performance mode
            try {
                const { execSync } = await import('child_process');
                execSync(`echo ${this.config.cpuGovernor} | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor`, { stdio: 'pipe' });
                logger_1.logger.info(`‚úÖ CPU governor set to: ${this.config.cpuGovernor}`);
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not set CPU governor (may require sudo):', error);
            }
            // Disable CPU idle states for consistent performance
            try {
                const { execSync } = await import('child_process');
                execSync('sudo cpupower idle-set -D 0', { stdio: 'pipe' });
                logger_1.logger.info('‚úÖ CPU idle states optimized');
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not optimize CPU idle states:', error);
            }
            // Set CPU affinity for trading processes
            await this.setCPUAffinity();
        }
        catch (error) {
            logger_1.logger.error('‚ùå CPU optimization failed:', error);
        }
    }
    /**
     * Set CPU affinity for optimal performance
     *
     * @returns Promise<void>
     */
    async setCPUAffinity() {
        try {
            const cpuInfo = await si.cpu();
            const coreCount = cpuInfo.cores;
            if (coreCount >= 4) {
                // Reserve cores 0-1 for trading operations, 2-3 for system
                process.env.TRADING_CPU_CORES = '0,1';
                process.env.SYSTEM_CPU_CORES = '2,3';
                logger_1.logger.info('‚úÖ CPU affinity configured for trading optimization');
            }
        }
        catch (error) {
            logger_1.logger.warn('‚ö†Ô∏è Could not set CPU affinity:', error);
        }
    }
    /**
     * Optimize memory performance
     *
     * @returns Promise<void>
     */
    async optimizeMemoryPerformance() {
        try {
            logger_1.logger.info('üîß Optimizing memory performance...');
            // Set memory swappiness for trading workload
            try {
                const { execSync } = await import('child_process');
                execSync(`echo ${this.config.memorySwappiness} | sudo tee /proc/sys/vm/swappiness`, { stdio: 'pipe' });
                logger_1.logger.info(`‚úÖ Memory swappiness set to: ${this.config.memorySwappiness}`);
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not set memory swappiness:', error);
            }
            // Optimize memory allocation
            try {
                const { execSync } = await import('child_process');
                // Reduce memory overcommit for stability
                execSync('echo 2 | sudo tee /proc/sys/vm/overcommit_memory', { stdio: 'pipe' });
                // Optimize dirty page writeback
                execSync('echo 5 | sudo tee /proc/sys/vm/dirty_background_ratio', { stdio: 'pipe' });
                execSync('echo 10 | sudo tee /proc/sys/vm/dirty_ratio', { stdio: 'pipe' });
                logger_1.logger.info('‚úÖ Memory allocation optimized');
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not optimize memory allocation:', error);
            }
            // Configure Node.js memory settings
            this.optimizeNodeJSMemory();
        }
        catch (error) {
            logger_1.logger.error('‚ùå Memory optimization failed:', error);
        }
    }
    /**
     * Optimize Node.js memory settings
     */
    optimizeNodeJSMemory() {
        try {
            // Set optimal heap sizes for trading application
            const totalMemoryGB = Math.floor(require('os').totalmem() / 1024 / 1024 / 1024);
            const maxHeapSize = Math.floor(totalMemoryGB * 0.6); // Use 60% of total memory
            process.env.NODE_OPTIONS = `--max-old-space-size=${maxHeapSize * 1024}`;
            // Enable garbage collection optimizations
            if (process.env.NODE_ENV === 'production') {
                process.env.NODE_OPTIONS += ' --optimize-for-size';
            }
            logger_1.logger.info(`‚úÖ Node.js memory optimized: ${maxHeapSize}GB heap`);
        }
        catch (error) {
            logger_1.logger.warn('‚ö†Ô∏è Could not optimize Node.js memory:', error);
        }
    }
    /**
     * Optimize I/O performance
     *
     * @returns Promise<void>
     */
    async optimizeIOPerformance() {
        try {
            logger_1.logger.info('üîß Optimizing I/O performance...');
            // Set I/O scheduler for SSD optimization
            try {
                const { execSync } = await import('child_process');
                const blockDevices = await si.blockDevices();
                for (const device of blockDevices) {
                    if (device.type === 'disk' && !device.removable) {
                        try {
                            execSync(`echo ${this.config.ioScheduler} | sudo tee /sys/block/${device.name}/queue/scheduler`, { stdio: 'pipe' });
                            logger_1.logger.info(`‚úÖ I/O scheduler set to ${this.config.ioScheduler} for ${device.name}`);
                        }
                        catch (error) {
                            logger_1.logger.warn(`‚ö†Ô∏è Could not set I/O scheduler for ${device.name}:`, error);
                        }
                    }
                }
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not optimize I/O scheduler:', error);
            }
            // Optimize file system parameters
            await this.optimizeFileSystem();
        }
        catch (error) {
            logger_1.logger.error('‚ùå I/O optimization failed:', error);
        }
    }
    /**
     * Optimize file system parameters
     *
     * @returns Promise<void>
     */
    async optimizeFileSystem() {
        try {
            const { execSync } = await import('child_process');
            // Optimize read-ahead for sequential I/O
            execSync('sudo blockdev --setra 256 /dev/sda', { stdio: 'pipe' });
            // Optimize file system cache
            execSync('echo 1 | sudo tee /proc/sys/vm/vfs_cache_pressure', { stdio: 'pipe' });
            logger_1.logger.info('‚úÖ File system optimized');
        }
        catch (error) {
            logger_1.logger.warn('‚ö†Ô∏è Could not optimize file system:', error);
        }
    }
    /**
     * Optimize network performance
     *
     * @returns Promise<void>
     */
    async optimizeNetworkPerformance() {
        try {
            logger_1.logger.info('üîß Optimizing network performance...');
            const { execSync } = await import('child_process');
            // Optimize TCP settings for low latency
            const tcpOptimizations = [
                'net.core.rmem_max = 16777216',
                'net.core.wmem_max = 16777216',
                'net.ipv4.tcp_rmem = 4096 87380 16777216',
                'net.ipv4.tcp_wmem = 4096 65536 16777216',
                'net.ipv4.tcp_congestion_control = bbr',
                'net.ipv4.tcp_fastopen = 3',
                'net.ipv4.tcp_low_latency = 1',
                'net.core.netdev_max_backlog = 5000'
            ];
            for (const optimization of tcpOptimizations) {
                try {
                    execSync(`echo "${optimization}" | sudo tee -a /etc/sysctl.conf`, { stdio: 'pipe' });
                }
                catch (error) {
                    logger_1.logger.warn(`‚ö†Ô∏è Could not apply network optimization: ${optimization}`);
                }
            }
            // Apply sysctl changes
            try {
                execSync('sudo sysctl -p', { stdio: 'pipe' });
                logger_1.logger.info('‚úÖ Network performance optimized');
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not apply sysctl changes:', error);
            }
        }
        catch (error) {
            logger_1.logger.error('‚ùå Network optimization failed:', error);
        }
    }
    /**
     * Setup thermal management
     *
     * @returns Promise<void>
     */
    async setupThermalManagement() {
        try {
            logger_1.logger.info('üå°Ô∏è Setting up thermal management...');
            // Start thermal monitoring
            setInterval(async () => {
                await this.monitorThermalConditions();
            }, 10000); // Check every 10 seconds
            logger_1.logger.info('‚úÖ Thermal management setup complete');
        }
        catch (error) {
            logger_1.logger.error('‚ùå Thermal management setup failed:', error);
        }
    }
    /**
     * Monitor thermal conditions and apply throttling if needed
     *
     * @returns Promise<void>
     */
    async monitorThermalConditions() {
        try {
            const cpuTemp = await si.cpuTemperature();
            const currentTemp = cpuTemp.main || 0;
            if (currentTemp >= this.config.thermalThrottleTemp) {
                await this.applyThermalThrottling(currentTemp);
            }
            else if (currentTemp < this.config.thermalThrottleTemp - 5) {
                // Remove throttling if temperature is safe
                await this.removeThermalThrottling();
            }
        }
        catch (error) {
            logger_1.logger.error('‚ùå Thermal monitoring failed:', error);
        }
    }
    /**
     * Apply thermal throttling to prevent overheating
     *
     * @param currentTemp Current CPU temperature
     * @returns Promise<void>
     */
    async applyThermalThrottling(currentTemp) {
        try {
            logger_1.logger.warn(`üå°Ô∏è Applying thermal throttling - CPU temp: ${currentTemp}¬∞C`);
            // Reduce CPU frequency
            const { execSync } = await import('child_process');
            try {
                execSync('echo powersave | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor', { stdio: 'pipe' });
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not apply CPU throttling:', error);
            }
            // Audit critical thermal event
            await audit_service_1.auditService.createAuditEntry({
                auditId: `thermal_throttle_${Date.now()}`,
                eventType: 'THERMAL_THROTTLING_APPLIED',
                actor: 'PERFORMANCE_OPTIMIZER',
                resource: 'CPU_THERMAL',
                action: 'APPLY_THROTTLING',
                result: 'SUCCESS',
                timestamp: new Date(),
                auditData: { currentTemp, threshold: this.config.thermalThrottleTemp }
            });
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to apply thermal throttling:', error);
        }
    }
    /**
     * Remove thermal throttling when temperature is safe
     *
     * @returns Promise<void>
     */
    async removeThermalThrottling() {
        try {
            if (this.config.enableCPUOptimization) {
                const { execSync } = await import('child_process');
                try {
                    execSync(`echo ${this.config.cpuGovernor} | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor`, { stdio: 'pipe' });
                    logger_1.logger.info('‚úÖ Thermal throttling removed - normal performance restored');
                }
                catch (error) {
                    logger_1.logger.warn('‚ö†Ô∏è Could not remove CPU throttling:', error);
                }
            }
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to remove thermal throttling:', error);
        }
    }
    /**
     * Start performance monitoring
     *
     * @returns Promise<void>
     */
    async startPerformanceMonitoring() {
        try {
            logger_1.logger.info('üìä Starting performance monitoring...');
            this.optimizationInterval = setInterval(async () => {
                try {
                    await this.measurePerformance();
                    await this.generateOptimizationRecommendations();
                }
                catch (error) {
                    logger_1.logger.error('‚ùå Performance monitoring error:', error);
                }
            }, this.config.monitoringIntervalMs);
            logger_1.logger.info('‚úÖ Performance monitoring started');
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to start performance monitoring:', error);
        }
    }
    /**
     * Measure system performance metrics
     *
     * @returns Promise<PerformanceMetrics>
     */
    async measurePerformance() {
        try {
            const startTime = process.hrtime.bigint();
            // Get current system metrics
            const metrics = this.systemMonitor.getCurrentMetrics();
            // Calculate performance scores
            const cpuScore = this.calculateCPUScore(metrics.cpu);
            const memoryScore = this.calculateMemoryScore(metrics.ram);
            const ioScore = this.calculateIOScore(metrics.ssd);
            const networkScore = this.calculateNetworkScore(metrics.network);
            const thermalScore = await this.calculateThermalScore();
            // Measure latency
            const latency = await this.measureSystemLatency();
            this.latencyMeasurements.push(latency);
            // Keep only last 1000 measurements
            if (this.latencyMeasurements.length > 1000) {
                this.latencyMeasurements = this.latencyMeasurements.slice(-1000);
            }
            // Calculate latency statistics
            const sortedLatencies = [...this.latencyMeasurements].sort((a, b) => a - b);
            const latencyStats = {
                average: this.latencyMeasurements.reduce((a, b) => a + b, 0) / this.latencyMeasurements.length,
                maximum: Math.max(...this.latencyMeasurements),
                p95: sortedLatencies[Math.floor(sortedLatencies.length * 0.95)] || 0,
                p99: sortedLatencies[Math.floor(sortedLatencies.length * 0.99)] || 0
            };
            // Calculate throughput metrics
            const throughput = {
                cpuOps: this.calculateCPUThroughput(metrics.cpu),
                memoryBandwidth: this.calculateMemoryBandwidth(metrics.ram),
                diskIOPS: metrics.ssd?.readIOPS || 0 + metrics.ssd?.writeIOPS || 0,
                networkThroughput: (metrics.network?.downloadSpeed || 0) + (metrics.network?.uploadSpeed || 0)
            };
            const overallScore = Math.round((cpuScore + memoryScore + ioScore + networkScore + thermalScore) / 5);
            const performanceMetrics = {
                overallScore,
                cpuScore,
                memoryScore,
                ioScore,
                networkScore,
                thermalScore,
                latency: latencyStats,
                throughput,
                timestamp: new Date()
            };
            // Store in history
            this.performanceHistory.push(performanceMetrics);
            if (this.performanceHistory.length > 100) {
                this.performanceHistory = this.performanceHistory.slice(-100);
            }
            const endTime = process.hrtime.bigint();
            const measurementTime = Number(endTime - startTime) / 1000000; // Convert to milliseconds
            logger_1.logger.debug('üìä Performance measurement completed', {
                overallScore,
                measurementTime: `${measurementTime.toFixed(2)}ms`,
                latency: latencyStats
            });
            return performanceMetrics;
        }
        catch (error) {
            logger_1.logger.error('‚ùå Performance measurement failed:', error);
            throw error;
        }
    }
    /**
     * Calculate CPU performance score
     *
     * @param cpu CPU metrics
     * @returns number Performance score (0-100)
     */
    calculateCPUScore(cpu) {
        if (!cpu)
            return 0;
        // Lower utilization and temperature = higher score
        const utilizationScore = Math.max(0, 100 - cpu.utilization);
        const temperatureScore = Math.max(0, 100 - (cpu.temperature / 80) * 100);
        const frequencyScore = Math.min(100, (cpu.frequency / 3000) * 100); // Assume 3GHz target
        return Math.round((utilizationScore + temperatureScore + frequencyScore) / 3);
    }
    /**
     * Calculate memory performance score
     *
     * @param ram RAM metrics
     * @returns number Performance score (0-100)
     */
    calculateMemoryScore(ram) {
        if (!ram)
            return 0;
        // Lower utilization = higher score, but some usage is expected
        const utilizationScore = ram.utilization < 50 ? 100 : Math.max(0, 100 - (ram.utilization - 50) * 2);
        const availabilityScore = Math.min(100, (ram.available / ram.total) * 200);
        return Math.round((utilizationScore + availabilityScore) / 2);
    }
    /**
     * Calculate I/O performance score
     *
     * @param ssd SSD metrics
     * @returns number Performance score (0-100)
     */
    calculateIOScore(ssd) {
        if (!ssd)
            return 0;
        // Higher throughput and lower utilization = higher score
        const utilizationScore = Math.max(0, 100 - ssd.utilization);
        const throughputScore = Math.min(100, ((ssd.readThroughput + ssd.writeThroughput) / 500) * 100);
        const healthScore = ssd.health;
        return Math.round((utilizationScore + throughputScore + healthScore) / 3);
    }
    /**
     * Calculate network performance score
     *
     * @param network Network metrics
     * @returns number Performance score (0-100)
     */
    calculateNetworkScore(network) {
        if (!network)
            return 0;
        const activeInterfaces = network.interfaces?.filter((i) => i.isUp).length || 0;
        const connectivityScore = activeInterfaces > 0 ? 100 : 0;
        const speedScore = Math.min(100, ((network.downloadSpeed + network.uploadSpeed) / 100) * 100);
        return Math.round((connectivityScore + speedScore) / 2);
    }
    /**
     * Calculate thermal performance score
     *
     * @returns Promise<number> Performance score (0-100)
     */
    async calculateThermalScore() {
        try {
            const cpuTemp = await si.cpuTemperature();
            const currentTemp = cpuTemp.main || 0;
            // Lower temperature = higher score
            if (currentTemp < 50)
                return 100;
            if (currentTemp < 60)
                return 90;
            if (currentTemp < 70)
                return 70;
            if (currentTemp < 80)
                return 50;
            return 20;
        }
        catch (error) {
            return 50; // Default score if measurement fails
        }
    }
    /**
     * Measure system latency
     *
     * @returns Promise<number> Latency in microseconds
     */
    async measureSystemLatency() {
        const start = process.hrtime.bigint();
        // Perform a small I/O operation to measure system responsiveness
        await new Promise(resolve => setImmediate(resolve));
        const end = process.hrtime.bigint();
        return Number(end - start) / 1000; // Convert to microseconds
    }
    /**
     * Calculate CPU throughput
     *
     * @param cpu CPU metrics
     * @returns number Operations per second
     */
    calculateCPUThroughput(cpu) {
        if (!cpu)
            return 0;
        // Estimate based on frequency and utilization
        return Math.round((cpu.frequency * cpu.cores.logical * (cpu.utilization / 100)) / 1000);
    }
    /**
     * Calculate memory bandwidth
     *
     * @param ram RAM metrics
     * @returns number Bandwidth in MB/s
     */
    calculateMemoryBandwidth(ram) {
        if (!ram)
            return 0;
        // Estimate based on memory usage patterns
        return Math.round((ram.used / ram.total) * 25600); // Assume DDR4-3200 theoretical max
    }
    /**
     * Generate optimization recommendations
     *
     * @returns Promise<OptimizationRecommendation[]>
     */
    async generateOptimizationRecommendations() {
        try {
            const recommendations = [];
            const metrics = this.systemMonitor.getCurrentMetrics();
            const latestPerformance = this.performanceHistory[this.performanceHistory.length - 1];
            // CPU recommendations
            if (metrics.cpu && metrics.cpu.utilization > 80) {
                recommendations.push({
                    id: `cpu_high_util_${Date.now()}`,
                    type: 'CPU',
                    priority: 'HIGH',
                    title: 'High CPU Utilization',
                    description: `CPU utilization is ${metrics.cpu.utilization}%. Consider reducing background processes or upgrading CPU.`,
                    expectedImprovement: 15,
                    complexity: 'MEDIUM',
                    canAutoApply: false,
                    timestamp: new Date()
                });
            }
            // Memory recommendations
            if (metrics.ram && metrics.ram.utilization > 85) {
                recommendations.push({
                    id: `memory_high_util_${Date.now()}`,
                    type: 'MEMORY',
                    priority: 'HIGH',
                    title: 'High Memory Utilization',
                    description: `Memory utilization is ${metrics.ram.utilization}%. Consider adding more RAM or optimizing memory usage.`,
                    expectedImprovement: 20,
                    complexity: 'EASY',
                    canAutoApply: false,
                    timestamp: new Date()
                });
            }
            // Thermal recommendations
            if (metrics.cpu && metrics.cpu.temperature > 70) {
                recommendations.push({
                    id: `thermal_high_temp_${Date.now()}`,
                    type: 'THERMAL',
                    priority: 'CRITICAL',
                    title: 'High CPU Temperature',
                    description: `CPU temperature is ${metrics.cpu.temperature}¬∞C. Check cooling system and ventilation.`,
                    expectedImprovement: 25,
                    complexity: 'MEDIUM',
                    canAutoApply: true,
                    implementation: 'apply_thermal_throttling',
                    timestamp: new Date()
                });
            }
            // Performance recommendations
            if (latestPerformance && latestPerformance.overallScore < 70) {
                recommendations.push({
                    id: `perf_low_score_${Date.now()}`,
                    type: 'CPU',
                    priority: 'MEDIUM',
                    title: 'Low Performance Score',
                    description: `Overall performance score is ${latestPerformance.overallScore}%. System optimization recommended.`,
                    expectedImprovement: 30,
                    complexity: 'MEDIUM',
                    canAutoApply: true,
                    implementation: 'reapply_optimizations',
                    timestamp: new Date()
                });
            }
            return recommendations;
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to generate optimization recommendations:', error);
            return [];
        }
    }
    /**
     * Get current thermal status
     *
     * @returns Promise<ThermalStatus>
     */
    async getThermalStatus() {
        try {
            const cpuTemp = await si.cpuTemperature();
            const currentTemp = cpuTemp.main || 0;
            const maxSafeTemp = this.config.thermalThrottleTemp;
            const isThrottling = currentTemp >= maxSafeTemp;
            const alerts = [];
            const recommendations = [];
            if (currentTemp > 80) {
                alerts.push('Critical temperature - immediate action required');
                recommendations.push('Check system cooling and ventilation');
                recommendations.push('Reduce system load');
            }
            else if (currentTemp > 70) {
                alerts.push('High temperature - monitoring required');
                recommendations.push('Verify cooling system operation');
            }
            const coolingEffectiveness = Math.max(0, 100 - ((currentTemp - 30) / 50) * 100);
            return {
                currentTemp,
                maxSafeTemp,
                isThrottling,
                coolingEffectiveness: Math.round(coolingEffectiveness),
                alerts,
                recommendations
            };
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to get thermal status:', error);
            throw error;
        }
    }
    /**
     * Get performance history
     *
     * @returns PerformanceMetrics[] Performance history
     */
    getPerformanceHistory() {
        return [...this.performanceHistory];
    }
    /**
     * Get current performance metrics
     *
     * @returns PerformanceMetrics | null Current metrics
     */
    getCurrentPerformanceMetrics() {
        return this.performanceHistory[this.performanceHistory.length - 1] || null;
    }
    /**
     * Stop performance optimization
     */
    stopPerformanceOptimization() {
        if (this.optimizationInterval) {
            clearInterval(this.optimizationInterval);
            this.optimizationInterval = null;
            logger_1.logger.info('üõë Performance optimization stopped');
        }
    }
    /**
     * Get optimizer status
     *
     * @returns Object containing status information
     */
    getStatus() {
        const latestMetrics = this.getCurrentPerformanceMetrics();
        return {
            isOptimizing: this.optimizationInterval !== null,
            config: this.config,
            performanceHistory: this.performanceHistory.length,
            latestScore: latestMetrics?.overallScore || null,
            timestamp: Date.now()
        };
    }
}
exports.PerformanceOptimizer = PerformanceOptimizer;
// =============================================================================
// PERFORMANCE OPTIMIZATION NOTES
// =============================================================================
// 1. Low-latency optimizations for high-frequency trading operations
// 2. Thermal management to prevent performance degradation
// 3. Resource allocation optimization for consistent performance
// 4. Real-time performance monitoring and adjustment
// 5. Automatic optimization recommendations and implementation
// 6. System health scoring for performance assessment
// 7. Comprehensive logging and audit trails for all optimizations
// 8. Hardware-specific optimizations for Intel NUC platform
// =============================================================================
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxOaWNrXFxEZXNrdG9wXFxTbW9vdGhTYWlsXFxzcmNcXGluZnJhc3RydWN0dXJlXFxwZXJmb3JtYW5jZS1vcHRpbWl6ZXIudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3Qkc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILHNEQUF3QztBQUN4QyxrREFBK0M7QUFDL0MsNERBQXdEO0FBcUh4RDs7O0dBR0c7QUFDSCxNQUFhLG9CQUFvQjtJQUN2QixhQUFhLENBQWdCO0lBQzdCLE1BQU0sQ0FBb0I7SUFDMUIsb0JBQW9CLEdBQTBCLElBQUksQ0FBQztJQUNuRCxrQkFBa0IsR0FBeUIsRUFBRSxDQUFDO0lBQzlDLG1CQUFtQixHQUFhLEVBQUUsQ0FBQztJQUNuQyxZQUFZLEdBQVksS0FBSyxDQUFDO0lBRXRDLFlBQVksYUFBNEI7UUFDdEMsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN2QyxlQUFNLENBQUMsSUFBSSxDQUFDLHlDQUF5QyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxpQkFBaUI7UUFDdkIsT0FBTztZQUNMLHFCQUFxQixFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEtBQUssTUFBTTtZQUNyRSx3QkFBd0IsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLDBCQUEwQixLQUFLLE1BQU07WUFDM0Usb0JBQW9CLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsS0FBSyxNQUFNO1lBQ25FLHlCQUF5QixFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsMkJBQTJCLEtBQUssTUFBTTtZQUM3RSx1QkFBdUIsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixLQUFLLE9BQU87WUFDMUUsV0FBVyxFQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBb0IsSUFBSSxhQUFhO1lBQy9ELGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixJQUFJLElBQUksQ0FBQztZQUNqRSxXQUFXLEVBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFvQixJQUFJLGFBQWE7WUFDL0QsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLElBQUksVUFBVSxDQUFDO1lBQzFFLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQztZQUN4RSxvQkFBb0IsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQywyQkFBMkIsSUFBSSxPQUFPLENBQUM7U0FDbkYsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEtBQUssQ0FBQyxpQ0FBaUM7UUFDNUMsSUFBSSxDQUFDO1lBQ0gsZUFBTSxDQUFDLElBQUksQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO1lBRTFELDhCQUE4QjtZQUM5QixNQUFNLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO1lBRXZDLCtCQUErQjtZQUMvQixNQUFNLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDO1lBRXhDLDRCQUE0QjtZQUM1QixNQUFNLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1lBRXBDLGVBQU0sQ0FBQyxJQUFJLENBQUMscURBQXFELENBQUMsQ0FBQztZQUVuRSxZQUFZO1lBQ1osTUFBTSw0QkFBWSxDQUFDLGdCQUFnQixDQUFDO2dCQUNsQyxPQUFPLEVBQUUsaUJBQWlCLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDdEMsU0FBUyxFQUFFLCtCQUErQjtnQkFDMUMsS0FBSyxFQUFFLFFBQVE7Z0JBQ2YsUUFBUSxFQUFFLHVCQUF1QjtnQkFDakMsTUFBTSxFQUFFLFlBQVk7Z0JBQ3BCLE1BQU0sRUFBRSxTQUFTO2dCQUNqQixTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUU7Z0JBQ3JCLFNBQVMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFO2FBQ25DLENBQUMsQ0FBQztRQUVMLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyxrREFBa0QsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN4RSxNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7UUFDcEUsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLEtBQUssQ0FBQyx5QkFBeUI7UUFDckMsSUFBSSxDQUFDO1lBQ0gsZUFBTSxDQUFDLElBQUksQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1lBRTNELE1BQU0sYUFBYSxHQUFvQixFQUFFLENBQUM7WUFFMUMsb0JBQW9CO1lBQ3BCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2dCQUN0QyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLENBQUM7WUFDcEQsQ0FBQztZQUVELHVCQUF1QjtZQUN2QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztnQkFDekMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZELENBQUM7WUFFRCxvQkFBb0I7WUFDcEIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLG9CQUFvQixFQUFFLENBQUM7Z0JBQ3JDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUMsQ0FBQztZQUNuRCxDQUFDO1lBRUQsd0JBQXdCO1lBQ3hCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO2dCQUMxQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDLENBQUM7WUFDeEQsQ0FBQztZQUVELHVDQUF1QztZQUN2QyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7WUFFakMsZUFBTSxDQUFDLElBQUksQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO1FBRTlELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQywwQ0FBMEMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNoRSxNQUFNLEtBQUssQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyxzQkFBc0I7UUFDbEMsSUFBSSxDQUFDO1lBQ0gsZUFBTSxDQUFDLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1lBRWhELHVDQUF1QztZQUN2QyxJQUFJLENBQUM7Z0JBQ0gsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUNuRCxRQUFRLENBQUMsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsbUVBQW1FLEVBQ3pHLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQ3JCLGVBQU0sQ0FBQyxJQUFJLENBQUMsMEJBQTBCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztZQUNuRSxDQUFDO1lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztnQkFDZixlQUFNLENBQUMsSUFBSSxDQUFDLG1EQUFtRCxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzFFLENBQUM7WUFFRCxxREFBcUQ7WUFDckQsSUFBSSxDQUFDO2dCQUNILE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDbkQsUUFBUSxDQUFDLDZCQUE2QixFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQzNELGVBQU0sQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztZQUM3QyxDQUFDO1lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztnQkFDZixlQUFNLENBQUMsSUFBSSxDQUFDLHdDQUF3QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQy9ELENBQUM7WUFFRCx5Q0FBeUM7WUFDekMsTUFBTSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFOUIsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixlQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3BELENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyxjQUFjO1FBQzFCLElBQUksQ0FBQztZQUNILE1BQU0sT0FBTyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQy9CLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFFaEMsSUFBSSxTQUFTLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ25CLDJEQUEyRDtnQkFDM0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7Z0JBQ3RDLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO2dCQUNyQyxlQUFNLENBQUMsSUFBSSxDQUFDLG9EQUFvRCxDQUFDLENBQUM7WUFDcEUsQ0FBQztRQUVILENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLElBQUksQ0FBQyxnQ0FBZ0MsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxLQUFLLENBQUMseUJBQXlCO1FBQ3JDLElBQUksQ0FBQztZQUNILGVBQU0sQ0FBQyxJQUFJLENBQUMscUNBQXFDLENBQUMsQ0FBQztZQUVuRCw2Q0FBNkM7WUFDN0MsSUFBSSxDQUFDO2dCQUNILE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDbkQsUUFBUSxDQUFDLFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IscUNBQXFDLEVBQ2hGLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQ3JCLGVBQU0sQ0FBQyxJQUFJLENBQUMsK0JBQStCLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO1lBQzdFLENBQUM7WUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLGVBQU0sQ0FBQyxJQUFJLENBQUMscUNBQXFDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDNUQsQ0FBQztZQUVELDZCQUE2QjtZQUM3QixJQUFJLENBQUM7Z0JBQ0gsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUNuRCx5Q0FBeUM7Z0JBQ3pDLFFBQVEsQ0FBQyxrREFBa0QsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO2dCQUNoRixnQ0FBZ0M7Z0JBQ2hDLFFBQVEsQ0FBQyx1REFBdUQsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO2dCQUNyRixRQUFRLENBQUMsNkNBQTZDLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztnQkFDM0UsZUFBTSxDQUFDLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1lBQy9DLENBQUM7WUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLGVBQU0sQ0FBQyxJQUFJLENBQUMsMENBQTBDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDakUsQ0FBQztZQUVELG9DQUFvQztZQUNwQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUU5QixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLGVBQU0sQ0FBQyxLQUFLLENBQUMsK0JBQStCLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkQsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNLLG9CQUFvQjtRQUMxQixJQUFJLENBQUM7WUFDSCxpREFBaUQ7WUFDakQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQztZQUNoRixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLDBCQUEwQjtZQUUvRSxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksR0FBRyx3QkFBd0IsV0FBVyxHQUFHLElBQUksRUFBRSxDQUFDO1lBRXhFLDBDQUEwQztZQUMxQyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxLQUFLLFlBQVksRUFBRSxDQUFDO2dCQUMxQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksSUFBSSxzQkFBc0IsQ0FBQztZQUNyRCxDQUFDO1lBRUQsZUFBTSxDQUFDLElBQUksQ0FBQywrQkFBK0IsV0FBVyxTQUFTLENBQUMsQ0FBQztRQUVuRSxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLGVBQU0sQ0FBQyxJQUFJLENBQUMsdUNBQXVDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDOUQsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLHFCQUFxQjtRQUNqQyxJQUFJLENBQUM7WUFDSCxlQUFNLENBQUMsSUFBSSxDQUFDLGtDQUFrQyxDQUFDLENBQUM7WUFFaEQseUNBQXlDO1lBQ3pDLElBQUksQ0FBQztnQkFDSCxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsTUFBTSxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBQ25ELE1BQU0sWUFBWSxHQUFHLE1BQU0sRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUU3QyxLQUFLLE1BQU0sTUFBTSxJQUFJLFlBQVksRUFBRSxDQUFDO29CQUNsQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO3dCQUNoRCxJQUFJLENBQUM7NEJBQ0gsUUFBUSxDQUFDLFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLDBCQUEwQixNQUFNLENBQUMsSUFBSSxrQkFBa0IsRUFDN0YsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQzs0QkFDckIsZUFBTSxDQUFDLElBQUksQ0FBQywwQkFBMEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLFFBQVEsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7d0JBQ3RGLENBQUM7d0JBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQzs0QkFDZixlQUFNLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxNQUFNLENBQUMsSUFBSSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7d0JBQzNFLENBQUM7b0JBQ0gsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztZQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsZUFBTSxDQUFDLElBQUksQ0FBQyxzQ0FBc0MsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUM3RCxDQUFDO1lBRUQsa0NBQWtDO1lBQ2xDLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFbEMsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixlQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3BELENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyxrQkFBa0I7UUFDOUIsSUFBSSxDQUFDO1lBQ0gsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBRW5ELHlDQUF5QztZQUN6QyxRQUFRLENBQUMsb0NBQW9DLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztZQUVsRSw2QkFBNkI7WUFDN0IsUUFBUSxDQUFDLG1EQUFtRCxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFFakYsZUFBTSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBRXpDLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLElBQUksQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMzRCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxLQUFLLENBQUMsMEJBQTBCO1FBQ3RDLElBQUksQ0FBQztZQUNILGVBQU0sQ0FBQyxJQUFJLENBQUMsc0NBQXNDLENBQUMsQ0FBQztZQUVwRCxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsTUFBTSxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7WUFFbkQsd0NBQXdDO1lBQ3hDLE1BQU0sZ0JBQWdCLEdBQUc7Z0JBQ3ZCLDhCQUE4QjtnQkFDOUIsOEJBQThCO2dCQUM5Qix5Q0FBeUM7Z0JBQ3pDLHlDQUF5QztnQkFDekMsdUNBQXVDO2dCQUN2QywyQkFBMkI7Z0JBQzNCLDhCQUE4QjtnQkFDOUIsb0NBQW9DO2FBQ3JDLENBQUM7WUFFRixLQUFLLE1BQU0sWUFBWSxJQUFJLGdCQUFnQixFQUFFLENBQUM7Z0JBQzVDLElBQUksQ0FBQztvQkFDSCxRQUFRLENBQUMsU0FBUyxZQUFZLGtDQUFrQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQ3ZGLENBQUM7Z0JBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztvQkFDZixlQUFNLENBQUMsSUFBSSxDQUFDLDRDQUE0QyxZQUFZLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxDQUFDO1lBQ0gsQ0FBQztZQUVELHVCQUF1QjtZQUN2QixJQUFJLENBQUM7Z0JBQ0gsUUFBUSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQzlDLGVBQU0sQ0FBQyxJQUFJLENBQUMsaUNBQWlDLENBQUMsQ0FBQztZQUNqRCxDQUFDO1lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztnQkFDZixlQUFNLENBQUMsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzNELENBQUM7UUFFSCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLGVBQU0sQ0FBQyxLQUFLLENBQUMsZ0NBQWdDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDeEQsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLHNCQUFzQjtRQUNqQyxJQUFJLENBQUM7WUFDSCxlQUFNLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxDQUFDLENBQUM7WUFFcEQsMkJBQTJCO1lBQzNCLFdBQVcsQ0FBQyxLQUFLLElBQUksRUFBRTtnQkFDckIsTUFBTSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztZQUN4QyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyx5QkFBeUI7WUFFcEMsZUFBTSxDQUFDLElBQUksQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1FBRXJELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM1RCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxLQUFLLENBQUMsd0JBQXdCO1FBQ3BDLElBQUksQ0FBQztZQUNILE1BQU0sT0FBTyxHQUFHLE1BQU0sRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQzFDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1lBRXRDLElBQUksV0FBVyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztnQkFDbkQsTUFBTSxJQUFJLENBQUMsc0JBQXNCLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDakQsQ0FBQztpQkFBTSxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUM3RCwyQ0FBMkM7Z0JBQzNDLE1BQU0sSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7WUFDdkMsQ0FBQztRQUVILENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyw4QkFBOEIsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN0RCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssS0FBSyxDQUFDLHNCQUFzQixDQUFDLFdBQW1CO1FBQ3RELElBQUksQ0FBQztZQUNILGVBQU0sQ0FBQyxJQUFJLENBQUMsK0NBQStDLFdBQVcsSUFBSSxDQUFDLENBQUM7WUFFNUUsdUJBQXVCO1lBQ3ZCLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUM7Z0JBQ0gsUUFBUSxDQUFDLGlGQUFpRixFQUN4RixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZCLENBQUM7WUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLGVBQU0sQ0FBQyxJQUFJLENBQUMsb0NBQW9DLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDM0QsQ0FBQztZQUVELCtCQUErQjtZQUMvQixNQUFNLDRCQUFZLENBQUMsZ0JBQWdCLENBQUM7Z0JBQ2xDLE9BQU8sRUFBRSxvQkFBb0IsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO2dCQUN6QyxTQUFTLEVBQUUsNEJBQTRCO2dCQUN2QyxLQUFLLEVBQUUsdUJBQXVCO2dCQUM5QixRQUFRLEVBQUUsYUFBYTtnQkFDdkIsTUFBTSxFQUFFLGtCQUFrQjtnQkFDMUIsTUFBTSxFQUFFLFNBQVM7Z0JBQ2pCLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtnQkFDckIsU0FBUyxFQUFFLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFO2FBQ3ZFLENBQUMsQ0FBQztRQUVMLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyx1Q0FBdUMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMvRCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxLQUFLLENBQUMsdUJBQXVCO1FBQ25DLElBQUksQ0FBQztZQUNILElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2dCQUN0QyxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsTUFBTSxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBQ25ELElBQUksQ0FBQztvQkFDSCxRQUFRLENBQUMsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsbUVBQW1FLEVBQ3pHLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7b0JBQ3JCLGVBQU0sQ0FBQyxJQUFJLENBQUMsNERBQTRELENBQUMsQ0FBQztnQkFDNUUsQ0FBQztnQkFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO29CQUNmLGVBQU0sQ0FBQyxJQUFJLENBQUMscUNBQXFDLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzVELENBQUM7WUFDSCxDQUFDO1FBRUgsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixlQUFNLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2hFLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQywwQkFBMEI7UUFDdEMsSUFBSSxDQUFDO1lBQ0gsZUFBTSxDQUFDLElBQUksQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1lBRXJELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxXQUFXLENBQUMsS0FBSyxJQUFJLEVBQUU7Z0JBQ2pELElBQUksQ0FBQztvQkFDSCxNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO29CQUNoQyxNQUFNLElBQUksQ0FBQyxtQ0FBbUMsRUFBRSxDQUFDO2dCQUNuRCxDQUFDO2dCQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7b0JBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDekQsQ0FBQztZQUNILENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFFckMsZUFBTSxDQUFDLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1FBRWxELENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQywyQ0FBMkMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNuRSxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsa0JBQWtCO1FBQzdCLElBQUksQ0FBQztZQUNILE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7WUFFMUMsNkJBQTZCO1lBQzdCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUV2RCwrQkFBK0I7WUFDL0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzNELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbkQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNqRSxNQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1lBRXhELGtCQUFrQjtZQUNsQixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQ2xELElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFdkMsbUNBQW1DO1lBQ25DLElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sR0FBRyxJQUFJLEVBQUUsQ0FBQztnQkFDM0MsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuRSxDQUFDO1lBRUQsK0JBQStCO1lBQy9CLE1BQU0sZUFBZSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUUsTUFBTSxZQUFZLEdBQUc7Z0JBQ25CLE9BQU8sRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTTtnQkFDOUYsT0FBTyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7Z0JBQzlDLEdBQUcsRUFBRSxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQztnQkFDcEUsR0FBRyxFQUFFLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDO2FBQ3JFLENBQUM7WUFFRiwrQkFBK0I7WUFDL0IsTUFBTSxVQUFVLEdBQUc7Z0JBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztnQkFDaEQsZUFBZSxFQUFFLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO2dCQUMzRCxRQUFRLEVBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxRQUFRLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsU0FBUyxJQUFJLENBQUM7Z0JBQ2xFLGlCQUFpQixFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxhQUFhLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFdBQVcsSUFBSSxDQUFDLENBQUM7YUFDL0YsQ0FBQztZQUVGLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEdBQUcsV0FBVyxHQUFHLE9BQU8sR0FBRyxZQUFZLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFFdEcsTUFBTSxrQkFBa0IsR0FBdUI7Z0JBQzdDLFlBQVk7Z0JBQ1osUUFBUTtnQkFDUixXQUFXO2dCQUNYLE9BQU87Z0JBQ1AsWUFBWTtnQkFDWixZQUFZO2dCQUNaLE9BQU8sRUFBRSxZQUFZO2dCQUNyQixVQUFVO2dCQUNWLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTthQUN0QixDQUFDO1lBRUYsbUJBQW1CO1lBQ25CLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztZQUNqRCxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7Z0JBQ3pDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDaEUsQ0FBQztZQUVELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDeEMsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQywwQkFBMEI7WUFFekYsZUFBTSxDQUFDLEtBQUssQ0FBQyxzQ0FBc0MsRUFBRTtnQkFDbkQsWUFBWTtnQkFDWixlQUFlLEVBQUUsR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJO2dCQUNsRCxPQUFPLEVBQUUsWUFBWTthQUN0QixDQUFDLENBQUM7WUFFSCxPQUFPLGtCQUFrQixDQUFDO1FBRTVCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN6RCxNQUFNLEtBQUssQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxpQkFBaUIsQ0FBQyxHQUFnQjtRQUN4QyxJQUFJLENBQUMsR0FBRztZQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRW5CLG1EQUFtRDtRQUNuRCxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDNUQsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLHFCQUFxQjtRQUV6RixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNoRixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxvQkFBb0IsQ0FBQyxHQUFnQjtRQUMzQyxJQUFJLENBQUMsR0FBRztZQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRW5CLCtEQUErRDtRQUMvRCxNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDcEcsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBRTNFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLGdCQUFnQixHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssZ0JBQWdCLENBQUMsR0FBZ0I7UUFDdkMsSUFBSSxDQUFDLEdBQUc7WUFBRSxPQUFPLENBQUMsQ0FBQztRQUVuQix5REFBeUQ7UUFDekQsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzVELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNoRyxNQUFNLFdBQVcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDO1FBRS9CLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxxQkFBcUIsQ0FBQyxPQUFhO1FBQ3pDLElBQUksQ0FBQyxPQUFPO1lBQUUsT0FBTyxDQUFDLENBQUM7UUFFdkIsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUM7UUFDcEYsTUFBTSxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUU5RixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxpQkFBaUIsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyxxQkFBcUI7UUFDakMsSUFBSSxDQUFDO1lBQ0gsTUFBTSxPQUFPLEdBQUcsTUFBTSxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDMUMsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7WUFFdEMsbUNBQW1DO1lBQ25DLElBQUksV0FBVyxHQUFHLEVBQUU7Z0JBQUUsT0FBTyxHQUFHLENBQUM7WUFDakMsSUFBSSxXQUFXLEdBQUcsRUFBRTtnQkFBRSxPQUFPLEVBQUUsQ0FBQztZQUNoQyxJQUFJLFdBQVcsR0FBRyxFQUFFO2dCQUFFLE9BQU8sRUFBRSxDQUFDO1lBQ2hDLElBQUksV0FBVyxHQUFHLEVBQUU7Z0JBQUUsT0FBTyxFQUFFLENBQUM7WUFDaEMsT0FBTyxFQUFFLENBQUM7UUFFWixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE9BQU8sRUFBRSxDQUFDLENBQUMscUNBQXFDO1FBQ2xELENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyxvQkFBb0I7UUFDaEMsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUV0QyxpRUFBaUU7UUFDakUsTUFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRXBELE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDcEMsT0FBTyxNQUFNLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLDBCQUEwQjtJQUMvRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxzQkFBc0IsQ0FBQyxHQUFnQjtRQUM3QyxJQUFJLENBQUMsR0FBRztZQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRW5CLDhDQUE4QztRQUM5QyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQzFGLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLHdCQUF3QixDQUFDLEdBQWdCO1FBQy9DLElBQUksQ0FBQyxHQUFHO1lBQUUsT0FBTyxDQUFDLENBQUM7UUFFbkIsMENBQTBDO1FBQzFDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsbUNBQW1DO0lBQ3hGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLG1DQUFtQztRQUM5QyxJQUFJLENBQUM7WUFDSCxNQUFNLGVBQWUsR0FBaUMsRUFBRSxDQUFDO1lBQ3pELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUN2RCxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBRXRGLHNCQUFzQjtZQUN0QixJQUFJLE9BQU8sQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsRUFBRSxFQUFFLENBQUM7Z0JBQ2hELGVBQWUsQ0FBQyxJQUFJLENBQUM7b0JBQ25CLEVBQUUsRUFBRSxpQkFBaUIsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO29CQUNqQyxJQUFJLEVBQUUsS0FBSztvQkFDWCxRQUFRLEVBQUUsTUFBTTtvQkFDaEIsS0FBSyxFQUFFLHNCQUFzQjtvQkFDN0IsV0FBVyxFQUFFLHNCQUFzQixPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsNkRBQTZEO29CQUN2SCxtQkFBbUIsRUFBRSxFQUFFO29CQUN2QixVQUFVLEVBQUUsUUFBUTtvQkFDcEIsWUFBWSxFQUFFLEtBQUs7b0JBQ25CLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtpQkFDdEIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztZQUVELHlCQUF5QjtZQUN6QixJQUFJLE9BQU8sQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsRUFBRSxFQUFFLENBQUM7Z0JBQ2hELGVBQWUsQ0FBQyxJQUFJLENBQUM7b0JBQ25CLEVBQUUsRUFBRSxvQkFBb0IsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO29CQUNwQyxJQUFJLEVBQUUsUUFBUTtvQkFDZCxRQUFRLEVBQUUsTUFBTTtvQkFDaEIsS0FBSyxFQUFFLHlCQUF5QjtvQkFDaEMsV0FBVyxFQUFFLHlCQUF5QixPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcseURBQXlEO29CQUN0SCxtQkFBbUIsRUFBRSxFQUFFO29CQUN2QixVQUFVLEVBQUUsTUFBTTtvQkFDbEIsWUFBWSxFQUFFLEtBQUs7b0JBQ25CLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtpQkFDdEIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztZQUVELDBCQUEwQjtZQUMxQixJQUFJLE9BQU8sQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsRUFBRSxFQUFFLENBQUM7Z0JBQ2hELGVBQWUsQ0FBQyxJQUFJLENBQUM7b0JBQ25CLEVBQUUsRUFBRSxxQkFBcUIsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO29CQUNyQyxJQUFJLEVBQUUsU0FBUztvQkFDZixRQUFRLEVBQUUsVUFBVTtvQkFDcEIsS0FBSyxFQUFFLHNCQUFzQjtvQkFDN0IsV0FBVyxFQUFFLHNCQUFzQixPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsMkNBQTJDO29CQUNyRyxtQkFBbUIsRUFBRSxFQUFFO29CQUN2QixVQUFVLEVBQUUsUUFBUTtvQkFDcEIsWUFBWSxFQUFFLElBQUk7b0JBQ2xCLGNBQWMsRUFBRSwwQkFBMEI7b0JBQzFDLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtpQkFDdEIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztZQUVELDhCQUE4QjtZQUM5QixJQUFJLGlCQUFpQixJQUFJLGlCQUFpQixDQUFDLFlBQVksR0FBRyxFQUFFLEVBQUUsQ0FBQztnQkFDN0QsZUFBZSxDQUFDLElBQUksQ0FBQztvQkFDbkIsRUFBRSxFQUFFLGtCQUFrQixJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUU7b0JBQ2xDLElBQUksRUFBRSxLQUFLO29CQUNYLFFBQVEsRUFBRSxRQUFRO29CQUNsQixLQUFLLEVBQUUsdUJBQXVCO29CQUM5QixXQUFXLEVBQUUsZ0NBQWdDLGlCQUFpQixDQUFDLFlBQVkscUNBQXFDO29CQUNoSCxtQkFBbUIsRUFBRSxFQUFFO29CQUN2QixVQUFVLEVBQUUsUUFBUTtvQkFDcEIsWUFBWSxFQUFFLElBQUk7b0JBQ2xCLGNBQWMsRUFBRSx1QkFBdUI7b0JBQ3ZDLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtpQkFDdEIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztZQUVELE9BQU8sZUFBZSxDQUFDO1FBRXpCLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyxvREFBb0QsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMxRSxPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEtBQUssQ0FBQyxnQkFBZ0I7UUFDM0IsSUFBSSxDQUFDO1lBQ0gsTUFBTSxPQUFPLEdBQUcsTUFBTSxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDMUMsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7WUFDdEMsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQztZQUNwRCxNQUFNLFlBQVksR0FBRyxXQUFXLElBQUksV0FBVyxDQUFDO1lBRWhELE1BQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztZQUM1QixNQUFNLGVBQWUsR0FBYSxFQUFFLENBQUM7WUFFckMsSUFBSSxXQUFXLEdBQUcsRUFBRSxFQUFFLENBQUM7Z0JBQ3JCLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0RBQWtELENBQUMsQ0FBQztnQkFDaEUsZUFBZSxDQUFDLElBQUksQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO2dCQUM3RCxlQUFlLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDN0MsQ0FBQztpQkFBTSxJQUFJLFdBQVcsR0FBRyxFQUFFLEVBQUUsQ0FBQztnQkFDNUIsTUFBTSxDQUFDLElBQUksQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO2dCQUN0RCxlQUFlLENBQUMsSUFBSSxDQUFDLGlDQUFpQyxDQUFDLENBQUM7WUFDMUQsQ0FBQztZQUVELE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFFaEYsT0FBTztnQkFDTCxXQUFXO2dCQUNYLFdBQVc7Z0JBQ1gsWUFBWTtnQkFDWixvQkFBb0IsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDO2dCQUN0RCxNQUFNO2dCQUNOLGVBQWU7YUFDaEIsQ0FBQztRQUVKLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsZUFBTSxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUN2RCxNQUFNLEtBQUssQ0FBQztRQUNkLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLHFCQUFxQjtRQUMxQixPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLDRCQUE0QjtRQUNqQyxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQztJQUM3RSxDQUFDO0lBRUQ7O09BRUc7SUFDSSwyQkFBMkI7UUFDaEMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUM5QixhQUFhLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQztZQUNqQyxlQUFNLENBQUMsSUFBSSxDQUFDLHFDQUFxQyxDQUFDLENBQUM7UUFDckQsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksU0FBUztRQU9kLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO1FBRTFELE9BQU87WUFDTCxZQUFZLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixLQUFLLElBQUk7WUFDaEQsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLGtCQUFrQixFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNO1lBQ2xELFdBQVcsRUFBRSxhQUFhLEVBQUUsWUFBWSxJQUFJLElBQUk7WUFDaEQsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUU7U0FDdEIsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXAxQkQsb0RBbzFCQztBQUVELGdGQUFnRjtBQUNoRixpQ0FBaUM7QUFDakMsZ0ZBQWdGO0FBQ2hGLHFFQUFxRTtBQUNyRSwyREFBMkQ7QUFDM0QsaUVBQWlFO0FBQ2pFLHFEQUFxRDtBQUNyRCwrREFBK0Q7QUFDL0Qsc0RBQXNEO0FBQ3RELGtFQUFrRTtBQUNsRSw0REFBNEQ7QUFDNUQsZ0ZBQWdGIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTmlja1xcRGVza3RvcFxcU21vb3RoU2FpbFxcc3JjXFxpbmZyYXN0cnVjdHVyZVxccGVyZm9ybWFuY2Utb3B0aW1pemVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBBSSBDUllQVE8gVFJBRElORyBBR0VOVCAtIFNZU1RFTSBQRVJGT1JNQU5DRSBPUFRJTUlaRVJcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogXHJcbiAqIFRoaXMgc2VydmljZSBwcm92aWRlcyBjb21wcmVoZW5zaXZlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBmb3IgSW50ZWwgTlVDXHJcbiAqIHN5c3RlbXMgcnVubmluZyB0aGUgQUkgY3J5cHRvIHRyYWRpbmcgYWdlbnQuIEl0IGltcGxlbWVudHMgbG93LWxhdGVuY3lcclxuICogdHJhZGluZyBvcHRpbWl6YXRpb25zLCB0aGVybWFsIG1hbmFnZW1lbnQsIGFuZCByZXNvdXJjZSBhbGxvY2F0aW9uLlxyXG4gKiBcclxuICogQ1JJVElDQUwgUEVSRk9STUFOQ0UgTk9USUNFOlxyXG4gKiBUaGlzIHN5c3RlbSBvcHRpbWl6ZXMgaGFyZHdhcmUgcGVyZm9ybWFuY2UgZm9yIHRyYWRpbmcgb3BlcmF0aW9ucy4gUG9vclxyXG4gKiBwZXJmb3JtYW5jZSBjb3VsZCBpbXBhY3QgdHJhZGluZyBkZWNpc2lvbnMgYW5kIHJlc3VsdCBpbiBmaW5hbmNpYWwgbG9zc2VzLlxyXG4gKiBBbGwgb3B0aW1pemF0aW9ucyBhcmUgY29udGludW91c2x5IG1vbml0b3JlZCBhbmQgYWRqdXN0ZWQuXHJcbiAqIFxyXG4gKiBIYXJkd2FyZSBTcGVjaWZpY2F0aW9uczpcclxuICogLSBJbnRlbCBOVUMgd2l0aCBpNSBDUFVcclxuICogLSAxMkdCIFJBTVxyXG4gKiAtIDI1NkdCIE0uMiBTU0RcclxuICogLSBXaXJlbGVzcyBhbmQgR2lnYWJpdCBFdGhlcm5ldFxyXG4gKiBcclxuICogQGF1dGhvciBBSSBDcnlwdG8gVHJhZGluZyBTeXN0ZW1cclxuICogQHZlcnNpb24gMS4wLjBcclxuICogQGxpY2Vuc2UgUFJPUFJJRVRBUllcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBzaSBmcm9tICdzeXN0ZW1pbmZvcm1hdGlvbic7XHJcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ0AvY29yZS9sb2dnaW5nL2xvZ2dlcic7XHJcbmltcG9ydCB7IGF1ZGl0U2VydmljZSB9IGZyb20gJ0Avc2VjdXJpdHkvYXVkaXQtc2VydmljZSc7XHJcbmltcG9ydCB7IFN5c3RlbU1vbml0b3IsIENQVU1ldHJpY3MsIFJBTU1ldHJpY3MsIFNTRE1ldHJpY3MgfSBmcm9tICcuL3N5c3RlbS1tb25pdG9yJztcclxuXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBjb25maWd1cmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBlcmZvcm1hbmNlQ29uZmlnIHtcclxuICAvKiogRW5hYmxlIENQVSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gKi9cclxuICBlbmFibGVDUFVPcHRpbWl6YXRpb246IGJvb2xlYW47XHJcbiAgLyoqIEVuYWJsZSBtZW1vcnkgb3B0aW1pemF0aW9uICovXHJcbiAgZW5hYmxlTWVtb3J5T3B0aW1pemF0aW9uOiBib29sZWFuO1xyXG4gIC8qKiBFbmFibGUgSS9PIG9wdGltaXphdGlvbiAqL1xyXG4gIGVuYWJsZUlPT3B0aW1pemF0aW9uOiBib29sZWFuO1xyXG4gIC8qKiBFbmFibGUgbmV0d29yayBvcHRpbWl6YXRpb24gKi9cclxuICBlbmFibGVOZXR3b3JrT3B0aW1pemF0aW9uOiBib29sZWFuO1xyXG4gIC8qKiBFbmFibGUgdGhlcm1hbCBtYW5hZ2VtZW50ICovXHJcbiAgZW5hYmxlVGhlcm1hbE1hbmFnZW1lbnQ6IGJvb2xlYW47XHJcbiAgLyoqIENQVSBnb3Zlcm5vciBtb2RlICovXHJcbiAgY3B1R292ZXJub3I6ICdwZXJmb3JtYW5jZScgfCAncG93ZXJzYXZlJyB8ICdvbmRlbWFuZCcgfCAnY29uc2VydmF0aXZlJztcclxuICAvKiogTWVtb3J5IHN3YXBwaW5lc3MgKDAtMTAwKSAqL1xyXG4gIG1lbW9yeVN3YXBwaW5lc3M6IG51bWJlcjtcclxuICAvKiogSS9PIHNjaGVkdWxlciAqL1xyXG4gIGlvU2NoZWR1bGVyOiAnbm9vcCcgfCAnZGVhZGxpbmUnIHwgJ2NmcScgfCAnbXEtZGVhZGxpbmUnO1xyXG4gIC8qKiBOZXR3b3JrIGJ1ZmZlciBzaXplcyAqL1xyXG4gIG5ldHdvcmtCdWZmZXJTaXplOiBudW1iZXI7XHJcbiAgLyoqIFRoZXJtYWwgdGhyb3R0bGluZyB0aHJlc2hvbGQgKi9cclxuICB0aGVybWFsVGhyb3R0bGVUZW1wOiBudW1iZXI7XHJcbiAgLyoqIFBlcmZvcm1hbmNlIG1vbml0b3JpbmcgaW50ZXJ2YWwgKi9cclxuICBtb25pdG9yaW5nSW50ZXJ2YWxNczogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJmYWNlIGZvciBwZXJmb3JtYW5jZSBtZXRyaWNzXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFBlcmZvcm1hbmNlTWV0cmljcyB7XHJcbiAgLyoqIE92ZXJhbGwgcGVyZm9ybWFuY2Ugc2NvcmUgKDAtMTAwKSAqL1xyXG4gIG92ZXJhbGxTY29yZTogbnVtYmVyO1xyXG4gIC8qKiBDUFUgcGVyZm9ybWFuY2Ugc2NvcmUgKi9cclxuICBjcHVTY29yZTogbnVtYmVyO1xyXG4gIC8qKiBNZW1vcnkgcGVyZm9ybWFuY2Ugc2NvcmUgKi9cclxuICBtZW1vcnlTY29yZTogbnVtYmVyO1xyXG4gIC8qKiBJL08gcGVyZm9ybWFuY2Ugc2NvcmUgKi9cclxuICBpb1Njb3JlOiBudW1iZXI7XHJcbiAgLyoqIE5ldHdvcmsgcGVyZm9ybWFuY2Ugc2NvcmUgKi9cclxuICBuZXR3b3JrU2NvcmU6IG51bWJlcjtcclxuICAvKiogVGhlcm1hbCBwZXJmb3JtYW5jZSBzY29yZSAqL1xyXG4gIHRoZXJtYWxTY29yZTogbnVtYmVyO1xyXG4gIC8qKiBMYXRlbmN5IG1ldHJpY3MgKi9cclxuICBsYXRlbmN5OiB7XHJcbiAgICAvKiogQXZlcmFnZSBzeXN0ZW0gbGF0ZW5jeSBpbiBtaWNyb3NlY29uZHMgKi9cclxuICAgIGF2ZXJhZ2U6IG51bWJlcjtcclxuICAgIC8qKiBNYXhpbXVtIHN5c3RlbSBsYXRlbmN5IGluIG1pY3Jvc2Vjb25kcyAqL1xyXG4gICAgbWF4aW11bTogbnVtYmVyO1xyXG4gICAgLyoqIDk1dGggcGVyY2VudGlsZSBsYXRlbmN5ICovXHJcbiAgICBwOTU6IG51bWJlcjtcclxuICAgIC8qKiA5OXRoIHBlcmNlbnRpbGUgbGF0ZW5jeSAqL1xyXG4gICAgcDk5OiBudW1iZXI7XHJcbiAgfTtcclxuICAvKiogVGhyb3VnaHB1dCBtZXRyaWNzICovXHJcbiAgdGhyb3VnaHB1dDoge1xyXG4gICAgLyoqIENQVSBvcGVyYXRpb25zIHBlciBzZWNvbmQgKi9cclxuICAgIGNwdU9wczogbnVtYmVyO1xyXG4gICAgLyoqIE1lbW9yeSBiYW5kd2lkdGggaW4gTUIvcyAqL1xyXG4gICAgbWVtb3J5QmFuZHdpZHRoOiBudW1iZXI7XHJcbiAgICAvKiogRGlzayBJL08gb3BlcmF0aW9ucyBwZXIgc2Vjb25kICovXHJcbiAgICBkaXNrSU9QUzogbnVtYmVyO1xyXG4gICAgLyoqIE5ldHdvcmsgdGhyb3VnaHB1dCBpbiBNYnBzICovXHJcbiAgICBuZXR3b3JrVGhyb3VnaHB1dDogbnVtYmVyO1xyXG4gIH07XHJcbiAgLyoqIExhc3QgbWVhc3VyZW1lbnQgdGltZXN0YW1wICovXHJcbiAgdGltZXN0YW1wOiBEYXRlO1xyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJmYWNlIGZvciBvcHRpbWl6YXRpb24gcmVjb21tZW5kYXRpb25cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb24ge1xyXG4gIC8qKiBSZWNvbW1lbmRhdGlvbiBJRCAqL1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgLyoqIFJlY29tbWVuZGF0aW9uIHR5cGUgKi9cclxuICB0eXBlOiAnQ1BVJyB8ICdNRU1PUlknIHwgJ0lPJyB8ICdORVRXT1JLJyB8ICdUSEVSTUFMJztcclxuICAvKiogUHJpb3JpdHkgbGV2ZWwgKi9cclxuICBwcmlvcml0eTogJ0xPVycgfCAnTUVESVVNJyB8ICdISUdIJyB8ICdDUklUSUNBTCc7XHJcbiAgLyoqIFJlY29tbWVuZGF0aW9uIHRpdGxlICovXHJcbiAgdGl0bGU6IHN0cmluZztcclxuICAvKiogRGV0YWlsZWQgZGVzY3JpcHRpb24gKi9cclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIC8qKiBFeHBlY3RlZCBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudCAqL1xyXG4gIGV4cGVjdGVkSW1wcm92ZW1lbnQ6IG51bWJlcjtcclxuICAvKiogSW1wbGVtZW50YXRpb24gY29tcGxleGl0eSAqL1xyXG4gIGNvbXBsZXhpdHk6ICdFQVNZJyB8ICdNRURJVU0nIHwgJ0hBUkQnO1xyXG4gIC8qKiBBdXRvLWFwcGx5IGNhcGFiaWxpdHkgKi9cclxuICBjYW5BdXRvQXBwbHk6IGJvb2xlYW47XHJcbiAgLyoqIEltcGxlbWVudGF0aW9uIGNvbW1hbmQvYWN0aW9uICovXHJcbiAgaW1wbGVtZW50YXRpb24/OiBzdHJpbmc7XHJcbiAgLyoqIFRpbWVzdGFtcCAqL1xyXG4gIHRpbWVzdGFtcDogRGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVyZmFjZSBmb3IgdGhlcm1hbCBtYW5hZ2VtZW50IHN0YXR1c1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUaGVybWFsU3RhdHVzIHtcclxuICAvKiogQ3VycmVudCBDUFUgdGVtcGVyYXR1cmUgKi9cclxuICBjdXJyZW50VGVtcDogbnVtYmVyO1xyXG4gIC8qKiBNYXhpbXVtIHNhZmUgdGVtcGVyYXR1cmUgKi9cclxuICBtYXhTYWZlVGVtcDogbnVtYmVyO1xyXG4gIC8qKiBUaGVybWFsIHRocm90dGxpbmcgYWN0aXZlICovXHJcbiAgaXNUaHJvdHRsaW5nOiBib29sZWFuO1xyXG4gIC8qKiBDb29saW5nIGVmZmVjdGl2ZW5lc3MgKDAtMTAwKSAqL1xyXG4gIGNvb2xpbmdFZmZlY3RpdmVuZXNzOiBudW1iZXI7XHJcbiAgLyoqIFRoZXJtYWwgYWxlcnRzICovXHJcbiAgYWxlcnRzOiBzdHJpbmdbXTtcclxuICAvKiogUmVjb21tZW5kZWQgYWN0aW9ucyAqL1xyXG4gIHJlY29tbWVuZGF0aW9uczogc3RyaW5nW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTeXN0ZW0gUGVyZm9ybWFuY2UgT3B0aW1pemVyXHJcbiAqIFByb3ZpZGVzIGNvbXByZWhlbnNpdmUgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGZvciB0cmFkaW5nIG9wZXJhdGlvbnNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZU9wdGltaXplciB7XHJcbiAgcHJpdmF0ZSBzeXN0ZW1Nb25pdG9yOiBTeXN0ZW1Nb25pdG9yO1xyXG4gIHByaXZhdGUgY29uZmlnOiBQZXJmb3JtYW5jZUNvbmZpZztcclxuICBwcml2YXRlIG9wdGltaXphdGlvbkludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgcGVyZm9ybWFuY2VIaXN0b3J5OiBQZXJmb3JtYW5jZU1ldHJpY3NbXSA9IFtdO1xyXG4gIHByaXZhdGUgbGF0ZW5jeU1lYXN1cmVtZW50czogbnVtYmVyW10gPSBbXTtcclxuICBwcml2YXRlIGlzT3B0aW1pemluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihzeXN0ZW1Nb25pdG9yOiBTeXN0ZW1Nb25pdG9yKSB7XHJcbiAgICB0aGlzLnN5c3RlbU1vbml0b3IgPSBzeXN0ZW1Nb25pdG9yO1xyXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLmxvYWRDb25maWd1cmF0aW9uKCk7XHJcbiAgICBsb2dnZXIuaW5mbygn4pqhIFBlcmZvcm1hbmNlIE9wdGltaXplciBpbml0aWFsaXppbmcuLi4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGNvbmZpZ3VyYXRpb25cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQZXJmb3JtYW5jZUNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdFxyXG4gICAqL1xyXG4gIHByaXZhdGUgbG9hZENvbmZpZ3VyYXRpb24oKTogUGVyZm9ybWFuY2VDb25maWcge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZW5hYmxlQ1BVT3B0aW1pemF0aW9uOiBwcm9jZXNzLmVudi5FTkFCTEVfQ1BVX09QVElNSVpBVElPTiA9PT0gJ3RydWUnLFxyXG4gICAgICBlbmFibGVNZW1vcnlPcHRpbWl6YXRpb246IHByb2Nlc3MuZW52LkVOQUJMRV9NRU1PUllfT1BUSU1JWkFUSU9OID09PSAndHJ1ZScsXHJcbiAgICAgIGVuYWJsZUlPT3B0aW1pemF0aW9uOiBwcm9jZXNzLmVudi5FTkFCTEVfSU9fT1BUSU1JWkFUSU9OID09PSAndHJ1ZScsXHJcbiAgICAgIGVuYWJsZU5ldHdvcmtPcHRpbWl6YXRpb246IHByb2Nlc3MuZW52LkVOQUJMRV9ORVRXT1JLX09QVElNSVpBVElPTiA9PT0gJ3RydWUnLFxyXG4gICAgICBlbmFibGVUaGVybWFsTWFuYWdlbWVudDogcHJvY2Vzcy5lbnYuRU5BQkxFX1RIRVJNQUxfTUFOQUdFTUVOVCAhPT0gJ2ZhbHNlJyxcclxuICAgICAgY3B1R292ZXJub3I6IChwcm9jZXNzLmVudi5DUFVfR09WRVJOT1IgYXMgYW55KSB8fCAncGVyZm9ybWFuY2UnLFxyXG4gICAgICBtZW1vcnlTd2FwcGluZXNzOiBwYXJzZUludChwcm9jZXNzLmVudi5NRU1PUllfU1dBUFBJTkVTUyB8fCAnMTAnKSxcclxuICAgICAgaW9TY2hlZHVsZXI6IChwcm9jZXNzLmVudi5JT19TQ0hFRFVMRVIgYXMgYW55KSB8fCAnbXEtZGVhZGxpbmUnLFxyXG4gICAgICBuZXR3b3JrQnVmZmVyU2l6ZTogcGFyc2VJbnQocHJvY2Vzcy5lbnYuTkVUV09SS19CVUZGRVJfU0laRSB8fCAnMTY3NzcyMTYnKSxcclxuICAgICAgdGhlcm1hbFRocm90dGxlVGVtcDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuVEhFUk1BTF9USFJPVFRMRV9URU1QIHx8ICc3NScpLFxyXG4gICAgICBtb25pdG9yaW5nSW50ZXJ2YWxNczogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUEVSRl9NT05JVE9SSU5HX0lOVEVSVkFMX01TIHx8ICc2MDAwMCcpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cclxuICAgKiBTZXRzIHVwIGFsbCBvcHRpbWl6YXRpb24gc3lzdGVtcyBhbmQgc3RhcnRzIG1vbml0b3JpbmdcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHVibGljIGFzeW5jIGluaXRpYWxpemVQZXJmb3JtYW5jZU9wdGltaXphdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxvZ2dlci5pbmZvKCfimqEgSW5pdGlhbGl6aW5nIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi4uLicpO1xyXG5cclxuICAgICAgLy8gQXBwbHkgaW5pdGlhbCBvcHRpbWl6YXRpb25zXHJcbiAgICAgIGF3YWl0IHRoaXMuYXBwbHlJbml0aWFsT3B0aW1pemF0aW9ucygpO1xyXG5cclxuICAgICAgLy8gU3RhcnQgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xyXG4gICAgICBhd2FpdCB0aGlzLnN0YXJ0UGVyZm9ybWFuY2VNb25pdG9yaW5nKCk7XHJcblxyXG4gICAgICAvLyBTZXQgdXAgdGhlcm1hbCBtYW5hZ2VtZW50XHJcbiAgICAgIGF3YWl0IHRoaXMuc2V0dXBUaGVybWFsTWFuYWdlbWVudCgpO1xyXG5cclxuICAgICAgbG9nZ2VyLmluZm8oJ+KchSBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcblxyXG4gICAgICAvLyBBdWRpdCBsb2dcclxuICAgICAgYXdhaXQgYXVkaXRTZXJ2aWNlLmNyZWF0ZUF1ZGl0RW50cnkoe1xyXG4gICAgICAgIGF1ZGl0SWQ6IGBwZXJmX29wdF9pbml0XyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgIGV2ZW50VHlwZTogJ1BFUkZPUk1BTkNFX09QVElNSVpBVElPTl9JTklUJyxcclxuICAgICAgICBhY3RvcjogJ1NZU1RFTScsXHJcbiAgICAgICAgcmVzb3VyY2U6ICdQRVJGT1JNQU5DRV9PUFRJTUlaRVInLFxyXG4gICAgICAgIGFjdGlvbjogJ0lOSVRJQUxJWkUnLFxyXG4gICAgICAgIHJlc3VsdDogJ1NVQ0NFU1MnLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICBhdWRpdERhdGE6IHsgY29uZmlnOiB0aGlzLmNvbmZpZyB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIGluaXRpYWxpemF0aW9uIGZhaWxlZCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbHkgaW5pdGlhbCBzeXN0ZW0gb3B0aW1pemF0aW9uc1xyXG4gICAqIENvbmZpZ3VyZXMgc3lzdGVtIGZvciBvcHRpbWFsIHRyYWRpbmcgcGVyZm9ybWFuY2VcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBhcHBseUluaXRpYWxPcHRpbWl6YXRpb25zKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9nZ2VyLmluZm8oJ/CflKcgQXBwbHlpbmcgaW5pdGlhbCBzeXN0ZW0gb3B0aW1pemF0aW9ucy4uLicpO1xyXG5cclxuICAgICAgY29uc3Qgb3B0aW1pemF0aW9uczogUHJvbWlzZTx2b2lkPltdID0gW107XHJcblxyXG4gICAgICAvLyBDUFUgb3B0aW1pemF0aW9uc1xyXG4gICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ1BVT3B0aW1pemF0aW9uKSB7XHJcbiAgICAgICAgb3B0aW1pemF0aW9ucy5wdXNoKHRoaXMub3B0aW1pemVDUFVQZXJmb3JtYW5jZSgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTWVtb3J5IG9wdGltaXphdGlvbnNcclxuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZU1lbW9yeU9wdGltaXphdGlvbikge1xyXG4gICAgICAgIG9wdGltaXphdGlvbnMucHVzaCh0aGlzLm9wdGltaXplTWVtb3J5UGVyZm9ybWFuY2UoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEkvTyBvcHRpbWl6YXRpb25zXHJcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVJT09wdGltaXphdGlvbikge1xyXG4gICAgICAgIG9wdGltaXphdGlvbnMucHVzaCh0aGlzLm9wdGltaXplSU9QZXJmb3JtYW5jZSgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTmV0d29yayBvcHRpbWl6YXRpb25zXHJcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVOZXR3b3JrT3B0aW1pemF0aW9uKSB7XHJcbiAgICAgICAgb3B0aW1pemF0aW9ucy5wdXNoKHRoaXMub3B0aW1pemVOZXR3b3JrUGVyZm9ybWFuY2UoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFwcGx5IGFsbCBvcHRpbWl6YXRpb25zIGNvbmN1cnJlbnRseVxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChvcHRpbWl6YXRpb25zKTtcclxuXHJcbiAgICAgIGxvZ2dlci5pbmZvKCfinIUgSW5pdGlhbCBvcHRpbWl6YXRpb25zIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKCfinYwgRmFpbGVkIHRvIGFwcGx5IGluaXRpYWwgb3B0aW1pemF0aW9uczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3B0aW1pemUgQ1BVIHBlcmZvcm1hbmNlIGZvciBsb3ctbGF0ZW5jeSB0cmFkaW5nXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgb3B0aW1pemVDUFVQZXJmb3JtYW5jZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxvZ2dlci5pbmZvKCfwn5SnIE9wdGltaXppbmcgQ1BVIHBlcmZvcm1hbmNlLi4uJyk7XHJcblxyXG4gICAgICAvLyBTZXQgQ1BVIGdvdmVybm9yIHRvIHBlcmZvcm1hbmNlIG1vZGVcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgICBleGVjU3luYyhgZWNobyAke3RoaXMuY29uZmlnLmNwdUdvdmVybm9yfSB8IHN1ZG8gdGVlIC9zeXMvZGV2aWNlcy9zeXN0ZW0vY3B1L2NwdSovY3B1ZnJlcS9zY2FsaW5nX2dvdmVybm9yYCwgXHJcbiAgICAgICAgICB7IHN0ZGlvOiAncGlwZScgfSk7XHJcbiAgICAgICAgbG9nZ2VyLmluZm8oYOKchSBDUFUgZ292ZXJub3Igc2V0IHRvOiAke3RoaXMuY29uZmlnLmNwdUdvdmVybm9yfWApO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxvZ2dlci53YXJuKCfimqDvuI8gQ291bGQgbm90IHNldCBDUFUgZ292ZXJub3IgKG1heSByZXF1aXJlIHN1ZG8pOicsIGVycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGlzYWJsZSBDUFUgaWRsZSBzdGF0ZXMgZm9yIGNvbnNpc3RlbnQgcGVyZm9ybWFuY2VcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgICBleGVjU3luYygnc3VkbyBjcHVwb3dlciBpZGxlLXNldCAtRCAwJywgeyBzdGRpbzogJ3BpcGUnIH0pO1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKCfinIUgQ1BVIGlkbGUgc3RhdGVzIG9wdGltaXplZCcpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxvZ2dlci53YXJuKCfimqDvuI8gQ291bGQgbm90IG9wdGltaXplIENQVSBpZGxlIHN0YXRlczonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCBDUFUgYWZmaW5pdHkgZm9yIHRyYWRpbmcgcHJvY2Vzc2VzXHJcbiAgICAgIGF3YWl0IHRoaXMuc2V0Q1BVQWZmaW5pdHkoKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBDUFUgb3B0aW1pemF0aW9uIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgQ1BVIGFmZmluaXR5IGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgc2V0Q1BVQWZmaW5pdHkoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjcHVJbmZvID0gYXdhaXQgc2kuY3B1KCk7XHJcbiAgICAgIGNvbnN0IGNvcmVDb3VudCA9IGNwdUluZm8uY29yZXM7XHJcblxyXG4gICAgICBpZiAoY29yZUNvdW50ID49IDQpIHtcclxuICAgICAgICAvLyBSZXNlcnZlIGNvcmVzIDAtMSBmb3IgdHJhZGluZyBvcGVyYXRpb25zLCAyLTMgZm9yIHN5c3RlbVxyXG4gICAgICAgIHByb2Nlc3MuZW52LlRSQURJTkdfQ1BVX0NPUkVTID0gJzAsMSc7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuU1lTVEVNX0NQVV9DT1JFUyA9ICcyLDMnO1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKCfinIUgQ1BVIGFmZmluaXR5IGNvbmZpZ3VyZWQgZm9yIHRyYWRpbmcgb3B0aW1pemF0aW9uJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIud2Fybign4pqg77iPIENvdWxkIG5vdCBzZXQgQ1BVIGFmZmluaXR5OicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wdGltaXplIG1lbW9yeSBwZXJmb3JtYW5jZVxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIG9wdGltaXplTWVtb3J5UGVyZm9ybWFuY2UoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBsb2dnZXIuaW5mbygn8J+UpyBPcHRpbWl6aW5nIG1lbW9yeSBwZXJmb3JtYW5jZS4uLicpO1xyXG5cclxuICAgICAgLy8gU2V0IG1lbW9yeSBzd2FwcGluZXNzIGZvciB0cmFkaW5nIHdvcmtsb2FkXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyBleGVjU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdjaGlsZF9wcm9jZXNzJyk7XHJcbiAgICAgICAgZXhlY1N5bmMoYGVjaG8gJHt0aGlzLmNvbmZpZy5tZW1vcnlTd2FwcGluZXNzfSB8IHN1ZG8gdGVlIC9wcm9jL3N5cy92bS9zd2FwcGluZXNzYCwgXHJcbiAgICAgICAgICB7IHN0ZGlvOiAncGlwZScgfSk7XHJcbiAgICAgICAgbG9nZ2VyLmluZm8oYOKchSBNZW1vcnkgc3dhcHBpbmVzcyBzZXQgdG86ICR7dGhpcy5jb25maWcubWVtb3J5U3dhcHBpbmVzc31gKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsb2dnZXIud2Fybign4pqg77iPIENvdWxkIG5vdCBzZXQgbWVtb3J5IHN3YXBwaW5lc3M6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPcHRpbWl6ZSBtZW1vcnkgYWxsb2NhdGlvblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZXhlY1N5bmMgfSA9IGF3YWl0IGltcG9ydCgnY2hpbGRfcHJvY2VzcycpO1xyXG4gICAgICAgIC8vIFJlZHVjZSBtZW1vcnkgb3ZlcmNvbW1pdCBmb3Igc3RhYmlsaXR5XHJcbiAgICAgICAgZXhlY1N5bmMoJ2VjaG8gMiB8IHN1ZG8gdGVlIC9wcm9jL3N5cy92bS9vdmVyY29tbWl0X21lbW9yeScsIHsgc3RkaW86ICdwaXBlJyB9KTtcclxuICAgICAgICAvLyBPcHRpbWl6ZSBkaXJ0eSBwYWdlIHdyaXRlYmFja1xyXG4gICAgICAgIGV4ZWNTeW5jKCdlY2hvIDUgfCBzdWRvIHRlZSAvcHJvYy9zeXMvdm0vZGlydHlfYmFja2dyb3VuZF9yYXRpbycsIHsgc3RkaW86ICdwaXBlJyB9KTtcclxuICAgICAgICBleGVjU3luYygnZWNobyAxMCB8IHN1ZG8gdGVlIC9wcm9jL3N5cy92bS9kaXJ0eV9yYXRpbycsIHsgc3RkaW86ICdwaXBlJyB9KTtcclxuICAgICAgICBsb2dnZXIuaW5mbygn4pyFIE1lbW9yeSBhbGxvY2F0aW9uIG9wdGltaXplZCcpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGxvZ2dlci53YXJuKCfimqDvuI8gQ291bGQgbm90IG9wdGltaXplIG1lbW9yeSBhbGxvY2F0aW9uOicsIGVycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29uZmlndXJlIE5vZGUuanMgbWVtb3J5IHNldHRpbmdzXHJcbiAgICAgIHRoaXMub3B0aW1pemVOb2RlSlNNZW1vcnkoKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBNZW1vcnkgb3B0aW1pemF0aW9uIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcHRpbWl6ZSBOb2RlLmpzIG1lbW9yeSBzZXR0aW5nc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgb3B0aW1pemVOb2RlSlNNZW1vcnkoKTogdm9pZCB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTZXQgb3B0aW1hbCBoZWFwIHNpemVzIGZvciB0cmFkaW5nIGFwcGxpY2F0aW9uXHJcbiAgICAgIGNvbnN0IHRvdGFsTWVtb3J5R0IgPSBNYXRoLmZsb29yKHJlcXVpcmUoJ29zJykudG90YWxtZW0oKSAvIDEwMjQgLyAxMDI0IC8gMTAyNCk7XHJcbiAgICAgIGNvbnN0IG1heEhlYXBTaXplID0gTWF0aC5mbG9vcih0b3RhbE1lbW9yeUdCICogMC42KTsgLy8gVXNlIDYwJSBvZiB0b3RhbCBtZW1vcnlcclxuXHJcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfT1BUSU9OUyA9IGAtLW1heC1vbGQtc3BhY2Utc2l6ZT0ke21heEhlYXBTaXplICogMTAyNH1gO1xyXG4gICAgICBcclxuICAgICAgLy8gRW5hYmxlIGdhcmJhZ2UgY29sbGVjdGlvbiBvcHRpbWl6YXRpb25zXHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TICs9ICcgLS1vcHRpbWl6ZS1mb3Itc2l6ZSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxvZ2dlci5pbmZvKGDinIUgTm9kZS5qcyBtZW1vcnkgb3B0aW1pemVkOiAke21heEhlYXBTaXplfUdCIGhlYXBgKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIud2Fybign4pqg77iPIENvdWxkIG5vdCBvcHRpbWl6ZSBOb2RlLmpzIG1lbW9yeTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcHRpbWl6ZSBJL08gcGVyZm9ybWFuY2VcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBvcHRpbWl6ZUlPUGVyZm9ybWFuY2UoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBsb2dnZXIuaW5mbygn8J+UpyBPcHRpbWl6aW5nIEkvTyBwZXJmb3JtYW5jZS4uLicpO1xyXG5cclxuICAgICAgLy8gU2V0IEkvTyBzY2hlZHVsZXIgZm9yIFNTRCBvcHRpbWl6YXRpb25cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgICBjb25zdCBibG9ja0RldmljZXMgPSBhd2FpdCBzaS5ibG9ja0RldmljZXMoKTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGNvbnN0IGRldmljZSBvZiBibG9ja0RldmljZXMpIHtcclxuICAgICAgICAgIGlmIChkZXZpY2UudHlwZSA9PT0gJ2Rpc2snICYmICFkZXZpY2UucmVtb3ZhYmxlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgZXhlY1N5bmMoYGVjaG8gJHt0aGlzLmNvbmZpZy5pb1NjaGVkdWxlcn0gfCBzdWRvIHRlZSAvc3lzL2Jsb2NrLyR7ZGV2aWNlLm5hbWV9L3F1ZXVlL3NjaGVkdWxlcmAsIFxyXG4gICAgICAgICAgICAgICAgeyBzdGRpbzogJ3BpcGUnIH0pO1xyXG4gICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGDinIUgSS9PIHNjaGVkdWxlciBzZXQgdG8gJHt0aGlzLmNvbmZpZy5pb1NjaGVkdWxlcn0gZm9yICR7ZGV2aWNlLm5hbWV9YCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYOKaoO+4jyBDb3VsZCBub3Qgc2V0IEkvTyBzY2hlZHVsZXIgZm9yICR7ZGV2aWNlLm5hbWV9OmAsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsb2dnZXIud2Fybign4pqg77iPIENvdWxkIG5vdCBvcHRpbWl6ZSBJL08gc2NoZWR1bGVyOicsIGVycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3B0aW1pemUgZmlsZSBzeXN0ZW0gcGFyYW1ldGVyc1xyXG4gICAgICBhd2FpdCB0aGlzLm9wdGltaXplRmlsZVN5c3RlbSgpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIEkvTyBvcHRpbWl6YXRpb24gZmFpbGVkOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wdGltaXplIGZpbGUgc3lzdGVtIHBhcmFtZXRlcnNcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBvcHRpbWl6ZUZpbGVTeXN0ZW0oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuXHJcbiAgICAgIC8vIE9wdGltaXplIHJlYWQtYWhlYWQgZm9yIHNlcXVlbnRpYWwgSS9PXHJcbiAgICAgIGV4ZWNTeW5jKCdzdWRvIGJsb2NrZGV2IC0tc2V0cmEgMjU2IC9kZXYvc2RhJywgeyBzdGRpbzogJ3BpcGUnIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gT3B0aW1pemUgZmlsZSBzeXN0ZW0gY2FjaGVcclxuICAgICAgZXhlY1N5bmMoJ2VjaG8gMSB8IHN1ZG8gdGVlIC9wcm9jL3N5cy92bS92ZnNfY2FjaGVfcHJlc3N1cmUnLCB7IHN0ZGlvOiAncGlwZScgfSk7XHJcbiAgICAgIFxyXG4gICAgICBsb2dnZXIuaW5mbygn4pyFIEZpbGUgc3lzdGVtIG9wdGltaXplZCcpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci53YXJuKCfimqDvuI8gQ291bGQgbm90IG9wdGltaXplIGZpbGUgc3lzdGVtOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wdGltaXplIG5ldHdvcmsgcGVyZm9ybWFuY2VcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBvcHRpbWl6ZU5ldHdvcmtQZXJmb3JtYW5jZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxvZ2dlci5pbmZvKCfwn5SnIE9wdGltaXppbmcgbmV0d29yayBwZXJmb3JtYW5jZS4uLicpO1xyXG5cclxuICAgICAgY29uc3QgeyBleGVjU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdjaGlsZF9wcm9jZXNzJyk7XHJcblxyXG4gICAgICAvLyBPcHRpbWl6ZSBUQ1Agc2V0dGluZ3MgZm9yIGxvdyBsYXRlbmN5XHJcbiAgICAgIGNvbnN0IHRjcE9wdGltaXphdGlvbnMgPSBbXHJcbiAgICAgICAgJ25ldC5jb3JlLnJtZW1fbWF4ID0gMTY3NzcyMTYnLFxyXG4gICAgICAgICduZXQuY29yZS53bWVtX21heCA9IDE2Nzc3MjE2JyxcclxuICAgICAgICAnbmV0LmlwdjQudGNwX3JtZW0gPSA0MDk2IDg3MzgwIDE2Nzc3MjE2JyxcclxuICAgICAgICAnbmV0LmlwdjQudGNwX3dtZW0gPSA0MDk2IDY1NTM2IDE2Nzc3MjE2JyxcclxuICAgICAgICAnbmV0LmlwdjQudGNwX2Nvbmdlc3Rpb25fY29udHJvbCA9IGJicicsXHJcbiAgICAgICAgJ25ldC5pcHY0LnRjcF9mYXN0b3BlbiA9IDMnLFxyXG4gICAgICAgICduZXQuaXB2NC50Y3BfbG93X2xhdGVuY3kgPSAxJyxcclxuICAgICAgICAnbmV0LmNvcmUubmV0ZGV2X21heF9iYWNrbG9nID0gNTAwMCdcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgb3B0aW1pemF0aW9uIG9mIHRjcE9wdGltaXphdGlvbnMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZXhlY1N5bmMoYGVjaG8gXCIke29wdGltaXphdGlvbn1cIiB8IHN1ZG8gdGVlIC1hIC9ldGMvc3lzY3RsLmNvbmZgLCB7IHN0ZGlvOiAncGlwZScgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGDimqDvuI8gQ291bGQgbm90IGFwcGx5IG5ldHdvcmsgb3B0aW1pemF0aW9uOiAke29wdGltaXphdGlvbn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFwcGx5IHN5c2N0bCBjaGFuZ2VzXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXhlY1N5bmMoJ3N1ZG8gc3lzY3RsIC1wJywgeyBzdGRpbzogJ3BpcGUnIH0pO1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKCfinIUgTmV0d29yayBwZXJmb3JtYW5jZSBvcHRpbWl6ZWQnKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsb2dnZXIud2Fybign4pqg77iPIENvdWxkIG5vdCBhcHBseSBzeXNjdGwgY2hhbmdlczonLCBlcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBOZXR3b3JrIG9wdGltaXphdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dXAgdGhlcm1hbCBtYW5hZ2VtZW50XHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyBzZXR1cFRoZXJtYWxNYW5hZ2VtZW50KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9nZ2VyLmluZm8oJ/CfjKHvuI8gU2V0dGluZyB1cCB0aGVybWFsIG1hbmFnZW1lbnQuLi4nKTtcclxuXHJcbiAgICAgIC8vIFN0YXJ0IHRoZXJtYWwgbW9uaXRvcmluZ1xyXG4gICAgICBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5tb25pdG9yVGhlcm1hbENvbmRpdGlvbnMoKTtcclxuICAgICAgfSwgMTAwMDApOyAvLyBDaGVjayBldmVyeSAxMCBzZWNvbmRzXHJcblxyXG4gICAgICBsb2dnZXIuaW5mbygn4pyFIFRoZXJtYWwgbWFuYWdlbWVudCBzZXR1cCBjb21wbGV0ZScpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIFRoZXJtYWwgbWFuYWdlbWVudCBzZXR1cCBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW9uaXRvciB0aGVybWFsIGNvbmRpdGlvbnMgYW5kIGFwcGx5IHRocm90dGxpbmcgaWYgbmVlZGVkXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgbW9uaXRvclRoZXJtYWxDb25kaXRpb25zKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY3B1VGVtcCA9IGF3YWl0IHNpLmNwdVRlbXBlcmF0dXJlKCk7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUZW1wID0gY3B1VGVtcC5tYWluIHx8IDA7XHJcblxyXG4gICAgICBpZiAoY3VycmVudFRlbXAgPj0gdGhpcy5jb25maWcudGhlcm1hbFRocm90dGxlVGVtcCkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuYXBwbHlUaGVybWFsVGhyb3R0bGluZyhjdXJyZW50VGVtcCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRlbXAgPCB0aGlzLmNvbmZpZy50aGVybWFsVGhyb3R0bGVUZW1wIC0gNSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aHJvdHRsaW5nIGlmIHRlbXBlcmF0dXJlIGlzIHNhZmVcclxuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZVRoZXJtYWxUaHJvdHRsaW5nKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBUaGVybWFsIG1vbml0b3JpbmcgZmFpbGVkOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGx5IHRoZXJtYWwgdGhyb3R0bGluZyB0byBwcmV2ZW50IG92ZXJoZWF0aW5nXHJcbiAgICogXHJcbiAgICogQHBhcmFtIGN1cnJlbnRUZW1wIEN1cnJlbnQgQ1BVIHRlbXBlcmF0dXJlXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgYXBwbHlUaGVybWFsVGhyb3R0bGluZyhjdXJyZW50VGVtcDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBsb2dnZXIud2Fybihg8J+Moe+4jyBBcHBseWluZyB0aGVybWFsIHRocm90dGxpbmcgLSBDUFUgdGVtcDogJHtjdXJyZW50VGVtcH3CsENgKTtcclxuXHJcbiAgICAgIC8vIFJlZHVjZSBDUFUgZnJlcXVlbmN5XHJcbiAgICAgIGNvbnN0IHsgZXhlY1N5bmMgfSA9IGF3YWl0IGltcG9ydCgnY2hpbGRfcHJvY2VzcycpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGV4ZWNTeW5jKCdlY2hvIHBvd2Vyc2F2ZSB8IHN1ZG8gdGVlIC9zeXMvZGV2aWNlcy9zeXN0ZW0vY3B1L2NwdSovY3B1ZnJlcS9zY2FsaW5nX2dvdmVybm9yJywgXHJcbiAgICAgICAgICB7IHN0ZGlvOiAncGlwZScgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oJ+KaoO+4jyBDb3VsZCBub3QgYXBwbHkgQ1BVIHRocm90dGxpbmc6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBdWRpdCBjcml0aWNhbCB0aGVybWFsIGV2ZW50XHJcbiAgICAgIGF3YWl0IGF1ZGl0U2VydmljZS5jcmVhdGVBdWRpdEVudHJ5KHtcclxuICAgICAgICBhdWRpdElkOiBgdGhlcm1hbF90aHJvdHRsZV8ke0RhdGUubm93KCl9YCxcclxuICAgICAgICBldmVudFR5cGU6ICdUSEVSTUFMX1RIUk9UVExJTkdfQVBQTElFRCcsXHJcbiAgICAgICAgYWN0b3I6ICdQRVJGT1JNQU5DRV9PUFRJTUlaRVInLFxyXG4gICAgICAgIHJlc291cmNlOiAnQ1BVX1RIRVJNQUwnLFxyXG4gICAgICAgIGFjdGlvbjogJ0FQUExZX1RIUk9UVExJTkcnLFxyXG4gICAgICAgIHJlc3VsdDogJ1NVQ0NFU1MnLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICBhdWRpdERhdGE6IHsgY3VycmVudFRlbXAsIHRocmVzaG9sZDogdGhpcy5jb25maWcudGhlcm1hbFRocm90dGxlVGVtcCB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIEZhaWxlZCB0byBhcHBseSB0aGVybWFsIHRocm90dGxpbmc6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZXJtYWwgdGhyb3R0bGluZyB3aGVuIHRlbXBlcmF0dXJlIGlzIHNhZmVcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyByZW1vdmVUaGVybWFsVGhyb3R0bGluZygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDUFVPcHRpbWl6YXRpb24pIHtcclxuICAgICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZXhlY1N5bmMoYGVjaG8gJHt0aGlzLmNvbmZpZy5jcHVHb3Zlcm5vcn0gfCBzdWRvIHRlZSAvc3lzL2RldmljZXMvc3lzdGVtL2NwdS9jcHUqL2NwdWZyZXEvc2NhbGluZ19nb3Zlcm5vcmAsIFxyXG4gICAgICAgICAgICB7IHN0ZGlvOiAncGlwZScgfSk7XHJcbiAgICAgICAgICBsb2dnZXIuaW5mbygn4pyFIFRoZXJtYWwgdGhyb3R0bGluZyByZW1vdmVkIC0gbm9ybWFsIHBlcmZvcm1hbmNlIHJlc3RvcmVkJyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKCfimqDvuI8gQ291bGQgbm90IHJlbW92ZSBDUFUgdGhyb3R0bGluZzonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKCfinYwgRmFpbGVkIHRvIHJlbW92ZSB0aGVybWFsIHRocm90dGxpbmc6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHN0YXJ0UGVyZm9ybWFuY2VNb25pdG9yaW5nKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9nZ2VyLmluZm8oJ/Cfk4ogU3RhcnRpbmcgcGVyZm9ybWFuY2UgbW9uaXRvcmluZy4uLicpO1xyXG5cclxuICAgICAgdGhpcy5vcHRpbWl6YXRpb25JbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5tZWFzdXJlUGVyZm9ybWFuY2UoKTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVPcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbnMoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCfinYwgUGVyZm9ybWFuY2UgbW9uaXRvcmluZyBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzLmNvbmZpZy5tb25pdG9yaW5nSW50ZXJ2YWxNcyk7XHJcblxyXG4gICAgICBsb2dnZXIuaW5mbygn4pyFIFBlcmZvcm1hbmNlIG1vbml0b3Jpbmcgc3RhcnRlZCcpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIEZhaWxlZCB0byBzdGFydCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lYXN1cmUgc3lzdGVtIHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPFBlcmZvcm1hbmNlTWV0cmljcz5cclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgbWVhc3VyZVBlcmZvcm1hbmNlKCk6IFByb21pc2U8UGVyZm9ybWFuY2VNZXRyaWNzPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCBjdXJyZW50IHN5c3RlbSBtZXRyaWNzXHJcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLnN5c3RlbU1vbml0b3IuZ2V0Q3VycmVudE1ldHJpY3MoKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENhbGN1bGF0ZSBwZXJmb3JtYW5jZSBzY29yZXNcclxuICAgICAgY29uc3QgY3B1U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUNQVVNjb3JlKG1ldHJpY3MuY3B1KTtcclxuICAgICAgY29uc3QgbWVtb3J5U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZU1lbW9yeVNjb3JlKG1ldHJpY3MucmFtKTtcclxuICAgICAgY29uc3QgaW9TY29yZSA9IHRoaXMuY2FsY3VsYXRlSU9TY29yZShtZXRyaWNzLnNzZCk7XHJcbiAgICAgIGNvbnN0IG5ldHdvcmtTY29yZSA9IHRoaXMuY2FsY3VsYXRlTmV0d29ya1Njb3JlKG1ldHJpY3MubmV0d29yayk7XHJcbiAgICAgIGNvbnN0IHRoZXJtYWxTY29yZSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlVGhlcm1hbFNjb3JlKCk7XHJcblxyXG4gICAgICAvLyBNZWFzdXJlIGxhdGVuY3lcclxuICAgICAgY29uc3QgbGF0ZW5jeSA9IGF3YWl0IHRoaXMubWVhc3VyZVN5c3RlbUxhdGVuY3koKTtcclxuICAgICAgdGhpcy5sYXRlbmN5TWVhc3VyZW1lbnRzLnB1c2gobGF0ZW5jeSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBLZWVwIG9ubHkgbGFzdCAxMDAwIG1lYXN1cmVtZW50c1xyXG4gICAgICBpZiAodGhpcy5sYXRlbmN5TWVhc3VyZW1lbnRzLmxlbmd0aCA+IDEwMDApIHtcclxuICAgICAgICB0aGlzLmxhdGVuY3lNZWFzdXJlbWVudHMgPSB0aGlzLmxhdGVuY3lNZWFzdXJlbWVudHMuc2xpY2UoLTEwMDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgbGF0ZW5jeSBzdGF0aXN0aWNzXHJcbiAgICAgIGNvbnN0IHNvcnRlZExhdGVuY2llcyA9IFsuLi50aGlzLmxhdGVuY3lNZWFzdXJlbWVudHNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgICAgY29uc3QgbGF0ZW5jeVN0YXRzID0ge1xyXG4gICAgICAgIGF2ZXJhZ2U6IHRoaXMubGF0ZW5jeU1lYXN1cmVtZW50cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHRoaXMubGF0ZW5jeU1lYXN1cmVtZW50cy5sZW5ndGgsXHJcbiAgICAgICAgbWF4aW11bTogTWF0aC5tYXgoLi4udGhpcy5sYXRlbmN5TWVhc3VyZW1lbnRzKSxcclxuICAgICAgICBwOTU6IHNvcnRlZExhdGVuY2llc1tNYXRoLmZsb29yKHNvcnRlZExhdGVuY2llcy5sZW5ndGggKiAwLjk1KV0gfHwgMCxcclxuICAgICAgICBwOTk6IHNvcnRlZExhdGVuY2llc1tNYXRoLmZsb29yKHNvcnRlZExhdGVuY2llcy5sZW5ndGggKiAwLjk5KV0gfHwgMFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRocm91Z2hwdXQgbWV0cmljc1xyXG4gICAgICBjb25zdCB0aHJvdWdocHV0ID0ge1xyXG4gICAgICAgIGNwdU9wczogdGhpcy5jYWxjdWxhdGVDUFVUaHJvdWdocHV0KG1ldHJpY3MuY3B1KSxcclxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6IHRoaXMuY2FsY3VsYXRlTWVtb3J5QmFuZHdpZHRoKG1ldHJpY3MucmFtKSxcclxuICAgICAgICBkaXNrSU9QUzogbWV0cmljcy5zc2Q/LnJlYWRJT1BTIHx8IDAgKyBtZXRyaWNzLnNzZD8ud3JpdGVJT1BTIHx8IDAsXHJcbiAgICAgICAgbmV0d29ya1Rocm91Z2hwdXQ6IChtZXRyaWNzLm5ldHdvcms/LmRvd25sb2FkU3BlZWQgfHwgMCkgKyAobWV0cmljcy5uZXR3b3JrPy51cGxvYWRTcGVlZCB8fCAwKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3Qgb3ZlcmFsbFNjb3JlID0gTWF0aC5yb3VuZCgoY3B1U2NvcmUgKyBtZW1vcnlTY29yZSArIGlvU2NvcmUgKyBuZXR3b3JrU2NvcmUgKyB0aGVybWFsU2NvcmUpIC8gNSk7XHJcblxyXG4gICAgICBjb25zdCBwZXJmb3JtYW5jZU1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljcyA9IHtcclxuICAgICAgICBvdmVyYWxsU2NvcmUsXHJcbiAgICAgICAgY3B1U2NvcmUsXHJcbiAgICAgICAgbWVtb3J5U2NvcmUsXHJcbiAgICAgICAgaW9TY29yZSxcclxuICAgICAgICBuZXR3b3JrU2NvcmUsXHJcbiAgICAgICAgdGhlcm1hbFNjb3JlLFxyXG4gICAgICAgIGxhdGVuY3k6IGxhdGVuY3lTdGF0cyxcclxuICAgICAgICB0aHJvdWdocHV0LFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gU3RvcmUgaW4gaGlzdG9yeVxyXG4gICAgICB0aGlzLnBlcmZvcm1hbmNlSGlzdG9yeS5wdXNoKHBlcmZvcm1hbmNlTWV0cmljcyk7XHJcbiAgICAgIGlmICh0aGlzLnBlcmZvcm1hbmNlSGlzdG9yeS5sZW5ndGggPiAxMDApIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1hbmNlSGlzdG9yeSA9IHRoaXMucGVyZm9ybWFuY2VIaXN0b3J5LnNsaWNlKC0xMDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBlbmRUaW1lID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XHJcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50VGltZSA9IE51bWJlcihlbmRUaW1lIC0gc3RhcnRUaW1lKSAvIDEwMDAwMDA7IC8vIENvbnZlcnQgdG8gbWlsbGlzZWNvbmRzXHJcblxyXG4gICAgICBsb2dnZXIuZGVidWcoJ/Cfk4ogUGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29tcGxldGVkJywge1xyXG4gICAgICAgIG92ZXJhbGxTY29yZSxcclxuICAgICAgICBtZWFzdXJlbWVudFRpbWU6IGAke21lYXN1cmVtZW50VGltZS50b0ZpeGVkKDIpfW1zYCxcclxuICAgICAgICBsYXRlbmN5OiBsYXRlbmN5U3RhdHNcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2VNZXRyaWNzO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIFBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIENQVSBwZXJmb3JtYW5jZSBzY29yZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBjcHUgQ1BVIG1ldHJpY3NcclxuICAgKiBAcmV0dXJucyBudW1iZXIgUGVyZm9ybWFuY2Ugc2NvcmUgKDAtMTAwKVxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2FsY3VsYXRlQ1BVU2NvcmUoY3B1PzogQ1BVTWV0cmljcyk6IG51bWJlciB7XHJcbiAgICBpZiAoIWNwdSkgcmV0dXJuIDA7XHJcblxyXG4gICAgLy8gTG93ZXIgdXRpbGl6YXRpb24gYW5kIHRlbXBlcmF0dXJlID0gaGlnaGVyIHNjb3JlXHJcbiAgICBjb25zdCB1dGlsaXphdGlvblNjb3JlID0gTWF0aC5tYXgoMCwgMTAwIC0gY3B1LnV0aWxpemF0aW9uKTtcclxuICAgIGNvbnN0IHRlbXBlcmF0dXJlU2NvcmUgPSBNYXRoLm1heCgwLCAxMDAgLSAoY3B1LnRlbXBlcmF0dXJlIC8gODApICogMTAwKTtcclxuICAgIGNvbnN0IGZyZXF1ZW5jeVNjb3JlID0gTWF0aC5taW4oMTAwLCAoY3B1LmZyZXF1ZW5jeSAvIDMwMDApICogMTAwKTsgLy8gQXNzdW1lIDNHSHogdGFyZ2V0XHJcblxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKHV0aWxpemF0aW9uU2NvcmUgKyB0ZW1wZXJhdHVyZVNjb3JlICsgZnJlcXVlbmN5U2NvcmUpIC8gMyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgbWVtb3J5IHBlcmZvcm1hbmNlIHNjb3JlXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHJhbSBSQU0gbWV0cmljc1xyXG4gICAqIEByZXR1cm5zIG51bWJlciBQZXJmb3JtYW5jZSBzY29yZSAoMC0xMDApXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVNZW1vcnlTY29yZShyYW0/OiBSQU1NZXRyaWNzKTogbnVtYmVyIHtcclxuICAgIGlmICghcmFtKSByZXR1cm4gMDtcclxuXHJcbiAgICAvLyBMb3dlciB1dGlsaXphdGlvbiA9IGhpZ2hlciBzY29yZSwgYnV0IHNvbWUgdXNhZ2UgaXMgZXhwZWN0ZWRcclxuICAgIGNvbnN0IHV0aWxpemF0aW9uU2NvcmUgPSByYW0udXRpbGl6YXRpb24gPCA1MCA/IDEwMCA6IE1hdGgubWF4KDAsIDEwMCAtIChyYW0udXRpbGl6YXRpb24gLSA1MCkgKiAyKTtcclxuICAgIGNvbnN0IGF2YWlsYWJpbGl0eVNjb3JlID0gTWF0aC5taW4oMTAwLCAocmFtLmF2YWlsYWJsZSAvIHJhbS50b3RhbCkgKiAyMDApO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnJvdW5kKCh1dGlsaXphdGlvblNjb3JlICsgYXZhaWxhYmlsaXR5U2NvcmUpIC8gMik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgSS9PIHBlcmZvcm1hbmNlIHNjb3JlXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHNzZCBTU0QgbWV0cmljc1xyXG4gICAqIEByZXR1cm5zIG51bWJlciBQZXJmb3JtYW5jZSBzY29yZSAoMC0xMDApXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVJT1Njb3JlKHNzZD86IFNTRE1ldHJpY3MpOiBudW1iZXIge1xyXG4gICAgaWYgKCFzc2QpIHJldHVybiAwO1xyXG5cclxuICAgIC8vIEhpZ2hlciB0aHJvdWdocHV0IGFuZCBsb3dlciB1dGlsaXphdGlvbiA9IGhpZ2hlciBzY29yZVxyXG4gICAgY29uc3QgdXRpbGl6YXRpb25TY29yZSA9IE1hdGgubWF4KDAsIDEwMCAtIHNzZC51dGlsaXphdGlvbik7XHJcbiAgICBjb25zdCB0aHJvdWdocHV0U2NvcmUgPSBNYXRoLm1pbigxMDAsICgoc3NkLnJlYWRUaHJvdWdocHV0ICsgc3NkLndyaXRlVGhyb3VnaHB1dCkgLyA1MDApICogMTAwKTtcclxuICAgIGNvbnN0IGhlYWx0aFNjb3JlID0gc3NkLmhlYWx0aDtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgodXRpbGl6YXRpb25TY29yZSArIHRocm91Z2hwdXRTY29yZSArIGhlYWx0aFNjb3JlKSAvIDMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIG5ldHdvcmsgcGVyZm9ybWFuY2Ugc2NvcmVcclxuICAgKiBcclxuICAgKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG1ldHJpY3NcclxuICAgKiBAcmV0dXJucyBudW1iZXIgUGVyZm9ybWFuY2Ugc2NvcmUgKDAtMTAwKVxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2FsY3VsYXRlTmV0d29ya1Njb3JlKG5ldHdvcms/OiBhbnkpOiBudW1iZXIge1xyXG4gICAgaWYgKCFuZXR3b3JrKSByZXR1cm4gMDtcclxuXHJcbiAgICBjb25zdCBhY3RpdmVJbnRlcmZhY2VzID0gbmV0d29yay5pbnRlcmZhY2VzPy5maWx0ZXIoKGk6IGFueSkgPT4gaS5pc1VwKS5sZW5ndGggfHwgMDtcclxuICAgIGNvbnN0IGNvbm5lY3Rpdml0eVNjb3JlID0gYWN0aXZlSW50ZXJmYWNlcyA+IDAgPyAxMDAgOiAwO1xyXG4gICAgY29uc3Qgc3BlZWRTY29yZSA9IE1hdGgubWluKDEwMCwgKChuZXR3b3JrLmRvd25sb2FkU3BlZWQgKyBuZXR3b3JrLnVwbG9hZFNwZWVkKSAvIDEwMCkgKiAxMDApO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnJvdW5kKChjb25uZWN0aXZpdHlTY29yZSArIHNwZWVkU2NvcmUpIC8gMik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlcm1hbCBwZXJmb3JtYW5jZSBzY29yZVxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8bnVtYmVyPiBQZXJmb3JtYW5jZSBzY29yZSAoMC0xMDApXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhdGVUaGVybWFsU2NvcmUoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNwdVRlbXAgPSBhd2FpdCBzaS5jcHVUZW1wZXJhdHVyZSgpO1xyXG4gICAgICBjb25zdCBjdXJyZW50VGVtcCA9IGNwdVRlbXAubWFpbiB8fCAwO1xyXG5cclxuICAgICAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgPSBoaWdoZXIgc2NvcmVcclxuICAgICAgaWYgKGN1cnJlbnRUZW1wIDwgNTApIHJldHVybiAxMDA7XHJcbiAgICAgIGlmIChjdXJyZW50VGVtcCA8IDYwKSByZXR1cm4gOTA7XHJcbiAgICAgIGlmIChjdXJyZW50VGVtcCA8IDcwKSByZXR1cm4gNzA7XHJcbiAgICAgIGlmIChjdXJyZW50VGVtcCA8IDgwKSByZXR1cm4gNTA7XHJcbiAgICAgIHJldHVybiAyMDtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gNTA7IC8vIERlZmF1bHQgc2NvcmUgaWYgbWVhc3VyZW1lbnQgZmFpbHNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lYXN1cmUgc3lzdGVtIGxhdGVuY3lcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPG51bWJlcj4gTGF0ZW5jeSBpbiBtaWNyb3NlY29uZHNcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIG1lYXN1cmVTeXN0ZW1MYXRlbmN5KCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICBjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xyXG4gICAgXHJcbiAgICAvLyBQZXJmb3JtIGEgc21hbGwgSS9PIG9wZXJhdGlvbiB0byBtZWFzdXJlIHN5c3RlbSByZXNwb25zaXZlbmVzc1xyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRJbW1lZGlhdGUocmVzb2x2ZSkpO1xyXG4gICAgXHJcbiAgICBjb25zdCBlbmQgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcclxuICAgIHJldHVybiBOdW1iZXIoZW5kIC0gc3RhcnQpIC8gMTAwMDsgLy8gQ29udmVydCB0byBtaWNyb3NlY29uZHNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBDUFUgdGhyb3VnaHB1dFxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBjcHUgQ1BVIG1ldHJpY3NcclxuICAgKiBAcmV0dXJucyBudW1iZXIgT3BlcmF0aW9ucyBwZXIgc2Vjb25kXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVDUFVUaHJvdWdocHV0KGNwdT86IENQVU1ldHJpY3MpOiBudW1iZXIge1xyXG4gICAgaWYgKCFjcHUpIHJldHVybiAwO1xyXG4gICAgXHJcbiAgICAvLyBFc3RpbWF0ZSBiYXNlZCBvbiBmcmVxdWVuY3kgYW5kIHV0aWxpemF0aW9uXHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoY3B1LmZyZXF1ZW5jeSAqIGNwdS5jb3Jlcy5sb2dpY2FsICogKGNwdS51dGlsaXphdGlvbiAvIDEwMCkpIC8gMTAwMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgbWVtb3J5IGJhbmR3aWR0aFxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSByYW0gUkFNIG1ldHJpY3NcclxuICAgKiBAcmV0dXJucyBudW1iZXIgQmFuZHdpZHRoIGluIE1CL3NcclxuICAgKi9cclxuICBwcml2YXRlIGNhbGN1bGF0ZU1lbW9yeUJhbmR3aWR0aChyYW0/OiBSQU1NZXRyaWNzKTogbnVtYmVyIHtcclxuICAgIGlmICghcmFtKSByZXR1cm4gMDtcclxuICAgIFxyXG4gICAgLy8gRXN0aW1hdGUgYmFzZWQgb24gbWVtb3J5IHVzYWdlIHBhdHRlcm5zXHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgocmFtLnVzZWQgLyByYW0udG90YWwpICogMjU2MDApOyAvLyBBc3N1bWUgRERSNC0zMjAwIHRoZW9yZXRpY2FsIG1heFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgb3B0aW1pemF0aW9uIHJlY29tbWVuZGF0aW9uc1xyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8T3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25bXT5cclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVPcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbnMoKTogUHJvbWlzZTxPcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbltdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZWNvbW1lbmRhdGlvbnM6IE9wdGltaXphdGlvblJlY29tbWVuZGF0aW9uW10gPSBbXTtcclxuICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMuc3lzdGVtTW9uaXRvci5nZXRDdXJyZW50TWV0cmljcygpO1xyXG4gICAgICBjb25zdCBsYXRlc3RQZXJmb3JtYW5jZSA9IHRoaXMucGVyZm9ybWFuY2VIaXN0b3J5W3RoaXMucGVyZm9ybWFuY2VIaXN0b3J5Lmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgLy8gQ1BVIHJlY29tbWVuZGF0aW9uc1xyXG4gICAgICBpZiAobWV0cmljcy5jcHUgJiYgbWV0cmljcy5jcHUudXRpbGl6YXRpb24gPiA4MCkge1xyXG4gICAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKHtcclxuICAgICAgICAgIGlkOiBgY3B1X2hpZ2hfdXRpbF8ke0RhdGUubm93KCl9YCxcclxuICAgICAgICAgIHR5cGU6ICdDUFUnLFxyXG4gICAgICAgICAgcHJpb3JpdHk6ICdISUdIJyxcclxuICAgICAgICAgIHRpdGxlOiAnSGlnaCBDUFUgVXRpbGl6YXRpb24nLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDUFUgdXRpbGl6YXRpb24gaXMgJHttZXRyaWNzLmNwdS51dGlsaXphdGlvbn0lLiBDb25zaWRlciByZWR1Y2luZyBiYWNrZ3JvdW5kIHByb2Nlc3NlcyBvciB1cGdyYWRpbmcgQ1BVLmAsXHJcbiAgICAgICAgICBleHBlY3RlZEltcHJvdmVtZW50OiAxNSxcclxuICAgICAgICAgIGNvbXBsZXhpdHk6ICdNRURJVU0nLFxyXG4gICAgICAgICAgY2FuQXV0b0FwcGx5OiBmYWxzZSxcclxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNZW1vcnkgcmVjb21tZW5kYXRpb25zXHJcbiAgICAgIGlmIChtZXRyaWNzLnJhbSAmJiBtZXRyaWNzLnJhbS51dGlsaXphdGlvbiA+IDg1KSB7XHJcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGBtZW1vcnlfaGlnaF91dGlsXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgICAgdHlwZTogJ01FTU9SWScsXHJcbiAgICAgICAgICBwcmlvcml0eTogJ0hJR0gnLFxyXG4gICAgICAgICAgdGl0bGU6ICdIaWdoIE1lbW9yeSBVdGlsaXphdGlvbicsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYE1lbW9yeSB1dGlsaXphdGlvbiBpcyAke21ldHJpY3MucmFtLnV0aWxpemF0aW9ufSUuIENvbnNpZGVyIGFkZGluZyBtb3JlIFJBTSBvciBvcHRpbWl6aW5nIG1lbW9yeSB1c2FnZS5gLFxyXG4gICAgICAgICAgZXhwZWN0ZWRJbXByb3ZlbWVudDogMjAsXHJcbiAgICAgICAgICBjb21wbGV4aXR5OiAnRUFTWScsXHJcbiAgICAgICAgICBjYW5BdXRvQXBwbHk6IGZhbHNlLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZXJtYWwgcmVjb21tZW5kYXRpb25zXHJcbiAgICAgIGlmIChtZXRyaWNzLmNwdSAmJiBtZXRyaWNzLmNwdS50ZW1wZXJhdHVyZSA+IDcwKSB7XHJcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGB0aGVybWFsX2hpZ2hfdGVtcF8ke0RhdGUubm93KCl9YCxcclxuICAgICAgICAgIHR5cGU6ICdUSEVSTUFMJyxcclxuICAgICAgICAgIHByaW9yaXR5OiAnQ1JJVElDQUwnLFxyXG4gICAgICAgICAgdGl0bGU6ICdIaWdoIENQVSBUZW1wZXJhdHVyZScsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENQVSB0ZW1wZXJhdHVyZSBpcyAke21ldHJpY3MuY3B1LnRlbXBlcmF0dXJlfcKwQy4gQ2hlY2sgY29vbGluZyBzeXN0ZW0gYW5kIHZlbnRpbGF0aW9uLmAsXHJcbiAgICAgICAgICBleHBlY3RlZEltcHJvdmVtZW50OiAyNSxcclxuICAgICAgICAgIGNvbXBsZXhpdHk6ICdNRURJVU0nLFxyXG4gICAgICAgICAgY2FuQXV0b0FwcGx5OiB0cnVlLFxyXG4gICAgICAgICAgaW1wbGVtZW50YXRpb246ICdhcHBseV90aGVybWFsX3Rocm90dGxpbmcnLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlIHJlY29tbWVuZGF0aW9uc1xyXG4gICAgICBpZiAobGF0ZXN0UGVyZm9ybWFuY2UgJiYgbGF0ZXN0UGVyZm9ybWFuY2Uub3ZlcmFsbFNjb3JlIDwgNzApIHtcclxuICAgICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICBpZDogYHBlcmZfbG93X3Njb3JlXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgICAgdHlwZTogJ0NQVScsXHJcbiAgICAgICAgICBwcmlvcml0eTogJ01FRElVTScsXHJcbiAgICAgICAgICB0aXRsZTogJ0xvdyBQZXJmb3JtYW5jZSBTY29yZScsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYE92ZXJhbGwgcGVyZm9ybWFuY2Ugc2NvcmUgaXMgJHtsYXRlc3RQZXJmb3JtYW5jZS5vdmVyYWxsU2NvcmV9JS4gU3lzdGVtIG9wdGltaXphdGlvbiByZWNvbW1lbmRlZC5gLFxyXG4gICAgICAgICAgZXhwZWN0ZWRJbXByb3ZlbWVudDogMzAsXHJcbiAgICAgICAgICBjb21wbGV4aXR5OiAnTUVESVVNJyxcclxuICAgICAgICAgIGNhbkF1dG9BcHBseTogdHJ1ZSxcclxuICAgICAgICAgIGltcGxlbWVudGF0aW9uOiAncmVhcHBseV9vcHRpbWl6YXRpb25zJyxcclxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIEZhaWxlZCB0byBnZW5lcmF0ZSBvcHRpbWl6YXRpb24gcmVjb21tZW5kYXRpb25zOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgdGhlcm1hbCBzdGF0dXNcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPFRoZXJtYWxTdGF0dXM+XHJcbiAgICovXHJcbiAgcHVibGljIGFzeW5jIGdldFRoZXJtYWxTdGF0dXMoKTogUHJvbWlzZTxUaGVybWFsU3RhdHVzPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjcHVUZW1wID0gYXdhaXQgc2kuY3B1VGVtcGVyYXR1cmUoKTtcclxuICAgICAgY29uc3QgY3VycmVudFRlbXAgPSBjcHVUZW1wLm1haW4gfHwgMDtcclxuICAgICAgY29uc3QgbWF4U2FmZVRlbXAgPSB0aGlzLmNvbmZpZy50aGVybWFsVGhyb3R0bGVUZW1wO1xyXG4gICAgICBjb25zdCBpc1Rocm90dGxpbmcgPSBjdXJyZW50VGVtcCA+PSBtYXhTYWZlVGVtcDtcclxuXHJcbiAgICAgIGNvbnN0IGFsZXJ0czogc3RyaW5nW10gPSBbXTtcclxuICAgICAgY29uc3QgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnRUZW1wID4gODApIHtcclxuICAgICAgICBhbGVydHMucHVzaCgnQ3JpdGljYWwgdGVtcGVyYXR1cmUgLSBpbW1lZGlhdGUgYWN0aW9uIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0NoZWNrIHN5c3RlbSBjb29saW5nIGFuZCB2ZW50aWxhdGlvbicpO1xyXG4gICAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdSZWR1Y2Ugc3lzdGVtIGxvYWQnKTtcclxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50VGVtcCA+IDcwKSB7XHJcbiAgICAgICAgYWxlcnRzLnB1c2goJ0hpZ2ggdGVtcGVyYXR1cmUgLSBtb25pdG9yaW5nIHJlcXVpcmVkJyk7XHJcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ1ZlcmlmeSBjb29saW5nIHN5c3RlbSBvcGVyYXRpb24nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY29vbGluZ0VmZmVjdGl2ZW5lc3MgPSBNYXRoLm1heCgwLCAxMDAgLSAoKGN1cnJlbnRUZW1wIC0gMzApIC8gNTApICogMTAwKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY3VycmVudFRlbXAsXHJcbiAgICAgICAgbWF4U2FmZVRlbXAsXHJcbiAgICAgICAgaXNUaHJvdHRsaW5nLFxyXG4gICAgICAgIGNvb2xpbmdFZmZlY3RpdmVuZXNzOiBNYXRoLnJvdW5kKGNvb2xpbmdFZmZlY3RpdmVuZXNzKSxcclxuICAgICAgICBhbGVydHMsXHJcbiAgICAgICAgcmVjb21tZW5kYXRpb25zXHJcbiAgICAgIH07XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKCfinYwgRmFpbGVkIHRvIGdldCB0aGVybWFsIHN0YXR1czonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHBlcmZvcm1hbmNlIGhpc3RvcnlcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQZXJmb3JtYW5jZU1ldHJpY3NbXSBQZXJmb3JtYW5jZSBoaXN0b3J5XHJcbiAgICovXHJcbiAgcHVibGljIGdldFBlcmZvcm1hbmNlSGlzdG9yeSgpOiBQZXJmb3JtYW5jZU1ldHJpY3NbXSB7XHJcbiAgICByZXR1cm4gWy4uLnRoaXMucGVyZm9ybWFuY2VIaXN0b3J5XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQZXJmb3JtYW5jZU1ldHJpY3MgfCBudWxsIEN1cnJlbnQgbWV0cmljc1xyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRDdXJyZW50UGVyZm9ybWFuY2VNZXRyaWNzKCk6IFBlcmZvcm1hbmNlTWV0cmljcyB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMucGVyZm9ybWFuY2VIaXN0b3J5W3RoaXMucGVyZm9ybWFuY2VIaXN0b3J5Lmxlbmd0aCAtIDFdIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdG9wUGVyZm9ybWFuY2VPcHRpbWl6YXRpb24oKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5vcHRpbWl6YXRpb25JbnRlcnZhbCkge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMub3B0aW1pemF0aW9uSW50ZXJ2YWwpO1xyXG4gICAgICB0aGlzLm9wdGltaXphdGlvbkludGVydmFsID0gbnVsbDtcclxuICAgICAgbG9nZ2VyLmluZm8oJ/Cfm5EgUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHN0b3BwZWQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvcHRpbWl6ZXIgc3RhdHVzXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgc3RhdHVzIGluZm9ybWF0aW9uXHJcbiAgICovXHJcbiAgcHVibGljIGdldFN0YXR1cygpOiB7XHJcbiAgICBpc09wdGltaXppbmc6IGJvb2xlYW47XHJcbiAgICBjb25maWc6IFBlcmZvcm1hbmNlQ29uZmlnO1xyXG4gICAgcGVyZm9ybWFuY2VIaXN0b3J5OiBudW1iZXI7XHJcbiAgICBsYXRlc3RTY29yZTogbnVtYmVyIHwgbnVsbDtcclxuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIH0ge1xyXG4gICAgY29uc3QgbGF0ZXN0TWV0cmljcyA9IHRoaXMuZ2V0Q3VycmVudFBlcmZvcm1hbmNlTWV0cmljcygpO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpc09wdGltaXppbmc6IHRoaXMub3B0aW1pemF0aW9uSW50ZXJ2YWwgIT09IG51bGwsXHJcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXHJcbiAgICAgIHBlcmZvcm1hbmNlSGlzdG9yeTogdGhpcy5wZXJmb3JtYW5jZUhpc3RvcnkubGVuZ3RoLFxyXG4gICAgICBsYXRlc3RTY29yZTogbGF0ZXN0TWV0cmljcz8ub3ZlcmFsbFNjb3JlIHx8IG51bGwsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBFUkZPUk1BTkNFIE9QVElNSVpBVElPTiBOT1RFU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyAxLiBMb3ctbGF0ZW5jeSBvcHRpbWl6YXRpb25zIGZvciBoaWdoLWZyZXF1ZW5jeSB0cmFkaW5nIG9wZXJhdGlvbnNcclxuLy8gMi4gVGhlcm1hbCBtYW5hZ2VtZW50IHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cclxuLy8gMy4gUmVzb3VyY2UgYWxsb2NhdGlvbiBvcHRpbWl6YXRpb24gZm9yIGNvbnNpc3RlbnQgcGVyZm9ybWFuY2VcclxuLy8gNC4gUmVhbC10aW1lIHBlcmZvcm1hbmNlIG1vbml0b3JpbmcgYW5kIGFkanVzdG1lbnRcclxuLy8gNS4gQXV0b21hdGljIG9wdGltaXphdGlvbiByZWNvbW1lbmRhdGlvbnMgYW5kIGltcGxlbWVudGF0aW9uXHJcbi8vIDYuIFN5c3RlbSBoZWFsdGggc2NvcmluZyBmb3IgcGVyZm9ybWFuY2UgYXNzZXNzbWVudFxyXG4vLyA3LiBDb21wcmVoZW5zaXZlIGxvZ2dpbmcgYW5kIGF1ZGl0IHRyYWlscyBmb3IgYWxsIG9wdGltaXphdGlvbnNcclxuLy8gOC4gSGFyZHdhcmUtc3BlY2lmaWMgb3B0aW1pemF0aW9ucyBmb3IgSW50ZWwgTlVDIHBsYXRmb3JtXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiJdLCJ2ZXJzaW9uIjozfQ==