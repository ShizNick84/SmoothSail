c9b854542d1a7b613fe1d25618ef4f16
"use strict";
/**
 * =============================================================================
 * AI CRYPTO TRADING AGENT - AUTO-RESTART AND RECOVERY MANAGER
 * =============================================================================
 *
 * This service provides comprehensive auto-restart and recovery capabilities
 * for the AI crypto trading agent. It manages systemd services, graceful
 * shutdowns, failure detection, and automatic recovery procedures.
 *
 * CRITICAL RELIABILITY NOTICE:
 * This system manages the availability of trading operations. System failures
 * or improper recovery could impact trading decisions and result in financial
 * losses. All recovery procedures are logged and monitored.
 *
 * Hardware Specifications:
 * - Intel NUC with i5 CPU
 * - 12GB RAM
 * - 256GB M.2 SSD
 * - Ubuntu OS with systemd
 *
 * @author AI Crypto Trading System
 * @version 1.0.0
 * @license PROPRIETARY
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoRestartManager = void 0;
const events_1 = require("events");
const logger_1 = require("@/core/logging/logger");
const audit_service_1 = require("@/security/audit-service");
/**
 * Auto-Restart and Recovery Manager
 * Provides comprehensive system recovery and restart capabilities
 */
class AutoRestartManager extends events_1.EventEmitter {
    services = new Map();
    recoveryStatus = new Map();
    failureDetectionConfig;
    shutdownConfig;
    monitoringInterval = null;
    isShuttingDown = false;
    healthCheckIntervals = new Map();
    constructor() {
        super();
        this.failureDetectionConfig = this.loadFailureDetectionConfig();
        this.shutdownConfig = this.loadShutdownConfig();
        logger_1.logger.info('üîÑ Auto-Restart Manager initializing...');
    }
    /**
     * Load failure detection configuration
     *
     * @returns FailureDetectionConfig Configuration object
     */
    loadFailureDetectionConfig() {
        return {
            enableHealthCheck: process.env.ENABLE_HEALTH_CHECK !== 'false',
            healthCheckInterval: parseInt(process.env.HEALTH_CHECK_INTERVAL_MS || '30000'),
            healthCheckTimeout: parseInt(process.env.HEALTH_CHECK_TIMEOUT_MS || '5000'),
            maxConsecutiveFailures: parseInt(process.env.MAX_CONSECUTIVE_FAILURES || '3'),
            enableProcessMonitoring: process.env.ENABLE_PROCESS_MONITORING !== 'false',
            enableResourceMonitoring: process.env.ENABLE_RESOURCE_MONITORING !== 'false',
            memoryThreshold: parseInt(process.env.MEMORY_RESTART_THRESHOLD || '90'),
            cpuThreshold: parseInt(process.env.CPU_RESTART_THRESHOLD || '95'),
            enableLogMonitoring: process.env.ENABLE_LOG_MONITORING !== 'false',
            errorPatterns: (process.env.ERROR_PATTERNS || 'FATAL,CRITICAL,OutOfMemoryError').split(',')
        };
    }
    /**
     * Load graceful shutdown configuration
     *
     * @returns ShutdownConfig Configuration object
     */
    loadShutdownConfig() {
        return {
            timeout: parseInt(process.env.SHUTDOWN_TIMEOUT_MS || '30000'),
            closePositions: process.env.SHUTDOWN_CLOSE_POSITIONS !== 'false',
            backupData: process.env.SHUTDOWN_BACKUP_DATA !== 'false',
            sendNotifications: process.env.SHUTDOWN_SEND_NOTIFICATIONS !== 'false',
            shutdownHooks: []
        };
    }
    /**
     * Initialize auto-restart and recovery system
     *
     * @returns Promise<void>
     */
    async initialize() {
        try {
            logger_1.logger.info('üîÑ Initializing auto-restart and recovery system...');
            // Create main trading service configuration
            await this.createTradingServiceConfig();
            // Create supporting service configurations
            await this.createSupportingServiceConfigs();
            // Generate systemd service files
            await this.generateSystemdServiceFiles();
            // Start failure detection monitoring
            await this.startFailureDetection();
            // Set up graceful shutdown handlers
            this.setupGracefulShutdownHandlers();
            logger_1.logger.info('‚úÖ Auto-restart and recovery system initialized');
            // Audit log
            await audit_service_1.auditService.createAuditEntry({
                auditId: `restart_mgr_init_${Date.now()}`,
                eventType: 'AUTO_RESTART_MANAGER_INIT',
                actor: 'SYSTEM',
                resource: 'AUTO_RESTART_MANAGER',
                action: 'INITIALIZE',
                result: 'SUCCESS',
                timestamp: new Date(),
                auditData: {
                    servicesCount: this.services.size,
                    failureDetectionEnabled: this.failureDetectionConfig.enableHealthCheck
                }
            });
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to initialize auto-restart system:', error);
            throw new Error('Auto-restart system initialization failed');
        }
    }
    /**
     * Create main trading service configuration
     *
     * @returns Promise<void>
     */
    async createTradingServiceConfig() {
        const tradingServiceConfig = {
            name: 'ai-crypto-trading-agent',
            description: 'AI Cryptocurrency Trading Agent - Main Service',
            execPath: '/usr/bin/node',
            workingDirectory: process.cwd(),
            environment: {
                NODE_ENV: 'production',
                NODE_OPTIONS: '--max-old-space-size=8192',
                PATH: '/usr/local/bin:/usr/bin:/bin'
            },
            user: process.env.SERVICE_USER || 'trading',
            group: process.env.SERVICE_GROUP || 'trading',
            restartPolicy: 'always',
            restartDelay: 10,
            maxRestartAttempts: 5,
            dependencies: ['network.target', 'ssh-tunnel.service'],
            requires: ['network.target'],
            after: ['network.target', 'ssh-tunnel.service', 'system-monitor.service'],
            before: []
        };
        this.services.set(tradingServiceConfig.name, tradingServiceConfig);
        this.initializeRecoveryStatus(tradingServiceConfig.name);
    }
    /**
     * Create supporting service configurations
     *
     * @returns Promise<void>
     */
    async createSupportingServiceConfigs() {
        // SSH Tunnel Service
        const sshTunnelConfig = {
            name: 'ssh-tunnel',
            description: 'SSH Tunnel to Oracle Free Tier',
            execPath: '/usr/bin/ssh',
            workingDirectory: '/home/trading',
            environment: {
                SSH_AUTH_SOCK: '',
                PATH: '/usr/local/bin:/usr/bin:/bin'
            },
            user: 'trading',
            group: 'trading',
            restartPolicy: 'always',
            restartDelay: 5,
            maxRestartAttempts: 10,
            dependencies: ['network.target'],
            requires: ['network.target'],
            after: ['network.target'],
            before: ['ai-crypto-trading-agent.service']
        };
        // System Monitor Service
        const systemMonitorConfig = {
            name: 'system-monitor',
            description: 'Intel NUC System Monitor',
            execPath: '/usr/bin/node',
            workingDirectory: process.cwd(),
            environment: {
                NODE_ENV: 'production',
                PATH: '/usr/local/bin:/usr/bin:/bin'
            },
            user: 'trading',
            group: 'trading',
            restartPolicy: 'always',
            restartDelay: 5,
            maxRestartAttempts: 3,
            dependencies: ['network.target'],
            requires: [],
            after: ['network.target'],
            before: ['ai-crypto-trading-agent.service']
        };
        this.services.set(sshTunnelConfig.name, sshTunnelConfig);
        this.services.set(systemMonitorConfig.name, systemMonitorConfig);
        this.initializeRecoveryStatus(sshTunnelConfig.name);
        this.initializeRecoveryStatus(systemMonitorConfig.name);
    }
    /**
     * Initialize recovery status for a service
     *
     * @param serviceName Service name
     */
    initializeRecoveryStatus(serviceName) {
        this.recoveryStatus.set(serviceName, {
            serviceName,
            status: 'unknown',
            lastRestart: null,
            restartCount: 0,
            consecutiveFailures: 0,
            lastFailureReason: null,
            recoveryActions: [],
            healthStatus: 'unknown',
            lastHealthCheck: null
        });
    }
    /**
     * Generate systemd service files
     *
     * @returns Promise<void>
     */
    async generateSystemdServiceFiles() {
        try {
            logger_1.logger.info('üìù Generating systemd service files...');
            for (const [serviceName, config] of this.services) {
                const serviceFileContent = this.generateServiceFileContent(config);
                const serviceFilePath = `/etc/systemd/system/${serviceName}.service`;
                // Write service file (would need sudo permissions)
                try {
                    const { writeFileSync } = await import('fs');
                    const { execSync } = await import('child_process');
                    // Create temporary file first
                    const tempPath = `/tmp/${serviceName}.service`;
                    writeFileSync(tempPath, serviceFileContent);
                    // Move to systemd directory with sudo
                    execSync(`sudo mv ${tempPath} ${serviceFilePath}`, { stdio: 'pipe' });
                    execSync(`sudo chmod 644 ${serviceFilePath}`, { stdio: 'pipe' });
                    logger_1.logger.info(`‚úÖ Created service file: ${serviceFilePath}`);
                }
                catch (error) {
                    logger_1.logger.warn(`‚ö†Ô∏è Could not create service file for ${serviceName}:`, error);
                    // Continue with other services
                }
            }
            // Reload systemd daemon
            try {
                const { execSync } = await import('child_process');
                execSync('sudo systemctl daemon-reload', { stdio: 'pipe' });
                logger_1.logger.info('‚úÖ Systemd daemon reloaded');
            }
            catch (error) {
                logger_1.logger.warn('‚ö†Ô∏è Could not reload systemd daemon:', error);
            }
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to generate systemd service files:', error);
        }
    }
    /**
     * Generate systemd service file content
     *
     * @param config Service configuration
     * @returns string Service file content
     */
    generateServiceFileContent(config) {
        const environmentVars = Object.entries(config.environment)
            .map(([key, value]) => `Environment=${key}=${value}`)
            .join('\n');
        const dependencies = config.dependencies.length > 0
            ? `Wants=${config.dependencies.join(' ')}\n`
            : '';
        const requires = config.requires.length > 0
            ? `Requires=${config.requires.join(' ')}\n`
            : '';
        const after = config.after.length > 0
            ? `After=${config.after.join(' ')}\n`
            : '';
        const before = config.before.length > 0
            ? `Before=${config.before.join(' ')}\n`
            : '';
        return `[Unit]
Description=${config.description}
${dependencies}${requires}${after}${before}

[Service]
Type=simple
User=${config.user}
Group=${config.group}
WorkingDirectory=${config.workingDirectory}
ExecStart=${this.generateExecStart(config)}
Restart=${config.restartPolicy}
RestartSec=${config.restartDelay}
StartLimitBurst=${config.maxRestartAttempts}
StartLimitIntervalSec=300
${environmentVars}

# Security settings
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=${config.workingDirectory}
PrivateTmp=true

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
`;
    }
    /**
     * Generate ExecStart command for service
     *
     * @param config Service configuration
     * @returns string ExecStart command
     */
    generateExecStart(config) {
        switch (config.name) {
            case 'ai-crypto-trading-agent':
                return `${config.execPath} ${config.workingDirectory}/dist/index.js`;
            case 'ssh-tunnel':
                const oracleIP = process.env.ORACLE_IP || '168.138.104.117';
                const sshUser = process.env.SSH_USER || 'ubuntu';
                const sshKey = process.env.SSH_KEY_PATH || '/home/trading/.ssh/id_rsa';
                const localPort = process.env.LOCAL_TUNNEL_PORT || '8080';
                const remotePort = process.env.REMOTE_TUNNEL_PORT || '80';
                return `${config.execPath} -N -L ${localPort}:localhost:${remotePort} -i ${sshKey} ${sshUser}@${oracleIP}`;
            case 'system-monitor':
                return `${config.execPath} ${config.workingDirectory}/dist/scripts/system-monitor.js`;
            default:
                return `${config.execPath} ${config.workingDirectory}/dist/index.js`;
        }
    }
    /**
     * Start failure detection monitoring
     *
     * @returns Promise<void>
     */
    async startFailureDetection() {
        try {
            logger_1.logger.info('üîç Starting failure detection monitoring...');
            if (this.failureDetectionConfig.enableHealthCheck) {
                // Start health checks for each service
                for (const serviceName of this.services.keys()) {
                    this.startHealthCheck(serviceName);
                }
            }
            // Start general monitoring
            this.monitoringInterval = setInterval(async () => {
                try {
                    await this.performFailureDetection();
                }
                catch (error) {
                    logger_1.logger.error('‚ùå Failure detection error:', error);
                }
            }, this.failureDetectionConfig.healthCheckInterval);
            logger_1.logger.info('‚úÖ Failure detection monitoring started');
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to start failure detection:', error);
        }
    }
    /**
     * Start health check for a specific service
     *
     * @param serviceName Service name
     */
    startHealthCheck(serviceName) {
        const interval = setInterval(async () => {
            try {
                await this.performHealthCheck(serviceName);
            }
            catch (error) {
                logger_1.logger.error(`‚ùå Health check failed for ${serviceName}:`, error);
            }
        }, this.failureDetectionConfig.healthCheckInterval);
        this.healthCheckIntervals.set(serviceName, interval);
    }
    /**
     * Perform health check for a service
     *
     * @param serviceName Service name
     * @returns Promise<void>
     */
    async performHealthCheck(serviceName) {
        try {
            const status = this.recoveryStatus.get(serviceName);
            if (!status)
                return;
            // Check service status using systemctl
            const isHealthy = await this.checkServiceHealth(serviceName);
            status.lastHealthCheck = new Date();
            if (isHealthy) {
                status.healthStatus = 'healthy';
                status.consecutiveFailures = 0;
            }
            else {
                status.healthStatus = 'unhealthy';
                status.consecutiveFailures++;
                logger_1.logger.warn(`‚ö†Ô∏è Health check failed for ${serviceName} (${status.consecutiveFailures}/${this.failureDetectionConfig.maxConsecutiveFailures})`);
                // Trigger recovery if threshold exceeded
                if (status.consecutiveFailures >= this.failureDetectionConfig.maxConsecutiveFailures) {
                    await this.triggerServiceRecovery(serviceName, 'consecutive_health_check_failures');
                }
            }
        }
        catch (error) {
            logger_1.logger.error(`‚ùå Health check error for ${serviceName}:`, error);
        }
    }
    /**
     * Check service health using systemctl
     *
     * @param serviceName Service name
     * @returns Promise<boolean> True if healthy
     */
    async checkServiceHealth(serviceName) {
        try {
            const { execSync } = await import('child_process');
            // Check if service is active
            const result = execSync(`systemctl is-active ${serviceName}`, {
                stdio: 'pipe',
                encoding: 'utf8'
            });
            return result.trim() === 'active';
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Perform comprehensive failure detection
     *
     * @returns Promise<void>
     */
    async performFailureDetection() {
        try {
            for (const serviceName of this.services.keys()) {
                const status = this.recoveryStatus.get(serviceName);
                if (!status)
                    continue;
                // Update service status
                await this.updateServiceStatus(serviceName);
                // Check for resource issues
                if (this.failureDetectionConfig.enableResourceMonitoring) {
                    await this.checkResourceUsage(serviceName);
                }
                // Check for log errors
                if (this.failureDetectionConfig.enableLogMonitoring) {
                    await this.checkLogErrors(serviceName);
                }
            }
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failure detection error:', error);
        }
    }
    /**
     * Update service status
     *
     * @param serviceName Service name
     * @returns Promise<void>
     */
    async updateServiceStatus(serviceName) {
        try {
            const { execSync } = await import('child_process');
            const status = this.recoveryStatus.get(serviceName);
            if (!status)
                return;
            // Get service status
            const result = execSync(`systemctl show ${serviceName} --property=ActiveState,SubState`, {
                stdio: 'pipe',
                encoding: 'utf8'
            });
            const lines = result.split('\n');
            const activeState = lines.find(line => line.startsWith('ActiveState='))?.split('=')[1];
            const subState = lines.find(line => line.startsWith('SubState='))?.split('=')[1];
            // Map systemd states to our status
            if (activeState === 'active' && subState === 'running') {
                status.status = 'running';
            }
            else if (activeState === 'failed') {
                status.status = 'failed';
                if (status.lastFailureReason !== 'systemd_failed') {
                    await this.triggerServiceRecovery(serviceName, 'systemd_failed');
                }
            }
            else if (activeState === 'activating') {
                status.status = 'restarting';
            }
            else {
                status.status = 'stopped';
            }
        }
        catch (error) {
            logger_1.logger.error(`‚ùå Failed to update status for ${serviceName}:`, error);
        }
    }
    /**
     * Check resource usage for a service
     *
     * @param serviceName Service name
     * @returns Promise<void>
     */
    async checkResourceUsage(serviceName) {
        try {
            // This would integrate with system monitoring to check resource usage
            // For now, we'll implement a basic check
            if (serviceName === 'ai-crypto-trading-agent') {
                const memoryUsage = process.memoryUsage();
                const memoryUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;
                if (memoryUsagePercent > this.failureDetectionConfig.memoryThreshold) {
                    await this.triggerServiceRecovery(serviceName, `high_memory_usage_${memoryUsagePercent.toFixed(1)}%`);
                }
            }
        }
        catch (error) {
            logger_1.logger.error(`‚ùå Resource usage check failed for ${serviceName}:`, error);
        }
    }
    /**
     * Check for log errors
     *
     * @param serviceName Service name
     * @returns Promise<void>
     */
    async checkLogErrors(serviceName) {
        try {
            const { execSync } = await import('child_process');
            // Check recent journal entries for error patterns
            const result = execSync(`journalctl -u ${serviceName} --since "5 minutes ago" --no-pager`, {
                stdio: 'pipe',
                encoding: 'utf8'
            });
            for (const pattern of this.failureDetectionConfig.errorPatterns) {
                if (result.includes(pattern)) {
                    await this.triggerServiceRecovery(serviceName, `log_error_pattern_${pattern}`);
                    break;
                }
            }
        }
        catch (error) {
            // Ignore errors - service might not exist yet
        }
    }
    /**
     * Trigger service recovery
     *
     * @param serviceName Service name
     * @param reason Failure reason
     * @returns Promise<void>
     */
    async triggerServiceRecovery(serviceName, reason) {
        try {
            const status = this.recoveryStatus.get(serviceName);
            if (!status)
                return;
            logger_1.logger.warn(`üîÑ Triggering recovery for ${serviceName} - Reason: ${reason}`);
            status.lastFailureReason = reason;
            status.restartCount++;
            status.lastRestart = new Date();
            status.recoveryActions.push(`restart_${Date.now()}_${reason}`);
            // Perform recovery actions
            await this.performRecoveryActions(serviceName, reason);
            // Audit log
            await audit_service_1.auditService.createAuditEntry({
                auditId: `service_recovery_${serviceName}_${Date.now()}`,
                eventType: 'SERVICE_RECOVERY_TRIGGERED',
                actor: 'AUTO_RESTART_MANAGER',
                resource: `SERVICE_${serviceName.toUpperCase()}`,
                action: 'TRIGGER_RECOVERY',
                result: 'SUCCESS',
                timestamp: new Date(),
                auditData: {
                    serviceName,
                    reason,
                    restartCount: status.restartCount,
                    consecutiveFailures: status.consecutiveFailures
                }
            });
            // Emit recovery event
            this.emit('serviceRecovery', { serviceName, reason, status });
        }
        catch (error) {
            logger_1.logger.error(`‚ùå Service recovery failed for ${serviceName}:`, error);
        }
    }
    /**
     * Perform recovery actions for a service
     *
     * @param serviceName Service name
     * @param reason Failure reason
     * @returns Promise<void>
     */
    async performRecoveryActions(serviceName, reason) {
        try {
            const { execSync } = await import('child_process');
            // Stop service gracefully first
            try {
                execSync(`sudo systemctl stop ${serviceName}`, { stdio: 'pipe', timeout: 10000 });
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            catch (error) {
                logger_1.logger.warn(`‚ö†Ô∏è Graceful stop failed for ${serviceName}, forcing stop`);
            }
            // Force kill if necessary
            try {
                execSync(`sudo systemctl kill ${serviceName}`, { stdio: 'pipe' });
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            catch (error) {
                // Ignore - service might already be stopped
            }
            // Clear any failed state
            try {
                execSync(`sudo systemctl reset-failed ${serviceName}`, { stdio: 'pipe' });
            }
            catch (error) {
                // Ignore - service might not be in failed state
            }
            // Restart service
            execSync(`sudo systemctl start ${serviceName}`, { stdio: 'pipe' });
            logger_1.logger.info(`‚úÖ Service ${serviceName} restarted successfully`);
        }
        catch (error) {
            logger_1.logger.error(`‚ùå Recovery actions failed for ${serviceName}:`, error);
            throw error;
        }
    }
    /**
     * Setup graceful shutdown handlers
     */
    setupGracefulShutdownHandlers() {
        // Handle shutdown signals
        process.on('SIGTERM', () => this.handleGracefulShutdown('SIGTERM'));
        process.on('SIGINT', () => this.handleGracefulShutdown('SIGINT'));
        process.on('SIGHUP', () => this.handleGracefulShutdown('SIGHUP'));
        logger_1.logger.info('‚úÖ Graceful shutdown handlers configured');
    }
    /**
     * Handle graceful shutdown
     *
     * @param signal Shutdown signal
     * @returns Promise<void>
     */
    async handleGracefulShutdown(signal) {
        if (this.isShuttingDown) {
            logger_1.logger.warn('‚ö†Ô∏è Shutdown already in progress');
            return;
        }
        this.isShuttingDown = true;
        logger_1.logger.info(`üõë Graceful shutdown initiated - Signal: ${signal}`);
        try {
            const shutdownPromise = this.performGracefulShutdown();
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Shutdown timeout')), this.shutdownConfig.timeout));
            await Promise.race([shutdownPromise, timeoutPromise]);
            logger_1.logger.info('‚úÖ Graceful shutdown completed');
            process.exit(0);
        }
        catch (error) {
            logger_1.logger.error('‚ùå Graceful shutdown failed:', error);
            process.exit(1);
        }
    }
    /**
     * Perform graceful shutdown procedures
     *
     * @returns Promise<void>
     */
    async performGracefulShutdown() {
        try {
            // Stop monitoring
            this.stopMonitoring();
            // Execute shutdown hooks
            for (const hook of this.shutdownConfig.shutdownHooks) {
                try {
                    await hook();
                }
                catch (error) {
                    logger_1.logger.error('‚ùå Shutdown hook failed:', error);
                }
            }
            // Stop all managed services
            await this.stopAllServices();
            // Send shutdown notifications
            if (this.shutdownConfig.sendNotifications) {
                await this.sendShutdownNotifications();
            }
            // Create final audit entry
            await audit_service_1.auditService.createAuditEntry({
                auditId: `graceful_shutdown_${Date.now()}`,
                eventType: 'GRACEFUL_SHUTDOWN_COMPLETED',
                actor: 'AUTO_RESTART_MANAGER',
                resource: 'SYSTEM',
                action: 'GRACEFUL_SHUTDOWN',
                result: 'SUCCESS',
                timestamp: new Date(),
                auditData: { shutdownConfig: this.shutdownConfig }
            });
        }
        catch (error) {
            logger_1.logger.error('‚ùå Graceful shutdown procedures failed:', error);
            throw error;
        }
    }
    /**
     * Stop all monitoring activities
     */
    stopMonitoring() {
        // Stop main monitoring interval
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
        // Stop health check intervals
        for (const [serviceName, interval] of this.healthCheckIntervals) {
            clearInterval(interval);
        }
        this.healthCheckIntervals.clear();
        logger_1.logger.info('üõë Monitoring stopped');
    }
    /**
     * Stop all managed services
     *
     * @returns Promise<void>
     */
    async stopAllServices() {
        try {
            const { execSync } = await import('child_process');
            // Stop services in reverse dependency order
            const serviceOrder = ['ai-crypto-trading-agent', 'system-monitor', 'ssh-tunnel'];
            for (const serviceName of serviceOrder) {
                if (this.services.has(serviceName)) {
                    try {
                        execSync(`sudo systemctl stop ${serviceName}`, { stdio: 'pipe', timeout: 10000 });
                        logger_1.logger.info(`‚úÖ Stopped service: ${serviceName}`);
                    }
                    catch (error) {
                        logger_1.logger.warn(`‚ö†Ô∏è Failed to stop service ${serviceName}:`, error);
                    }
                }
            }
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to stop services:', error);
        }
    }
    /**
     * Send shutdown notifications
     *
     * @returns Promise<void>
     */
    async sendShutdownNotifications() {
        try {
            // This would integrate with notification service
            logger_1.logger.info('üìß Shutdown notifications sent');
        }
        catch (error) {
            logger_1.logger.error('‚ùå Failed to send shutdown notifications:', error);
        }
    }
    /**
     * Add shutdown hook
     *
     * @param hook Shutdown hook function
     */
    addShutdownHook(hook) {
        this.shutdownConfig.shutdownHooks.push(hook);
    }
    /**
     * Get recovery status for all services
     *
     * @returns Map<string, RecoveryStatus> Recovery status map
     */
    getRecoveryStatus() {
        return new Map(this.recoveryStatus);
    }
    /**
     * Get recovery status for a specific service
     *
     * @param serviceName Service name
     * @returns RecoveryStatus | null Recovery status
     */
    getServiceRecoveryStatus(serviceName) {
        return this.recoveryStatus.get(serviceName) || null;
    }
    /**
     * Get manager status
     *
     * @returns Object containing status information
     */
    getStatus() {
        const activeServices = Array.from(this.recoveryStatus.values())
            .filter(status => status.status === 'running').length;
        const failedServices = Array.from(this.recoveryStatus.values())
            .filter(status => status.status === 'failed').length;
        const totalRestarts = Array.from(this.recoveryStatus.values())
            .reduce((sum, status) => sum + status.restartCount, 0);
        return {
            isMonitoring: this.monitoringInterval !== null,
            servicesCount: this.services.size,
            activeServices,
            failedServices,
            totalRestarts,
            isShuttingDown: this.isShuttingDown,
            timestamp: Date.now()
        };
    }
}
exports.AutoRestartManager = AutoRestartManager;
// =============================================================================
// AUTO-RESTART AND RECOVERY SYSTEM NOTES
// =============================================================================
// 1. Systemd service file generation for automatic startup
// 2. Comprehensive failure detection and health monitoring
// 3. Automatic service recovery with exponential backoff
// 4. Graceful shutdown procedures with position closure
// 5. Dependency management for proper service startup order
// 6. Resource monitoring and automatic restart on threshold breach
// 7. Log monitoring for error pattern detection
// 8. Comprehensive audit logging for all recovery actions
// =============================================================================
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxOaWNrXFxEZXNrdG9wXFxTbW9vdGhTYWlsXFxzcmNcXGluZnJhc3RydWN0dXJlXFxhdXRvLXJlc3RhcnQtbWFuYWdlci50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdCRzs7O0FBRUgsbUNBQXNDO0FBQ3RDLGtEQUErQztBQUMvQyw0REFBd0Q7QUFzR3hEOzs7R0FHRztBQUNILE1BQWEsa0JBQW1CLFNBQVEscUJBQVk7SUFDMUMsUUFBUSxHQUErQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2pELGNBQWMsR0FBZ0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUN4RCxzQkFBc0IsQ0FBeUI7SUFDL0MsY0FBYyxDQUFpQjtJQUMvQixrQkFBa0IsR0FBMEIsSUFBSSxDQUFDO0lBQ2pELGNBQWMsR0FBWSxLQUFLLENBQUM7SUFDaEMsb0JBQW9CLEdBQWdDLElBQUksR0FBRyxFQUFFLENBQUM7SUFFdEU7UUFDRSxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztRQUNoRSxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ2hELGVBQU0sQ0FBQyxJQUFJLENBQUMseUNBQXlDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLDBCQUEwQjtRQUNoQyxPQUFPO1lBQ0wsaUJBQWlCLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsS0FBSyxPQUFPO1lBQzlELG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUF3QixJQUFJLE9BQU8sQ0FBQztZQUM5RSxrQkFBa0IsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsSUFBSSxNQUFNLENBQUM7WUFDM0Usc0JBQXNCLEVBQUUsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLElB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QWE7WUFDYixjQUFjLEVBQUUsSUFBSSxDQUFDLGNBQWM7WUFDbkMsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUU7U0FDdEIsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXgyQkQsZ0RBdzJCQztBQUVELGdGQUFnRjtBQUNoRix5Q0FBeUM7QUFDekMsZ0ZBQWdGO0FBQ2hGLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pELHdEQUF3RDtBQUN4RCw0REFBNEQ7QUFDNUQsbUVBQW1FO0FBQ25FLGdEQUFnRDtBQUNoRCwwREFBMEQ7QUFDMUQsZ0ZBQWdGIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTmlja1xcRGVza3RvcFxcU21vb3RoU2FpbFxcc3JjXFxpbmZyYXN0cnVjdHVyZVxcYXV0by1yZXN0YXJ0LW1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEFJIENSWVBUTyBUUkFESU5HIEFHRU5UIC0gQVVUTy1SRVNUQVJUIEFORCBSRUNPVkVSWSBNQU5BR0VSXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFxyXG4gKiBUaGlzIHNlcnZpY2UgcHJvdmlkZXMgY29tcHJlaGVuc2l2ZSBhdXRvLXJlc3RhcnQgYW5kIHJlY292ZXJ5IGNhcGFiaWxpdGllc1xyXG4gKiBmb3IgdGhlIEFJIGNyeXB0byB0cmFkaW5nIGFnZW50LiBJdCBtYW5hZ2VzIHN5c3RlbWQgc2VydmljZXMsIGdyYWNlZnVsXHJcbiAqIHNodXRkb3ducywgZmFpbHVyZSBkZXRlY3Rpb24sIGFuZCBhdXRvbWF0aWMgcmVjb3ZlcnkgcHJvY2VkdXJlcy5cclxuICogXHJcbiAqIENSSVRJQ0FMIFJFTElBQklMSVRZIE5PVElDRTpcclxuICogVGhpcyBzeXN0ZW0gbWFuYWdlcyB0aGUgYXZhaWxhYmlsaXR5IG9mIHRyYWRpbmcgb3BlcmF0aW9ucy4gU3lzdGVtIGZhaWx1cmVzXHJcbiAqIG9yIGltcHJvcGVyIHJlY292ZXJ5IGNvdWxkIGltcGFjdCB0cmFkaW5nIGRlY2lzaW9ucyBhbmQgcmVzdWx0IGluIGZpbmFuY2lhbFxyXG4gKiBsb3NzZXMuIEFsbCByZWNvdmVyeSBwcm9jZWR1cmVzIGFyZSBsb2dnZWQgYW5kIG1vbml0b3JlZC5cclxuICogXHJcbiAqIEhhcmR3YXJlIFNwZWNpZmljYXRpb25zOlxyXG4gKiAtIEludGVsIE5VQyB3aXRoIGk1IENQVVxyXG4gKiAtIDEyR0IgUkFNXHJcbiAqIC0gMjU2R0IgTS4yIFNTRFxyXG4gKiAtIFVidW50dSBPUyB3aXRoIHN5c3RlbWRcclxuICogXHJcbiAqIEBhdXRob3IgQUkgQ3J5cHRvIFRyYWRpbmcgU3lzdGVtXHJcbiAqIEB2ZXJzaW9uIDEuMC4wXHJcbiAqIEBsaWNlbnNlIFBST1BSSUVUQVJZXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQC9jb3JlL2xvZ2dpbmcvbG9nZ2VyJztcclxuaW1wb3J0IHsgYXVkaXRTZXJ2aWNlIH0gZnJvbSAnQC9zZWN1cml0eS9hdWRpdC1zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZm9yIHNlcnZpY2UgY29uZmlndXJhdGlvblxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlQ29uZmlnIHtcclxuICAvKiogU2VydmljZSBuYW1lICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKiBTZXJ2aWNlIGRlc2NyaXB0aW9uICovXHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICAvKiogRXhlY3V0YWJsZSBwYXRoICovXHJcbiAgZXhlY1BhdGg6IHN0cmluZztcclxuICAvKiogV29ya2luZyBkaXJlY3RvcnkgKi9cclxuICB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmc7XHJcbiAgLyoqIEVudmlyb25tZW50IHZhcmlhYmxlcyAqL1xyXG4gIGVudmlyb25tZW50OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xyXG4gIC8qKiBVc2VyIHRvIHJ1biBzZXJ2aWNlIGFzICovXHJcbiAgdXNlcjogc3RyaW5nO1xyXG4gIC8qKiBHcm91cCB0byBydW4gc2VydmljZSBhcyAqL1xyXG4gIGdyb3VwOiBzdHJpbmc7XHJcbiAgLyoqIFJlc3RhcnQgcG9saWN5ICovXHJcbiAgcmVzdGFydFBvbGljeTogJ2Fsd2F5cycgfCAnb24tZmFpbHVyZScgfCAnb24tYWJub3JtYWwnIHwgJ29uLXdhdGNoZG9nJyB8ICdvbi1hYm9ydCcgfCAnbmV2ZXInO1xyXG4gIC8qKiBSZXN0YXJ0IGRlbGF5IGluIHNlY29uZHMgKi9cclxuICByZXN0YXJ0RGVsYXk6IG51bWJlcjtcclxuICAvKiogTWF4aW11bSByZXN0YXJ0IGF0dGVtcHRzICovXHJcbiAgbWF4UmVzdGFydEF0dGVtcHRzOiBudW1iZXI7XHJcbiAgLyoqIERlcGVuZGVuY2llcyAqL1xyXG4gIGRlcGVuZGVuY2llczogc3RyaW5nW107XHJcbiAgLyoqIFJlcXVpcmVkIHNlcnZpY2VzICovXHJcbiAgcmVxdWlyZXM6IHN0cmluZ1tdO1xyXG4gIC8qKiBTZXJ2aWNlcyB0byBzdGFydCBhZnRlciAqL1xyXG4gIGFmdGVyOiBzdHJpbmdbXTtcclxuICAvKiogU2VydmljZXMgdG8gc3RhcnQgYmVmb3JlICovXHJcbiAgYmVmb3JlOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVyZmFjZSBmb3IgZmFpbHVyZSBkZXRlY3Rpb24gY29uZmlndXJhdGlvblxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBGYWlsdXJlRGV0ZWN0aW9uQ29uZmlnIHtcclxuICAvKiogRW5hYmxlIGhlYWx0aCBjaGVjayBtb25pdG9yaW5nICovXHJcbiAgZW5hYmxlSGVhbHRoQ2hlY2s6IGJvb2xlYW47XHJcbiAgLyoqIEhlYWx0aCBjaGVjayBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgKi9cclxuICBoZWFsdGhDaGVja0ludGVydmFsOiBudW1iZXI7XHJcbiAgLyoqIEhlYWx0aCBjaGVjayB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyAqL1xyXG4gIGhlYWx0aENoZWNrVGltZW91dDogbnVtYmVyO1xyXG4gIC8qKiBNYXhpbXVtIGNvbnNlY3V0aXZlIGZhaWx1cmVzIGJlZm9yZSByZXN0YXJ0ICovXHJcbiAgbWF4Q29uc2VjdXRpdmVGYWlsdXJlczogbnVtYmVyO1xyXG4gIC8qKiBFbmFibGUgcHJvY2VzcyBtb25pdG9yaW5nICovXHJcbiAgZW5hYmxlUHJvY2Vzc01vbml0b3Jpbmc6IGJvb2xlYW47XHJcbiAgLyoqIEVuYWJsZSByZXNvdXJjZSBtb25pdG9yaW5nICovXHJcbiAgZW5hYmxlUmVzb3VyY2VNb25pdG9yaW5nOiBib29sZWFuO1xyXG4gIC8qKiBNZW1vcnkgdXNhZ2UgdGhyZXNob2xkIGZvciByZXN0YXJ0IChwZXJjZW50YWdlKSAqL1xyXG4gIG1lbW9yeVRocmVzaG9sZDogbnVtYmVyO1xyXG4gIC8qKiBDUFUgdXNhZ2UgdGhyZXNob2xkIGZvciByZXN0YXJ0IChwZXJjZW50YWdlKSAqL1xyXG4gIGNwdVRocmVzaG9sZDogbnVtYmVyO1xyXG4gIC8qKiBFbmFibGUgbG9nIG1vbml0b3JpbmcgKi9cclxuICBlbmFibGVMb2dNb25pdG9yaW5nOiBib29sZWFuO1xyXG4gIC8qKiBFcnJvciBwYXR0ZXJucyB0byBtb25pdG9yIGluIGxvZ3MgKi9cclxuICBlcnJvclBhdHRlcm5zOiBzdHJpbmdbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVyZmFjZSBmb3IgcmVjb3Zlcnkgc3RhdHVzXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5U3RhdHVzIHtcclxuICAvKiogU2VydmljZSBuYW1lICovXHJcbiAgc2VydmljZU5hbWU6IHN0cmluZztcclxuICAvKiogQ3VycmVudCBzdGF0dXMgKi9cclxuICBzdGF0dXM6ICdydW5uaW5nJyB8ICdzdG9wcGVkJyB8ICdmYWlsZWQnIHwgJ3Jlc3RhcnRpbmcnIHwgJ3Vua25vd24nO1xyXG4gIC8qKiBMYXN0IHJlc3RhcnQgdGltZSAqL1xyXG4gIGxhc3RSZXN0YXJ0OiBEYXRlIHwgbnVsbDtcclxuICAvKiogUmVzdGFydCBjb3VudCAqL1xyXG4gIHJlc3RhcnRDb3VudDogbnVtYmVyO1xyXG4gIC8qKiBDb25zZWN1dGl2ZSBmYWlsdXJlIGNvdW50ICovXHJcbiAgY29uc2VjdXRpdmVGYWlsdXJlczogbnVtYmVyO1xyXG4gIC8qKiBMYXN0IGZhaWx1cmUgcmVhc29uICovXHJcbiAgbGFzdEZhaWx1cmVSZWFzb246IHN0cmluZyB8IG51bGw7XHJcbiAgLyoqIFJlY292ZXJ5IGFjdGlvbnMgdGFrZW4gKi9cclxuICByZWNvdmVyeUFjdGlvbnM6IHN0cmluZ1tdO1xyXG4gIC8qKiBIZWFsdGggY2hlY2sgc3RhdHVzICovXHJcbiAgaGVhbHRoU3RhdHVzOiAnaGVhbHRoeScgfCAndW5oZWFsdGh5JyB8ICd1bmtub3duJztcclxuICAvKiogTGFzdCBoZWFsdGggY2hlY2sgKi9cclxuICBsYXN0SGVhbHRoQ2hlY2s6IERhdGUgfCBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJmYWNlIGZvciBncmFjZWZ1bCBzaHV0ZG93biBjb25maWd1cmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNodXRkb3duQ29uZmlnIHtcclxuICAvKiogU2h1dGRvd24gdGltZW91dCBpbiBtaWxsaXNlY29uZHMgKi9cclxuICB0aW1lb3V0OiBudW1iZXI7XHJcbiAgLyoqIEVuYWJsZSBwb3NpdGlvbiBjbG9zdXJlIGJlZm9yZSBzaHV0ZG93biAqL1xyXG4gIGNsb3NlUG9zaXRpb25zOiBib29sZWFuO1xyXG4gIC8qKiBFbmFibGUgZGF0YSBiYWNrdXAgYmVmb3JlIHNodXRkb3duICovXHJcbiAgYmFja3VwRGF0YTogYm9vbGVhbjtcclxuICAvKiogRW5hYmxlIG5vdGlmaWNhdGlvbiBzZW5kaW5nICovXHJcbiAgc2VuZE5vdGlmaWNhdGlvbnM6IGJvb2xlYW47XHJcbiAgLyoqIFNodXRkb3duIGhvb2tzIHRvIGV4ZWN1dGUgKi9cclxuICBzaHV0ZG93bkhvb2tzOiBBcnJheTwoKSA9PiBQcm9taXNlPHZvaWQ+PjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEF1dG8tUmVzdGFydCBhbmQgUmVjb3ZlcnkgTWFuYWdlclxyXG4gKiBQcm92aWRlcyBjb21wcmVoZW5zaXZlIHN5c3RlbSByZWNvdmVyeSBhbmQgcmVzdGFydCBjYXBhYmlsaXRpZXNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBdXRvUmVzdGFydE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gIHByaXZhdGUgc2VydmljZXM6IE1hcDxzdHJpbmcsIFNlcnZpY2VDb25maWc+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgcmVjb3ZlcnlTdGF0dXM6IE1hcDxzdHJpbmcsIFJlY292ZXJ5U3RhdHVzPiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIGZhaWx1cmVEZXRlY3Rpb25Db25maWc6IEZhaWx1cmVEZXRlY3Rpb25Db25maWc7XHJcbiAgcHJpdmF0ZSBzaHV0ZG93bkNvbmZpZzogU2h1dGRvd25Db25maWc7XHJcbiAgcHJpdmF0ZSBtb25pdG9yaW5nSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBpc1NodXR0aW5nRG93bjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHByaXZhdGUgaGVhbHRoQ2hlY2tJbnRlcnZhbHM6IE1hcDxzdHJpbmcsIE5vZGVKUy5UaW1lb3V0PiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5mYWlsdXJlRGV0ZWN0aW9uQ29uZmlnID0gdGhpcy5sb2FkRmFpbHVyZURldGVjdGlvbkNvbmZpZygpO1xyXG4gICAgdGhpcy5zaHV0ZG93bkNvbmZpZyA9IHRoaXMubG9hZFNodXRkb3duQ29uZmlnKCk7XHJcbiAgICBsb2dnZXIuaW5mbygn8J+UhCBBdXRvLVJlc3RhcnQgTWFuYWdlciBpbml0aWFsaXppbmcuLi4nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWQgZmFpbHVyZSBkZXRlY3Rpb24gY29uZmlndXJhdGlvblxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIEZhaWx1cmVEZXRlY3Rpb25Db25maWcgQ29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgKi9cclxuICBwcml2YXRlIGxvYWRGYWlsdXJlRGV0ZWN0aW9uQ29uZmlnKCk6IEZhaWx1cmVEZXRlY3Rpb25Db25maWcge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZW5hYmxlSGVhbHRoQ2hlY2s6IHByb2Nlc3MuZW52LkVOQUJMRV9IRUFMVEhfQ0hFQ0sgIT09ICdmYWxzZScsXHJcbiAgICAgIGhlYWx0aENoZWNrSW50ZXJ2YWw6IHBhcnNlSW50KHByb2Nlc3MuZW52LkhFQUxUSF9DSEVDS19JTlRFUlZBTF9NUyB8fCAnMzAwMDAnKSxcclxuICAgICAgaGVhbHRoQ2hlY2tUaW1lb3V0OiBwYXJzZUludChwcm9jZXNzLmVudi5IRUFMVEhfQ0hFQ0tfVElNRU9VVF9NUyB8fCAnNTAwMCcpLFxyXG4gICAgICBtYXhDb25zZWN1dGl2ZUZhaWx1cmVzOiBwYXJzZUludChwcm9jZXNzLmVudi5NQVhfQ09OU0VDVVRJVkVfRkFJTFVSRVMgfHwgJzMnKSxcclxuICAgICAgZW5hYmxlUHJvY2Vzc01vbml0b3Jpbmc6IHByb2Nlc3MuZW52LkVOQUJMRV9QUk9DRVNTX01PTklUT1JJTkcgIT09ICdmYWxzZScsXHJcbiAgICAgIGVuYWJsZVJlc291cmNlTW9uaXRvcmluZzogcHJvY2Vzcy5lbnYuRU5BQkxFX1JFU09VUkNFX01PTklUT1JJTkcgIT09ICdmYWxzZScsXHJcbiAgICAgIG1lbW9yeVRocmVzaG9sZDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuTUVNT1JZX1JFU1RBUlRfVEhSRVNIT0xEIHx8ICc5MCcpLFxyXG4gICAgICBjcHVUaHJlc2hvbGQ6IHBhcnNlSW50KHByb2Nlc3MuZW52LkNQVV9SRVNUQVJUX1RIUkVTSE9MRCB8fCAnOTUnKSxcclxuICAgICAgZW5hYmxlTG9nTW9uaXRvcmluZzogcHJvY2Vzcy5lbnYuRU5BQkxFX0xPR19NT05JVE9SSU5HICE9PSAnZmFsc2UnLFxyXG4gICAgICBlcnJvclBhdHRlcm5zOiAocHJvY2Vzcy5lbnYuRVJST1JfUEFUVEVSTlMgfHwgJ0ZBVEFMLENSSVRJQ0FMLE91dE9mTWVtb3J5RXJyb3InKS5zcGxpdCgnLCcpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCBncmFjZWZ1bCBzaHV0ZG93biBjb25maWd1cmF0aW9uXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgU2h1dGRvd25Db25maWcgQ29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgKi9cclxuICBwcml2YXRlIGxvYWRTaHV0ZG93bkNvbmZpZygpOiBTaHV0ZG93bkNvbmZpZyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0aW1lb3V0OiBwYXJzZUludChwcm9jZXNzLmVudi5TSFVURE9XTl9USU1FT1VUX01TIHx8ICczMDAwMCcpLFxyXG4gICAgICBjbG9zZVBvc2l0aW9uczogcHJvY2Vzcy5lbnYuU0hVVERPV05fQ0xPU0VfUE9TSVRJT05TICE9PSAnZmFsc2UnLFxyXG4gICAgICBiYWNrdXBEYXRhOiBwcm9jZXNzLmVudi5TSFVURE9XTl9CQUNLVVBfREFUQSAhPT0gJ2ZhbHNlJyxcclxuICAgICAgc2VuZE5vdGlmaWNhdGlvbnM6IHByb2Nlc3MuZW52LlNIVVRET1dOX1NFTkRfTk9USUZJQ0FUSU9OUyAhPT0gJ2ZhbHNlJyxcclxuICAgICAgc2h1dGRvd25Ib29rczogW11cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGF1dG8tcmVzdGFydCBhbmQgcmVjb3Zlcnkgc3lzdGVtXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9nZ2VyLmluZm8oJ/CflIQgSW5pdGlhbGl6aW5nIGF1dG8tcmVzdGFydCBhbmQgcmVjb3Zlcnkgc3lzdGVtLi4uJyk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgbWFpbiB0cmFkaW5nIHNlcnZpY2UgY29uZmlndXJhdGlvblxyXG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZVRyYWRpbmdTZXJ2aWNlQ29uZmlnKCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgc3VwcG9ydGluZyBzZXJ2aWNlIGNvbmZpZ3VyYXRpb25zXHJcbiAgICAgIGF3YWl0IHRoaXMuY3JlYXRlU3VwcG9ydGluZ1NlcnZpY2VDb25maWdzKCk7XHJcblxyXG4gICAgICAvLyBHZW5lcmF0ZSBzeXN0ZW1kIHNlcnZpY2UgZmlsZXNcclxuICAgICAgYXdhaXQgdGhpcy5nZW5lcmF0ZVN5c3RlbWRTZXJ2aWNlRmlsZXMoKTtcclxuXHJcbiAgICAgIC8vIFN0YXJ0IGZhaWx1cmUgZGV0ZWN0aW9uIG1vbml0b3JpbmdcclxuICAgICAgYXdhaXQgdGhpcy5zdGFydEZhaWx1cmVEZXRlY3Rpb24oKTtcclxuXHJcbiAgICAgIC8vIFNldCB1cCBncmFjZWZ1bCBzaHV0ZG93biBoYW5kbGVyc1xyXG4gICAgICB0aGlzLnNldHVwR3JhY2VmdWxTaHV0ZG93bkhhbmRsZXJzKCk7XHJcblxyXG4gICAgICBsb2dnZXIuaW5mbygn4pyFIEF1dG8tcmVzdGFydCBhbmQgcmVjb3Zlcnkgc3lzdGVtIGluaXRpYWxpemVkJyk7XHJcblxyXG4gICAgICAvLyBBdWRpdCBsb2dcclxuICAgICAgYXdhaXQgYXVkaXRTZXJ2aWNlLmNyZWF0ZUF1ZGl0RW50cnkoe1xyXG4gICAgICAgIGF1ZGl0SWQ6IGByZXN0YXJ0X21ncl9pbml0XyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgIGV2ZW50VHlwZTogJ0FVVE9fUkVTVEFSVF9NQU5BR0VSX0lOSVQnLFxyXG4gICAgICAgIGFjdG9yOiAnU1lTVEVNJyxcclxuICAgICAgICByZXNvdXJjZTogJ0FVVE9fUkVTVEFSVF9NQU5BR0VSJyxcclxuICAgICAgICBhY3Rpb246ICdJTklUSUFMSVpFJyxcclxuICAgICAgICByZXN1bHQ6ICdTVUNDRVNTJyxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgYXVkaXREYXRhOiB7IFxyXG4gICAgICAgICAgc2VydmljZXNDb3VudDogdGhpcy5zZXJ2aWNlcy5zaXplLFxyXG4gICAgICAgICAgZmFpbHVyZURldGVjdGlvbkVuYWJsZWQ6IHRoaXMuZmFpbHVyZURldGVjdGlvbkNvbmZpZy5lbmFibGVIZWFsdGhDaGVja1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKCfinYwgRmFpbGVkIHRvIGluaXRpYWxpemUgYXV0by1yZXN0YXJ0IHN5c3RlbTonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXV0by1yZXN0YXJ0IHN5c3RlbSBpbml0aWFsaXphdGlvbiBmYWlsZWQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBtYWluIHRyYWRpbmcgc2VydmljZSBjb25maWd1cmF0aW9uXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlVHJhZGluZ1NlcnZpY2VDb25maWcoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0cmFkaW5nU2VydmljZUNvbmZpZzogU2VydmljZUNvbmZpZyA9IHtcclxuICAgICAgbmFtZTogJ2FpLWNyeXB0by10cmFkaW5nLWFnZW50JyxcclxuICAgICAgZGVzY3JpcHRpb246ICdBSSBDcnlwdG9jdXJyZW5jeSBUcmFkaW5nIEFnZW50IC0gTWFpbiBTZXJ2aWNlJyxcclxuICAgICAgZXhlY1BhdGg6ICcvdXNyL2Jpbi9ub2RlJyxcclxuICAgICAgd29ya2luZ0RpcmVjdG9yeTogcHJvY2Vzcy5jd2QoKSxcclxuICAgICAgZW52aXJvbm1lbnQ6IHtcclxuICAgICAgICBOT0RFX0VOVjogJ3Byb2R1Y3Rpb24nLFxyXG4gICAgICAgIE5PREVfT1BUSU9OUzogJy0tbWF4LW9sZC1zcGFjZS1zaXplPTgxOTInLFxyXG4gICAgICAgIFBBVEg6ICcvdXNyL2xvY2FsL2JpbjovdXNyL2JpbjovYmluJ1xyXG4gICAgICB9LFxyXG4gICAgICB1c2VyOiBwcm9jZXNzLmVudi5TRVJWSUNFX1VTRVIgfHwgJ3RyYWRpbmcnLFxyXG4gICAgICBncm91cDogcHJvY2Vzcy5lbnYuU0VSVklDRV9HUk9VUCB8fCAndHJhZGluZycsXHJcbiAgICAgIHJlc3RhcnRQb2xpY3k6ICdhbHdheXMnLFxyXG4gICAgICByZXN0YXJ0RGVsYXk6IDEwLFxyXG4gICAgICBtYXhSZXN0YXJ0QXR0ZW1wdHM6IDUsXHJcbiAgICAgIGRlcGVuZGVuY2llczogWyduZXR3b3JrLnRhcmdldCcsICdzc2gtdHVubmVsLnNlcnZpY2UnXSxcclxuICAgICAgcmVxdWlyZXM6IFsnbmV0d29yay50YXJnZXQnXSxcclxuICAgICAgYWZ0ZXI6IFsnbmV0d29yay50YXJnZXQnLCAnc3NoLXR1bm5lbC5zZXJ2aWNlJywgJ3N5c3RlbS1tb25pdG9yLnNlcnZpY2UnXSxcclxuICAgICAgYmVmb3JlOiBbXVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNlcnZpY2VzLnNldCh0cmFkaW5nU2VydmljZUNvbmZpZy5uYW1lLCB0cmFkaW5nU2VydmljZUNvbmZpZyk7XHJcbiAgICB0aGlzLmluaXRpYWxpemVSZWNvdmVyeVN0YXR1cyh0cmFkaW5nU2VydmljZUNvbmZpZy5uYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBzdXBwb3J0aW5nIHNlcnZpY2UgY29uZmlndXJhdGlvbnNcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVTdXBwb3J0aW5nU2VydmljZUNvbmZpZ3MoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBTU0ggVHVubmVsIFNlcnZpY2VcclxuICAgIGNvbnN0IHNzaFR1bm5lbENvbmZpZzogU2VydmljZUNvbmZpZyA9IHtcclxuICAgICAgbmFtZTogJ3NzaC10dW5uZWwnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1NTSCBUdW5uZWwgdG8gT3JhY2xlIEZyZWUgVGllcicsXHJcbiAgICAgIGV4ZWNQYXRoOiAnL3Vzci9iaW4vc3NoJyxcclxuICAgICAgd29ya2luZ0RpcmVjdG9yeTogJy9ob21lL3RyYWRpbmcnLFxyXG4gICAgICBlbnZpcm9ubWVudDoge1xyXG4gICAgICAgIFNTSF9BVVRIX1NPQ0s6ICcnLFxyXG4gICAgICAgIFBBVEg6ICcvdXNyL2xvY2FsL2JpbjovdXNyL2JpbjovYmluJ1xyXG4gICAgICB9LFxyXG4gICAgICB1c2VyOiAndHJhZGluZycsXHJcbiAgICAgIGdyb3VwOiAndHJhZGluZycsXHJcbiAgICAgIHJlc3RhcnRQb2xpY3k6ICdhbHdheXMnLFxyXG4gICAgICByZXN0YXJ0RGVsYXk6IDUsXHJcbiAgICAgIG1heFJlc3RhcnRBdHRlbXB0czogMTAsXHJcbiAgICAgIGRlcGVuZGVuY2llczogWyduZXR3b3JrLnRhcmdldCddLFxyXG4gICAgICByZXF1aXJlczogWyduZXR3b3JrLnRhcmdldCddLFxyXG4gICAgICBhZnRlcjogWyduZXR3b3JrLnRhcmdldCddLFxyXG4gICAgICBiZWZvcmU6IFsnYWktY3J5cHRvLXRyYWRpbmctYWdlbnQuc2VydmljZSddXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN5c3RlbSBNb25pdG9yIFNlcnZpY2VcclxuICAgIGNvbnN0IHN5c3RlbU1vbml0b3JDb25maWc6IFNlcnZpY2VDb25maWcgPSB7XHJcbiAgICAgIG5hbWU6ICdzeXN0ZW0tbW9uaXRvcicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnSW50ZWwgTlVDIFN5c3RlbSBNb25pdG9yJyxcclxuICAgICAgZXhlY1BhdGg6ICcvdXNyL2Jpbi9ub2RlJyxcclxuICAgICAgd29ya2luZ0RpcmVjdG9yeTogcHJvY2Vzcy5jd2QoKSxcclxuICAgICAgZW52aXJvbm1lbnQ6IHtcclxuICAgICAgICBOT0RFX0VOVjogJ3Byb2R1Y3Rpb24nLFxyXG4gICAgICAgIFBBVEg6ICcvdXNyL2xvY2FsL2JpbjovdXNyL2JpbjovYmluJ1xyXG4gICAgICB9LFxyXG4gICAgICB1c2VyOiAndHJhZGluZycsXHJcbiAgICAgIGdyb3VwOiAndHJhZGluZycsXHJcbiAgICAgIHJlc3RhcnRQb2xpY3k6ICdhbHdheXMnLFxyXG4gICAgICByZXN0YXJ0RGVsYXk6IDUsXHJcbiAgICAgIG1heFJlc3RhcnRBdHRlbXB0czogMyxcclxuICAgICAgZGVwZW5kZW5jaWVzOiBbJ25ldHdvcmsudGFyZ2V0J10sXHJcbiAgICAgIHJlcXVpcmVzOiBbXSxcclxuICAgICAgYWZ0ZXI6IFsnbmV0d29yay50YXJnZXQnXSxcclxuICAgICAgYmVmb3JlOiBbJ2FpLWNyeXB0by10cmFkaW5nLWFnZW50LnNlcnZpY2UnXVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNlcnZpY2VzLnNldChzc2hUdW5uZWxDb25maWcubmFtZSwgc3NoVHVubmVsQ29uZmlnKTtcclxuICAgIHRoaXMuc2VydmljZXMuc2V0KHN5c3RlbU1vbml0b3JDb25maWcubmFtZSwgc3lzdGVtTW9uaXRvckNvbmZpZyk7XHJcblxyXG4gICAgdGhpcy5pbml0aWFsaXplUmVjb3ZlcnlTdGF0dXMoc3NoVHVubmVsQ29uZmlnLm5hbWUpO1xyXG4gICAgdGhpcy5pbml0aWFsaXplUmVjb3ZlcnlTdGF0dXMoc3lzdGVtTW9uaXRvckNvbmZpZy5uYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgcmVjb3Zlcnkgc3RhdHVzIGZvciBhIHNlcnZpY2VcclxuICAgKiBcclxuICAgKiBAcGFyYW0gc2VydmljZU5hbWUgU2VydmljZSBuYW1lXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpbml0aWFsaXplUmVjb3ZlcnlTdGF0dXMoc2VydmljZU5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5yZWNvdmVyeVN0YXR1cy5zZXQoc2VydmljZU5hbWUsIHtcclxuICAgICAgc2VydmljZU5hbWUsXHJcbiAgICAgIHN0YXR1czogJ3Vua25vd24nLFxyXG4gICAgICBsYXN0UmVzdGFydDogbnVsbCxcclxuICAgICAgcmVzdGFydENvdW50OiAwLFxyXG4gICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzOiAwLFxyXG4gICAgICBsYXN0RmFpbHVyZVJlYXNvbjogbnVsbCxcclxuICAgICAgcmVjb3ZlcnlBY3Rpb25zOiBbXSxcclxuICAgICAgaGVhbHRoU3RhdHVzOiAndW5rbm93bicsXHJcbiAgICAgIGxhc3RIZWFsdGhDaGVjazogbnVsbFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBzeXN0ZW1kIHNlcnZpY2UgZmlsZXNcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVN5c3RlbWRTZXJ2aWNlRmlsZXMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBsb2dnZXIuaW5mbygn8J+TnSBHZW5lcmF0aW5nIHN5c3RlbWQgc2VydmljZSBmaWxlcy4uLicpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBbc2VydmljZU5hbWUsIGNvbmZpZ10gb2YgdGhpcy5zZXJ2aWNlcykge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VGaWxlQ29udGVudCA9IHRoaXMuZ2VuZXJhdGVTZXJ2aWNlRmlsZUNvbnRlbnQoY29uZmlnKTtcclxuICAgICAgICBjb25zdCBzZXJ2aWNlRmlsZVBhdGggPSBgL2V0Yy9zeXN0ZW1kL3N5c3RlbS8ke3NlcnZpY2VOYW1lfS5zZXJ2aWNlYDtcclxuXHJcbiAgICAgICAgLy8gV3JpdGUgc2VydmljZSBmaWxlICh3b3VsZCBuZWVkIHN1ZG8gcGVybWlzc2lvbnMpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHsgd3JpdGVGaWxlU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdmcycpO1xyXG4gICAgICAgICAgY29uc3QgeyBleGVjU3luYyB9ID0gYXdhaXQgaW1wb3J0KCdjaGlsZF9wcm9jZXNzJyk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIHRlbXBvcmFyeSBmaWxlIGZpcnN0XHJcbiAgICAgICAgICBjb25zdCB0ZW1wUGF0aCA9IGAvdG1wLyR7c2VydmljZU5hbWV9LnNlcnZpY2VgO1xyXG4gICAgICAgICAgd3JpdGVGaWxlU3luYyh0ZW1wUGF0aCwgc2VydmljZUZpbGVDb250ZW50KTtcclxuXHJcbiAgICAgICAgICAvLyBNb3ZlIHRvIHN5c3RlbWQgZGlyZWN0b3J5IHdpdGggc3Vkb1xyXG4gICAgICAgICAgZXhlY1N5bmMoYHN1ZG8gbXYgJHt0ZW1wUGF0aH0gJHtzZXJ2aWNlRmlsZVBhdGh9YCwgeyBzdGRpbzogJ3BpcGUnIH0pO1xyXG4gICAgICAgICAgZXhlY1N5bmMoYHN1ZG8gY2htb2QgNjQ0ICR7c2VydmljZUZpbGVQYXRofWAsIHsgc3RkaW86ICdwaXBlJyB9KTtcclxuXHJcbiAgICAgICAgICBsb2dnZXIuaW5mbyhg4pyFIENyZWF0ZWQgc2VydmljZSBmaWxlOiAke3NlcnZpY2VGaWxlUGF0aH1gKTtcclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGxvZ2dlci53YXJuKGDimqDvuI8gQ291bGQgbm90IGNyZWF0ZSBzZXJ2aWNlIGZpbGUgZm9yICR7c2VydmljZU5hbWV9OmAsIGVycm9yKTtcclxuICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgc2VydmljZXNcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbG9hZCBzeXN0ZW1kIGRhZW1vblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZXhlY1N5bmMgfSA9IGF3YWl0IGltcG9ydCgnY2hpbGRfcHJvY2VzcycpO1xyXG4gICAgICAgIGV4ZWNTeW5jKCdzdWRvIHN5c3RlbWN0bCBkYWVtb24tcmVsb2FkJywgeyBzdGRpbzogJ3BpcGUnIH0pO1xyXG4gICAgICAgIGxvZ2dlci5pbmZvKCfinIUgU3lzdGVtZCBkYWVtb24gcmVsb2FkZWQnKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsb2dnZXIud2Fybign4pqg77iPIENvdWxkIG5vdCByZWxvYWQgc3lzdGVtZCBkYWVtb246JywgZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKCfinYwgRmFpbGVkIHRvIGdlbmVyYXRlIHN5c3RlbWQgc2VydmljZSBmaWxlczonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBzeXN0ZW1kIHNlcnZpY2UgZmlsZSBjb250ZW50XHJcbiAgICogXHJcbiAgICogQHBhcmFtIGNvbmZpZyBTZXJ2aWNlIGNvbmZpZ3VyYXRpb25cclxuICAgKiBAcmV0dXJucyBzdHJpbmcgU2VydmljZSBmaWxlIGNvbnRlbnRcclxuICAgKi9cclxuICBwcml2YXRlIGdlbmVyYXRlU2VydmljZUZpbGVDb250ZW50KGNvbmZpZzogU2VydmljZUNvbmZpZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBlbnZpcm9ubWVudFZhcnMgPSBPYmplY3QuZW50cmllcyhjb25maWcuZW52aXJvbm1lbnQpXHJcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYEVudmlyb25tZW50PSR7a2V5fT0ke3ZhbHVlfWApXHJcbiAgICAgIC5qb2luKCdcXG4nKTtcclxuXHJcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBjb25maWcuZGVwZW5kZW5jaWVzLmxlbmd0aCA+IDAgXHJcbiAgICAgID8gYFdhbnRzPSR7Y29uZmlnLmRlcGVuZGVuY2llcy5qb2luKCcgJyl9XFxuYCBcclxuICAgICAgOiAnJztcclxuXHJcbiAgICBjb25zdCByZXF1aXJlcyA9IGNvbmZpZy5yZXF1aXJlcy5sZW5ndGggPiAwIFxyXG4gICAgICA/IGBSZXF1aXJlcz0ke2NvbmZpZy5yZXF1aXJlcy5qb2luKCcgJyl9XFxuYCBcclxuICAgICAgOiAnJztcclxuXHJcbiAgICBjb25zdCBhZnRlciA9IGNvbmZpZy5hZnRlci5sZW5ndGggPiAwIFxyXG4gICAgICA/IGBBZnRlcj0ke2NvbmZpZy5hZnRlci5qb2luKCcgJyl9XFxuYCBcclxuICAgICAgOiAnJztcclxuXHJcbiAgICBjb25zdCBiZWZvcmUgPSBjb25maWcuYmVmb3JlLmxlbmd0aCA+IDAgXHJcbiAgICAgID8gYEJlZm9yZT0ke2NvbmZpZy5iZWZvcmUuam9pbignICcpfVxcbmAgXHJcbiAgICAgIDogJyc7XHJcblxyXG4gICAgcmV0dXJuIGBbVW5pdF1cclxuRGVzY3JpcHRpb249JHtjb25maWcuZGVzY3JpcHRpb259XHJcbiR7ZGVwZW5kZW5jaWVzfSR7cmVxdWlyZXN9JHthZnRlcn0ke2JlZm9yZX1cclxuXHJcbltTZXJ2aWNlXVxyXG5UeXBlPXNpbXBsZVxyXG5Vc2VyPSR7Y29uZmlnLnVzZXJ9XHJcbkdyb3VwPSR7Y29uZmlnLmdyb3VwfVxyXG5Xb3JraW5nRGlyZWN0b3J5PSR7Y29uZmlnLndvcmtpbmdEaXJlY3Rvcnl9XHJcbkV4ZWNTdGFydD0ke3RoaXMuZ2VuZXJhdGVFeGVjU3RhcnQoY29uZmlnKX1cclxuUmVzdGFydD0ke2NvbmZpZy5yZXN0YXJ0UG9saWN5fVxyXG5SZXN0YXJ0U2VjPSR7Y29uZmlnLnJlc3RhcnREZWxheX1cclxuU3RhcnRMaW1pdEJ1cnN0PSR7Y29uZmlnLm1heFJlc3RhcnRBdHRlbXB0c31cclxuU3RhcnRMaW1pdEludGVydmFsU2VjPTMwMFxyXG4ke2Vudmlyb25tZW50VmFyc31cclxuXHJcbiMgU2VjdXJpdHkgc2V0dGluZ3NcclxuTm9OZXdQcml2aWxlZ2VzPXRydWVcclxuUHJvdGVjdFN5c3RlbT1zdHJpY3RcclxuUHJvdGVjdEhvbWU9dHJ1ZVxyXG5SZWFkV3JpdGVQYXRocz0ke2NvbmZpZy53b3JraW5nRGlyZWN0b3J5fVxyXG5Qcml2YXRlVG1wPXRydWVcclxuXHJcbiMgUmVzb3VyY2UgbGltaXRzXHJcbkxpbWl0Tk9GSUxFPTY1NTM2XHJcbkxpbWl0TlBST0M9NDA5NlxyXG5cclxuW0luc3RhbGxdXHJcbldhbnRlZEJ5PW11bHRpLXVzZXIudGFyZ2V0XHJcbmA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBFeGVjU3RhcnQgY29tbWFuZCBmb3Igc2VydmljZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBjb25maWcgU2VydmljZSBjb25maWd1cmF0aW9uXHJcbiAgICogQHJldHVybnMgc3RyaW5nIEV4ZWNTdGFydCBjb21tYW5kXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZUV4ZWNTdGFydChjb25maWc6IFNlcnZpY2VDb25maWcpOiBzdHJpbmcge1xyXG4gICAgc3dpdGNoIChjb25maWcubmFtZSkge1xyXG4gICAgICBjYXNlICdhaS1jcnlwdG8tdHJhZGluZy1hZ2VudCc6XHJcbiAgICAgICAgcmV0dXJuIGAke2NvbmZpZy5leGVjUGF0aH0gJHtjb25maWcud29ya2luZ0RpcmVjdG9yeX0vZGlzdC9pbmRleC5qc2A7XHJcbiAgICAgIFxyXG4gICAgICBjYXNlICdzc2gtdHVubmVsJzpcclxuICAgICAgICBjb25zdCBvcmFjbGVJUCA9IHByb2Nlc3MuZW52Lk9SQUNMRV9JUCB8fCAnMTY4LjEzOC4xMDQuMTE3JztcclxuICAgICAgICBjb25zdCBzc2hVc2VyID0gcHJvY2Vzcy5lbnYuU1NIX1VTRVIgfHwgJ3VidW50dSc7XHJcbiAgICAgICAgY29uc3Qgc3NoS2V5ID0gcHJvY2Vzcy5lbnYuU1NIX0tFWV9QQVRIIHx8ICcvaG9tZS90cmFkaW5nLy5zc2gvaWRfcnNhJztcclxuICAgICAgICBjb25zdCBsb2NhbFBvcnQgPSBwcm9jZXNzLmVudi5MT0NBTF9UVU5ORUxfUE9SVCB8fCAnODA4MCc7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlUG9ydCA9IHByb2Nlc3MuZW52LlJFTU9URV9UVU5ORUxfUE9SVCB8fCAnODAnO1xyXG4gICAgICAgIHJldHVybiBgJHtjb25maWcuZXhlY1BhdGh9IC1OIC1MICR7bG9jYWxQb3J0fTpsb2NhbGhvc3Q6JHtyZW1vdGVQb3J0fSAtaSAke3NzaEtleX0gJHtzc2hVc2VyfUAke29yYWNsZUlQfWA7XHJcbiAgICAgIFxyXG4gICAgICBjYXNlICdzeXN0ZW0tbW9uaXRvcic6XHJcbiAgICAgICAgcmV0dXJuIGAke2NvbmZpZy5leGVjUGF0aH0gJHtjb25maWcud29ya2luZ0RpcmVjdG9yeX0vZGlzdC9zY3JpcHRzL3N5c3RlbS1tb25pdG9yLmpzYDtcclxuICAgICAgXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGAke2NvbmZpZy5leGVjUGF0aH0gJHtjb25maWcud29ya2luZ0RpcmVjdG9yeX0vZGlzdC9pbmRleC5qc2A7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBmYWlsdXJlIGRldGVjdGlvbiBtb25pdG9yaW5nXHJcbiAgICogXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgc3RhcnRGYWlsdXJlRGV0ZWN0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9nZ2VyLmluZm8oJ/CflI0gU3RhcnRpbmcgZmFpbHVyZSBkZXRlY3Rpb24gbW9uaXRvcmluZy4uLicpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZmFpbHVyZURldGVjdGlvbkNvbmZpZy5lbmFibGVIZWFsdGhDaGVjaykge1xyXG4gICAgICAgIC8vIFN0YXJ0IGhlYWx0aCBjaGVja3MgZm9yIGVhY2ggc2VydmljZVxyXG4gICAgICAgIGZvciAoY29uc3Qgc2VydmljZU5hbWUgb2YgdGhpcy5zZXJ2aWNlcy5rZXlzKCkpIHtcclxuICAgICAgICAgIHRoaXMuc3RhcnRIZWFsdGhDaGVjayhzZXJ2aWNlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdGFydCBnZW5lcmFsIG1vbml0b3JpbmdcclxuICAgICAgdGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucGVyZm9ybUZhaWx1cmVEZXRlY3Rpb24oKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCfinYwgRmFpbHVyZSBkZXRlY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgdGhpcy5mYWlsdXJlRGV0ZWN0aW9uQ29uZmlnLmhlYWx0aENoZWNrSW50ZXJ2YWwpO1xyXG5cclxuICAgICAgbG9nZ2VyLmluZm8oJ+KchSBGYWlsdXJlIGRldGVjdGlvbiBtb25pdG9yaW5nIHN0YXJ0ZWQnKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RhcnQgZmFpbHVyZSBkZXRlY3Rpb246JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgaGVhbHRoIGNoZWNrIGZvciBhIHNwZWNpZmljIHNlcnZpY2VcclxuICAgKiBcclxuICAgKiBAcGFyYW0gc2VydmljZU5hbWUgU2VydmljZSBuYW1lXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGFydEhlYWx0aENoZWNrKHNlcnZpY2VOYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGVyZm9ybUhlYWx0aENoZWNrKHNlcnZpY2VOYW1lKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoYOKdjCBIZWFsdGggY2hlY2sgZmFpbGVkIGZvciAke3NlcnZpY2VOYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0sIHRoaXMuZmFpbHVyZURldGVjdGlvbkNvbmZpZy5oZWFsdGhDaGVja0ludGVydmFsKTtcclxuXHJcbiAgICB0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWxzLnNldChzZXJ2aWNlTmFtZSwgaW50ZXJ2YWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGVyZm9ybSBoZWFsdGggY2hlY2sgZm9yIGEgc2VydmljZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtSGVhbHRoQ2hlY2soc2VydmljZU5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5yZWNvdmVyeVN0YXR1cy5nZXQoc2VydmljZU5hbWUpO1xyXG4gICAgICBpZiAoIXN0YXR1cykgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgc2VydmljZSBzdGF0dXMgdXNpbmcgc3lzdGVtY3RsXHJcbiAgICAgIGNvbnN0IGlzSGVhbHRoeSA9IGF3YWl0IHRoaXMuY2hlY2tTZXJ2aWNlSGVhbHRoKHNlcnZpY2VOYW1lKTtcclxuICAgICAgXHJcbiAgICAgIHN0YXR1cy5sYXN0SGVhbHRoQ2hlY2sgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBcclxuICAgICAgaWYgKGlzSGVhbHRoeSkge1xyXG4gICAgICAgIHN0YXR1cy5oZWFsdGhTdGF0dXMgPSAnaGVhbHRoeSc7XHJcbiAgICAgICAgc3RhdHVzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXR1cy5oZWFsdGhTdGF0dXMgPSAndW5oZWFsdGh5JztcclxuICAgICAgICBzdGF0dXMuY29uc2VjdXRpdmVGYWlsdXJlcysrO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxvZ2dlci53YXJuKGDimqDvuI8gSGVhbHRoIGNoZWNrIGZhaWxlZCBmb3IgJHtzZXJ2aWNlTmFtZX0gKCR7c3RhdHVzLmNvbnNlY3V0aXZlRmFpbHVyZXN9LyR7dGhpcy5mYWlsdXJlRGV0ZWN0aW9uQ29uZmlnLm1heENvbnNlY3V0aXZlRmFpbHVyZXN9KWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyaWdnZXIgcmVjb3ZlcnkgaWYgdGhyZXNob2xkIGV4Y2VlZGVkXHJcbiAgICAgICAgaWYgKHN0YXR1cy5jb25zZWN1dGl2ZUZhaWx1cmVzID49IHRoaXMuZmFpbHVyZURldGVjdGlvbkNvbmZpZy5tYXhDb25zZWN1dGl2ZUZhaWx1cmVzKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnRyaWdnZXJTZXJ2aWNlUmVjb3Zlcnkoc2VydmljZU5hbWUsICdjb25zZWN1dGl2ZV9oZWFsdGhfY2hlY2tfZmFpbHVyZXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoYOKdjCBIZWFsdGggY2hlY2sgZXJyb3IgZm9yICR7c2VydmljZU5hbWV9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIHNlcnZpY2UgaGVhbHRoIHVzaW5nIHN5c3RlbWN0bFxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPGJvb2xlYW4+IFRydWUgaWYgaGVhbHRoeVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgY2hlY2tTZXJ2aWNlSGVhbHRoKHNlcnZpY2VOYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXhlY1N5bmMgfSA9IGF3YWl0IGltcG9ydCgnY2hpbGRfcHJvY2VzcycpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgc2VydmljZSBpcyBhY3RpdmVcclxuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoYHN5c3RlbWN0bCBpcy1hY3RpdmUgJHtzZXJ2aWNlTmFtZX1gLCB7IFxyXG4gICAgICAgIHN0ZGlvOiAncGlwZScsXHJcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiByZXN1bHQudHJpbSgpID09PSAnYWN0aXZlJztcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIGNvbXByZWhlbnNpdmUgZmFpbHVyZSBkZXRlY3Rpb25cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtRmFpbHVyZURldGVjdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZvciAoY29uc3Qgc2VydmljZU5hbWUgb2YgdGhpcy5zZXJ2aWNlcy5rZXlzKCkpIHtcclxuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnJlY292ZXJ5U3RhdHVzLmdldChzZXJ2aWNlTmFtZSk7XHJcbiAgICAgICAgaWYgKCFzdGF0dXMpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgc2VydmljZSBzdGF0dXNcclxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlcnZpY2VTdGF0dXMoc2VydmljZU5hbWUpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgcmVzb3VyY2UgaXNzdWVzXHJcbiAgICAgICAgaWYgKHRoaXMuZmFpbHVyZURldGVjdGlvbkNvbmZpZy5lbmFibGVSZXNvdXJjZU1vbml0b3JpbmcpIHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuY2hlY2tSZXNvdXJjZVVzYWdlKHNlcnZpY2VOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciBsb2cgZXJyb3JzXHJcbiAgICAgICAgaWYgKHRoaXMuZmFpbHVyZURldGVjdGlvbkNvbmZpZy5lbmFibGVMb2dNb25pdG9yaW5nKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmNoZWNrTG9nRXJyb3JzKHNlcnZpY2VOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBGYWlsdXJlIGRldGVjdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgc2VydmljZSBzdGF0dXNcclxuICAgKiBcclxuICAgKiBAcGFyYW0gc2VydmljZU5hbWUgU2VydmljZSBuYW1lXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlU2VydmljZVN0YXR1cyhzZXJ2aWNlTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5yZWNvdmVyeVN0YXR1cy5nZXQoc2VydmljZU5hbWUpO1xyXG4gICAgICBpZiAoIXN0YXR1cykgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gR2V0IHNlcnZpY2Ugc3RhdHVzXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKGBzeXN0ZW1jdGwgc2hvdyAke3NlcnZpY2VOYW1lfSAtLXByb3BlcnR5PUFjdGl2ZVN0YXRlLFN1YlN0YXRlYCwge1xyXG4gICAgICAgIHN0ZGlvOiAncGlwZScsXHJcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcclxuICAgICAgY29uc3QgYWN0aXZlU3RhdGUgPSBsaW5lcy5maW5kKGxpbmUgPT4gbGluZS5zdGFydHNXaXRoKCdBY3RpdmVTdGF0ZT0nKSk/LnNwbGl0KCc9JylbMV07XHJcbiAgICAgIGNvbnN0IHN1YlN0YXRlID0gbGluZXMuZmluZChsaW5lID0+IGxpbmUuc3RhcnRzV2l0aCgnU3ViU3RhdGU9JykpPy5zcGxpdCgnPScpWzFdO1xyXG5cclxuICAgICAgLy8gTWFwIHN5c3RlbWQgc3RhdGVzIHRvIG91ciBzdGF0dXNcclxuICAgICAgaWYgKGFjdGl2ZVN0YXRlID09PSAnYWN0aXZlJyAmJiBzdWJTdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XHJcbiAgICAgICAgc3RhdHVzLnN0YXR1cyA9ICdydW5uaW5nJztcclxuICAgICAgfSBlbHNlIGlmIChhY3RpdmVTdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcclxuICAgICAgICBzdGF0dXMuc3RhdHVzID0gJ2ZhaWxlZCc7XHJcbiAgICAgICAgaWYgKHN0YXR1cy5sYXN0RmFpbHVyZVJlYXNvbiAhPT0gJ3N5c3RlbWRfZmFpbGVkJykge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy50cmlnZ2VyU2VydmljZVJlY292ZXJ5KHNlcnZpY2VOYW1lLCAnc3lzdGVtZF9mYWlsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZlU3RhdGUgPT09ICdhY3RpdmF0aW5nJykge1xyXG4gICAgICAgIHN0YXR1cy5zdGF0dXMgPSAncmVzdGFydGluZyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhdHVzLnN0YXR1cyA9ICdzdG9wcGVkJztcclxuICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihg4p2MIEZhaWxlZCB0byB1cGRhdGUgc3RhdHVzIGZvciAke3NlcnZpY2VOYW1lfTpgLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayByZXNvdXJjZSB1c2FnZSBmb3IgYSBzZXJ2aWNlXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHNlcnZpY2VOYW1lIFNlcnZpY2UgbmFtZVxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGNoZWNrUmVzb3VyY2VVc2FnZShzZXJ2aWNlTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUaGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIHN5c3RlbSBtb25pdG9yaW5nIHRvIGNoZWNrIHJlc291cmNlIHVzYWdlXHJcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIGltcGxlbWVudCBhIGJhc2ljIGNoZWNrXHJcbiAgICAgIFxyXG4gICAgICBpZiAoc2VydmljZU5hbWUgPT09ICdhaS1jcnlwdG8tdHJhZGluZy1hZ2VudCcpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcclxuICAgICAgICBjb25zdCBtZW1vcnlVc2FnZVBlcmNlbnQgPSAobWVtb3J5VXNhZ2UuaGVhcFVzZWQgLyBtZW1vcnlVc2FnZS5oZWFwVG90YWwpICogMTAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChtZW1vcnlVc2FnZVBlcmNlbnQgPiB0aGlzLmZhaWx1cmVEZXRlY3Rpb25Db25maWcubWVtb3J5VGhyZXNob2xkKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnRyaWdnZXJTZXJ2aWNlUmVjb3Zlcnkoc2VydmljZU5hbWUsIGBoaWdoX21lbW9yeV91c2FnZV8ke21lbW9yeVVzYWdlUGVyY2VudC50b0ZpeGVkKDEpfSVgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoYOKdjCBSZXNvdXJjZSB1c2FnZSBjaGVjayBmYWlsZWQgZm9yICR7c2VydmljZU5hbWV9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGZvciBsb2cgZXJyb3JzXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHNlcnZpY2VOYW1lIFNlcnZpY2UgbmFtZVxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGNoZWNrTG9nRXJyb3JzKHNlcnZpY2VOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXhlY1N5bmMgfSA9IGF3YWl0IGltcG9ydCgnY2hpbGRfcHJvY2VzcycpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgcmVjZW50IGpvdXJuYWwgZW50cmllcyBmb3IgZXJyb3IgcGF0dGVybnNcclxuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoYGpvdXJuYWxjdGwgLXUgJHtzZXJ2aWNlTmFtZX0gLS1zaW5jZSBcIjUgbWludXRlcyBhZ29cIiAtLW5vLXBhZ2VyYCwge1xyXG4gICAgICAgIHN0ZGlvOiAncGlwZScsXHJcbiAgICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLmZhaWx1cmVEZXRlY3Rpb25Db25maWcuZXJyb3JQYXR0ZXJucykge1xyXG4gICAgICAgIGlmIChyZXN1bHQuaW5jbHVkZXMocGF0dGVybikpIHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMudHJpZ2dlclNlcnZpY2VSZWNvdmVyeShzZXJ2aWNlTmFtZSwgYGxvZ19lcnJvcl9wYXR0ZXJuXyR7cGF0dGVybn1gKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIElnbm9yZSBlcnJvcnMgLSBzZXJ2aWNlIG1pZ2h0IG5vdCBleGlzdCB5ZXRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgc2VydmljZSByZWNvdmVyeVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgKiBAcGFyYW0gcmVhc29uIEZhaWx1cmUgcmVhc29uXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgdHJpZ2dlclNlcnZpY2VSZWNvdmVyeShzZXJ2aWNlTmFtZTogc3RyaW5nLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5yZWNvdmVyeVN0YXR1cy5nZXQoc2VydmljZU5hbWUpO1xyXG4gICAgICBpZiAoIXN0YXR1cykgcmV0dXJuO1xyXG5cclxuICAgICAgbG9nZ2VyLndhcm4oYPCflIQgVHJpZ2dlcmluZyByZWNvdmVyeSBmb3IgJHtzZXJ2aWNlTmFtZX0gLSBSZWFzb246ICR7cmVhc29ufWApO1xyXG5cclxuICAgICAgc3RhdHVzLmxhc3RGYWlsdXJlUmVhc29uID0gcmVhc29uO1xyXG4gICAgICBzdGF0dXMucmVzdGFydENvdW50Kys7XHJcbiAgICAgIHN0YXR1cy5sYXN0UmVzdGFydCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIHN0YXR1cy5yZWNvdmVyeUFjdGlvbnMucHVzaChgcmVzdGFydF8ke0RhdGUubm93KCl9XyR7cmVhc29ufWApO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybSByZWNvdmVyeSBhY3Rpb25zXHJcbiAgICAgIGF3YWl0IHRoaXMucGVyZm9ybVJlY292ZXJ5QWN0aW9ucyhzZXJ2aWNlTmFtZSwgcmVhc29uKTtcclxuXHJcbiAgICAgIC8vIEF1ZGl0IGxvZ1xyXG4gICAgICBhd2FpdCBhdWRpdFNlcnZpY2UuY3JlYXRlQXVkaXRFbnRyeSh7XHJcbiAgICAgICAgYXVkaXRJZDogYHNlcnZpY2VfcmVjb3ZlcnlfJHtzZXJ2aWNlTmFtZX1fJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgZXZlbnRUeXBlOiAnU0VSVklDRV9SRUNPVkVSWV9UUklHR0VSRUQnLFxyXG4gICAgICAgIGFjdG9yOiAnQVVUT19SRVNUQVJUX01BTkFHRVInLFxyXG4gICAgICAgIHJlc291cmNlOiBgU0VSVklDRV8ke3NlcnZpY2VOYW1lLnRvVXBwZXJDYXNlKCl9YCxcclxuICAgICAgICBhY3Rpb246ICdUUklHR0VSX1JFQ09WRVJZJyxcclxuICAgICAgICByZXN1bHQ6ICdTVUNDRVNTJyxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgYXVkaXREYXRhOiB7IFxyXG4gICAgICAgICAgc2VydmljZU5hbWUsXHJcbiAgICAgICAgICByZWFzb24sXHJcbiAgICAgICAgICByZXN0YXJ0Q291bnQ6IHN0YXR1cy5yZXN0YXJ0Q291bnQsXHJcbiAgICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzOiBzdGF0dXMuY29uc2VjdXRpdmVGYWlsdXJlc1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBFbWl0IHJlY292ZXJ5IGV2ZW50XHJcbiAgICAgIHRoaXMuZW1pdCgnc2VydmljZVJlY292ZXJ5JywgeyBzZXJ2aWNlTmFtZSwgcmVhc29uLCBzdGF0dXMgfSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKGDinYwgU2VydmljZSByZWNvdmVyeSBmYWlsZWQgZm9yICR7c2VydmljZU5hbWV9OmAsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm0gcmVjb3ZlcnkgYWN0aW9ucyBmb3IgYSBzZXJ2aWNlXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHNlcnZpY2VOYW1lIFNlcnZpY2UgbmFtZVxyXG4gICAqIEBwYXJhbSByZWFzb24gRmFpbHVyZSByZWFzb25cclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtUmVjb3ZlcnlBY3Rpb25zKHNlcnZpY2VOYW1lOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuXHJcbiAgICAgIC8vIFN0b3Agc2VydmljZSBncmFjZWZ1bGx5IGZpcnN0XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXhlY1N5bmMoYHN1ZG8gc3lzdGVtY3RsIHN0b3AgJHtzZXJ2aWNlTmFtZX1gLCB7IHN0ZGlvOiAncGlwZScsIHRpbWVvdXQ6IDEwMDAwIH0pO1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgbG9nZ2VyLndhcm4oYOKaoO+4jyBHcmFjZWZ1bCBzdG9wIGZhaWxlZCBmb3IgJHtzZXJ2aWNlTmFtZX0sIGZvcmNpbmcgc3RvcGApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGb3JjZSBraWxsIGlmIG5lY2Vzc2FyeVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGV4ZWNTeW5jKGBzdWRvIHN5c3RlbWN0bCBraWxsICR7c2VydmljZU5hbWV9YCwgeyBzdGRpbzogJ3BpcGUnIH0pO1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgLy8gSWdub3JlIC0gc2VydmljZSBtaWdodCBhbHJlYWR5IGJlIHN0b3BwZWRcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2xlYXIgYW55IGZhaWxlZCBzdGF0ZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGV4ZWNTeW5jKGBzdWRvIHN5c3RlbWN0bCByZXNldC1mYWlsZWQgJHtzZXJ2aWNlTmFtZX1gLCB7IHN0ZGlvOiAncGlwZScgfSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgLy8gSWdub3JlIC0gc2VydmljZSBtaWdodCBub3QgYmUgaW4gZmFpbGVkIHN0YXRlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlc3RhcnQgc2VydmljZVxyXG4gICAgICBleGVjU3luYyhgc3VkbyBzeXN0ZW1jdGwgc3RhcnQgJHtzZXJ2aWNlTmFtZX1gLCB7IHN0ZGlvOiAncGlwZScgfSk7XHJcblxyXG4gICAgICBsb2dnZXIuaW5mbyhg4pyFIFNlcnZpY2UgJHtzZXJ2aWNlTmFtZX0gcmVzdGFydGVkIHN1Y2Nlc3NmdWxseWApO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihg4p2MIFJlY292ZXJ5IGFjdGlvbnMgZmFpbGVkIGZvciAke3NlcnZpY2VOYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0dXAgZ3JhY2VmdWwgc2h1dGRvd24gaGFuZGxlcnNcclxuICAgKi9cclxuICBwcml2YXRlIHNldHVwR3JhY2VmdWxTaHV0ZG93bkhhbmRsZXJzKCk6IHZvaWQge1xyXG4gICAgLy8gSGFuZGxlIHNodXRkb3duIHNpZ25hbHNcclxuICAgIHByb2Nlc3Mub24oJ1NJR1RFUk0nLCAoKSA9PiB0aGlzLmhhbmRsZUdyYWNlZnVsU2h1dGRvd24oJ1NJR1RFUk0nKSk7XHJcbiAgICBwcm9jZXNzLm9uKCdTSUdJTlQnLCAoKSA9PiB0aGlzLmhhbmRsZUdyYWNlZnVsU2h1dGRvd24oJ1NJR0lOVCcpKTtcclxuICAgIHByb2Nlc3Mub24oJ1NJR0hVUCcsICgpID0+IHRoaXMuaGFuZGxlR3JhY2VmdWxTaHV0ZG93bignU0lHSFVQJykpO1xyXG5cclxuICAgIGxvZ2dlci5pbmZvKCfinIUgR3JhY2VmdWwgc2h1dGRvd24gaGFuZGxlcnMgY29uZmlndXJlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGdyYWNlZnVsIHNodXRkb3duXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHNpZ25hbCBTaHV0ZG93biBzaWduYWxcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVHcmFjZWZ1bFNodXRkb3duKHNpZ25hbDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5pc1NodXR0aW5nRG93bikge1xyXG4gICAgICBsb2dnZXIud2Fybign4pqg77iPIFNodXRkb3duIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaXNTaHV0dGluZ0Rvd24gPSB0cnVlO1xyXG4gICAgbG9nZ2VyLmluZm8oYPCfm5EgR3JhY2VmdWwgc2h1dGRvd24gaW5pdGlhdGVkIC0gU2lnbmFsOiAke3NpZ25hbH1gKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzaHV0ZG93blByb21pc2UgPSB0aGlzLnBlcmZvcm1HcmFjZWZ1bFNodXRkb3duKCk7XHJcbiAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdTaHV0ZG93biB0aW1lb3V0JykpLCB0aGlzLnNodXRkb3duQ29uZmlnLnRpbWVvdXQpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW3NodXRkb3duUHJvbWlzZSwgdGltZW91dFByb21pc2VdKTtcclxuICAgICAgXHJcbiAgICAgIGxvZ2dlci5pbmZvKCfinIUgR3JhY2VmdWwgc2h1dGRvd24gY29tcGxldGVkJyk7XHJcbiAgICAgIHByb2Nlc3MuZXhpdCgwKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBHcmFjZWZ1bCBzaHV0ZG93biBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIGdyYWNlZnVsIHNodXRkb3duIHByb2NlZHVyZXNcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtR3JhY2VmdWxTaHV0ZG93bigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFN0b3AgbW9uaXRvcmluZ1xyXG4gICAgICB0aGlzLnN0b3BNb25pdG9yaW5nKCk7XHJcblxyXG4gICAgICAvLyBFeGVjdXRlIHNodXRkb3duIGhvb2tzXHJcbiAgICAgIGZvciAoY29uc3QgaG9vayBvZiB0aGlzLnNodXRkb3duQ29uZmlnLnNodXRkb3duSG9va3MpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgaG9vaygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBTaHV0ZG93biBob29rIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdG9wIGFsbCBtYW5hZ2VkIHNlcnZpY2VzXHJcbiAgICAgIGF3YWl0IHRoaXMuc3RvcEFsbFNlcnZpY2VzKCk7XHJcblxyXG4gICAgICAvLyBTZW5kIHNodXRkb3duIG5vdGlmaWNhdGlvbnNcclxuICAgICAgaWYgKHRoaXMuc2h1dGRvd25Db25maWcuc2VuZE5vdGlmaWNhdGlvbnMpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRTaHV0ZG93bk5vdGlmaWNhdGlvbnMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIGZpbmFsIGF1ZGl0IGVudHJ5XHJcbiAgICAgIGF3YWl0IGF1ZGl0U2VydmljZS5jcmVhdGVBdWRpdEVudHJ5KHtcclxuICAgICAgICBhdWRpdElkOiBgZ3JhY2VmdWxfc2h1dGRvd25fJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgZXZlbnRUeXBlOiAnR1JBQ0VGVUxfU0hVVERPV05fQ09NUExFVEVEJyxcclxuICAgICAgICBhY3RvcjogJ0FVVE9fUkVTVEFSVF9NQU5BR0VSJyxcclxuICAgICAgICByZXNvdXJjZTogJ1NZU1RFTScsXHJcbiAgICAgICAgYWN0aW9uOiAnR1JBQ0VGVUxfU0hVVERPV04nLFxyXG4gICAgICAgIHJlc3VsdDogJ1NVQ0NFU1MnLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICBhdWRpdERhdGE6IHsgc2h1dGRvd25Db25maWc6IHRoaXMuc2h1dGRvd25Db25maWcgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBHcmFjZWZ1bCBzaHV0ZG93biBwcm9jZWR1cmVzIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBhbGwgbW9uaXRvcmluZyBhY3Rpdml0aWVzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdG9wTW9uaXRvcmluZygpOiB2b2lkIHtcclxuICAgIC8vIFN0b3AgbWFpbiBtb25pdG9yaW5nIGludGVydmFsXHJcbiAgICBpZiAodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCk7XHJcbiAgICAgIHRoaXMubW9uaXRvcmluZ0ludGVydmFsID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdG9wIGhlYWx0aCBjaGVjayBpbnRlcnZhbHNcclxuICAgIGZvciAoY29uc3QgW3NlcnZpY2VOYW1lLCBpbnRlcnZhbF0gb2YgdGhpcy5oZWFsdGhDaGVja0ludGVydmFscykge1xyXG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgIH1cclxuICAgIHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbHMuY2xlYXIoKTtcclxuXHJcbiAgICBsb2dnZXIuaW5mbygn8J+bkSBNb25pdG9yaW5nIHN0b3BwZWQnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgYWxsIG1hbmFnZWQgc2VydmljZXNcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBzdG9wQWxsU2VydmljZXMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuXHJcbiAgICAgIC8vIFN0b3Agc2VydmljZXMgaW4gcmV2ZXJzZSBkZXBlbmRlbmN5IG9yZGVyXHJcbiAgICAgIGNvbnN0IHNlcnZpY2VPcmRlciA9IFsnYWktY3J5cHRvLXRyYWRpbmctYWdlbnQnLCAnc3lzdGVtLW1vbml0b3InLCAnc3NoLXR1bm5lbCddO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBzZXJ2aWNlTmFtZSBvZiBzZXJ2aWNlT3JkZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlcy5oYXMoc2VydmljZU5hbWUpKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBleGVjU3luYyhgc3VkbyBzeXN0ZW1jdGwgc3RvcCAke3NlcnZpY2VOYW1lfWAsIHsgc3RkaW86ICdwaXBlJywgdGltZW91dDogMTAwMDAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGDinIUgU3RvcHBlZCBzZXJ2aWNlOiAke3NlcnZpY2VOYW1lfWApO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYOKaoO+4jyBGYWlsZWQgdG8gc3RvcCBzZXJ2aWNlICR7c2VydmljZU5hbWV9OmAsIGVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc3RvcCBzZXJ2aWNlczonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIHNodXRkb3duIG5vdGlmaWNhdGlvbnNcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBzZW5kU2h1dGRvd25Ob3RpZmljYXRpb25zKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVGhpcyB3b3VsZCBpbnRlZ3JhdGUgd2l0aCBub3RpZmljYXRpb24gc2VydmljZVxyXG4gICAgICBsb2dnZXIuaW5mbygn8J+TpyBTaHV0ZG93biBub3RpZmljYXRpb25zIHNlbnQnKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcign4p2MIEZhaWxlZCB0byBzZW5kIHNodXRkb3duIG5vdGlmaWNhdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIHNodXRkb3duIGhvb2tcclxuICAgKiBcclxuICAgKiBAcGFyYW0gaG9vayBTaHV0ZG93biBob29rIGZ1bmN0aW9uXHJcbiAgICovXHJcbiAgcHVibGljIGFkZFNodXRkb3duSG9vayhob29rOiAoKSA9PiBQcm9taXNlPHZvaWQ+KTogdm9pZCB7XHJcbiAgICB0aGlzLnNodXRkb3duQ29uZmlnLnNodXRkb3duSG9va3MucHVzaChob29rKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCByZWNvdmVyeSBzdGF0dXMgZm9yIGFsbCBzZXJ2aWNlc1xyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIE1hcDxzdHJpbmcsIFJlY292ZXJ5U3RhdHVzPiBSZWNvdmVyeSBzdGF0dXMgbWFwXHJcbiAgICovXHJcbiAgcHVibGljIGdldFJlY292ZXJ5U3RhdHVzKCk6IE1hcDxzdHJpbmcsIFJlY292ZXJ5U3RhdHVzPiB7XHJcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLnJlY292ZXJ5U3RhdHVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCByZWNvdmVyeSBzdGF0dXMgZm9yIGEgc3BlY2lmaWMgc2VydmljZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgKiBAcmV0dXJucyBSZWNvdmVyeVN0YXR1cyB8IG51bGwgUmVjb3Zlcnkgc3RhdHVzXHJcbiAgICovXHJcbiAgcHVibGljIGdldFNlcnZpY2VSZWNvdmVyeVN0YXR1cyhzZXJ2aWNlTmFtZTogc3RyaW5nKTogUmVjb3ZlcnlTdGF0dXMgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLnJlY292ZXJ5U3RhdHVzLmdldChzZXJ2aWNlTmFtZSkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBtYW5hZ2VyIHN0YXR1c1xyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIHN0YXR1cyBpbmZvcm1hdGlvblxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRTdGF0dXMoKToge1xyXG4gICAgaXNNb25pdG9yaW5nOiBib29sZWFuO1xyXG4gICAgc2VydmljZXNDb3VudDogbnVtYmVyO1xyXG4gICAgYWN0aXZlU2VydmljZXM6IG51bWJlcjtcclxuICAgIGZhaWxlZFNlcnZpY2VzOiBudW1iZXI7XHJcbiAgICB0b3RhbFJlc3RhcnRzOiBudW1iZXI7XHJcbiAgICBpc1NodXR0aW5nRG93bjogYm9vbGVhbjtcclxuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIH0ge1xyXG4gICAgY29uc3QgYWN0aXZlU2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMucmVjb3ZlcnlTdGF0dXMudmFsdWVzKCkpXHJcbiAgICAgIC5maWx0ZXIoc3RhdHVzID0+IHN0YXR1cy5zdGF0dXMgPT09ICdydW5uaW5nJykubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBjb25zdCBmYWlsZWRTZXJ2aWNlcyA9IEFycmF5LmZyb20odGhpcy5yZWNvdmVyeVN0YXR1cy52YWx1ZXMoKSlcclxuICAgICAgLmZpbHRlcihzdGF0dXMgPT4gc3RhdHVzLnN0YXR1cyA9PT0gJ2ZhaWxlZCcpLmxlbmd0aDtcclxuICAgIFxyXG4gICAgY29uc3QgdG90YWxSZXN0YXJ0cyA9IEFycmF5LmZyb20odGhpcy5yZWNvdmVyeVN0YXR1cy52YWx1ZXMoKSlcclxuICAgICAgLnJlZHVjZSgoc3VtLCBzdGF0dXMpID0+IHN1bSArIHN0YXR1cy5yZXN0YXJ0Q291bnQsIDApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzTW9uaXRvcmluZzogdGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwgIT09IG51bGwsXHJcbiAgICAgIHNlcnZpY2VzQ291bnQ6IHRoaXMuc2VydmljZXMuc2l6ZSxcclxuICAgICAgYWN0aXZlU2VydmljZXMsXHJcbiAgICAgIGZhaWxlZFNlcnZpY2VzLFxyXG4gICAgICB0b3RhbFJlc3RhcnRzLFxyXG4gICAgICBpc1NodXR0aW5nRG93bjogdGhpcy5pc1NodXR0aW5nRG93bixcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gQVVUTy1SRVNUQVJUIEFORCBSRUNPVkVSWSBTWVNURU0gTk9URVNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gMS4gU3lzdGVtZCBzZXJ2aWNlIGZpbGUgZ2VuZXJhdGlvbiBmb3IgYXV0b21hdGljIHN0YXJ0dXBcclxuLy8gMi4gQ29tcHJlaGVuc2l2ZSBmYWlsdXJlIGRldGVjdGlvbiBhbmQgaGVhbHRoIG1vbml0b3JpbmdcclxuLy8gMy4gQXV0b21hdGljIHNlcnZpY2UgcmVjb3Zlcnkgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXHJcbi8vIDQuIEdyYWNlZnVsIHNodXRkb3duIHByb2NlZHVyZXMgd2l0aCBwb3NpdGlvbiBjbG9zdXJlXHJcbi8vIDUuIERlcGVuZGVuY3kgbWFuYWdlbWVudCBmb3IgcHJvcGVyIHNlcnZpY2Ugc3RhcnR1cCBvcmRlclxyXG4vLyA2LiBSZXNvdXJjZSBtb25pdG9yaW5nIGFuZCBhdXRvbWF0aWMgcmVzdGFydCBvbiB0aHJlc2hvbGQgYnJlYWNoXHJcbi8vIDcuIExvZyBtb25pdG9yaW5nIGZvciBlcnJvciBwYXR0ZXJuIGRldGVjdGlvblxyXG4vLyA4LiBDb21wcmVoZW5zaXZlIGF1ZGl0IGxvZ2dpbmcgZm9yIGFsbCByZWNvdmVyeSBhY3Rpb25zXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiJdLCJ2ZXJzaW9uIjozfQ==